<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AQS 介绍</title>
    <url>/2020/06/08/AQS%20%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="AQS-介绍"><a href="#AQS-介绍" class="headerlink" title="AQS 介绍"></a>AQS 介绍</h3><p>一、基础介绍</p>
<p>1.AQS(AbstractQueuedSynchronizer),是构建锁和同步器的框架。ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock都是基于 AQS 实现的</p>
<p>2.原理：</p>
<ul>
<li><p>概述：如果请求的共享资源空闲，则将当前请求的线程设置为有效的工作线程，并将资源设置成锁定状态。如果资源被占用，AQS 会利用 <strong>CLH 队列锁</strong>实现阻塞以及等待唤醒的锁分配机制，将等待的线程加入队列中，等待资源空闲时系统的锁分配。</p>
<ul>
<li>其中：CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</li>
</ul>
</li>
<li><p>同步：AQS使用的一个 int 变量表示同步状态，通过内置的 FIFO队列获取线程队列，并且使用 CAS 操作进行状态的修改（即 protected 修饰的 getState()/setState()/compareAndSetState()）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子操作（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>3.AQS 对资源的共享方式</p>
<ul>
<li><p>独占 Exclusive：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁,ReentrantLock 同时支持两种锁(默认公平锁)</p>
<ul>
<li>公平锁：先到先得，根据队列的排队顺序依次拿到锁</li>
<li>非公平锁：当前线程请求获得锁时，需要通过 两次CAS操作争抢锁，如果没有抢到锁，放入队列中等待唤醒。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock之公平锁 lock方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock之非公平锁 lock方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里没有对阻塞队列进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：公平锁和非公平锁之间存在两点不同：</p>
<ul>
<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>
</ul>
<p>公平锁和非公平锁就这两点区别，<strong>如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</strong></p>
<p>相对来说，<strong>非公平锁会有更好的性能</strong>，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
</li>
<li><p>共享（Share）</p>
<p>多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p>
<p>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在上层已经帮我们实现好了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装 Nacos</title>
    <url>/2021/01/31/Docker%E5%AE%89%E8%A3%85-Nacos/</url>
    <content><![CDATA[<h1 id="docker命令安装单机版Nacos"><a href="#docker命令安装单机版Nacos" class="headerlink" title="docker命令安装单机版Nacos"></a>docker命令安装单机版Nacos</h1><h2 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search nacos</span><br></pre></td></tr></table></figure>

<h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>查阅官方文档可知，当前nacos稳定版本是 1.4.1，所以选择版本为 1.4.1 的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nacos&#x2F;nacos-server:1.4.1</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn6w3pkhq1j31ug0rydx2.jpg"></p>
<h2 id="创建配置文件和日志文件"><a href="#创建配置文件和日志文件" class="headerlink" title="创建配置文件和日志文件"></a>创建配置文件和日志文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;opt&#x2F;nacos&#x2F;init.d</span><br><span class="line">mkdir -p &#x2F;opt&#x2F;nacos&#x2F;logs</span><br><span class="line">cd &#x2F;opt&#x2F;nacos&#x2F;init.d</span><br><span class="line">touch custom.properties</span><br></pre></td></tr></table></figure>

<p>在<code>custom.properties</code>文件中填写如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">management.endpoints.web.exposure.include&#x3D;*</span><br></pre></td></tr></table></figure>

<p>注意：在 MacOS 环境中，上述命令创建的文件或文件夹要在Docker 的 File Sharing 中配置，否则会出现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker: Error response from daemon: Mounts denied: </span><br><span class="line">The path &#x2F;opt&#x2F;nacos&#x2F;init.d&#x2F;custom.properties is not shared from the host and is not known to Docker.</span><br><span class="line">You can configure shared paths from Docker -&gt; Preferences... -&gt; Resources -&gt; File Sharing.</span><br><span class="line">See https:&#x2F;&#x2F;docs.docker.com&#x2F;docker-for-mac for more info.</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn6w44aoj4j31g10u078o.jpg"></p>
<h2 id="创建并启动容器（单机模式）"><a href="#创建并启动容器（单机模式）" class="headerlink" title="创建并启动容器（单机模式）"></a>创建并启动容器（单机模式）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8848:8848 -e MODE&#x3D;standalone \     </span><br><span class="line">-v &#x2F;Users&#x2F;heyou-macbook&#x2F;Desktop&#x2F;docker-nacos&#x2F;nacos&#x2F;init.d&#x2F;custom.properties:&#x2F;home&#x2F;nacos&#x2F;init.d&#x2F;custom.properties \</span><br><span class="line">-v &#x2F;Users&#x2F;heyou-macbook&#x2F;Desktop&#x2F;docker-nacos&#x2F;nacos&#x2F;logs:&#x2F;home&#x2F;nacos&#x2F;logs \</span><br><span class="line">--restart always \</span><br><span class="line">--name my-nacos nacos&#x2F;nacos-server:1.4.1</span><br></pre></td></tr></table></figure>

<p>访问 localhost:8848/nacos 输入用户名/密码：nacos/nacos 即可进入 nacos 注册中心控制台。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn6w441eowj31jn0u0q85.jpg"></p>
]]></content>
      <categories>
        <category>分布式框架</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch 入门简介与安装</title>
    <url>/2020/05/22/ElasticSearch%20%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>下载：<a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></li>
</ol>
<p>选择合适的版本进行下载</p>
<ol start="2">
<li><p>解压安装：进入文件目录</p>
</li>
<li><p>启动：bin/elasticsearch</p>
</li>
<li><p>验证：访问 localhost:9200,如果出现以下内容则表示安装成功：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;Xp6GcoT&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span> : <span class="string">&quot;elasticsearch&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;cluster_uuid&quot;</span> : <span class="string">&quot;Sbk-IMRCSgKTUEuW8ygOTQ&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;number&quot;</span> : <span class="string">&quot;6.8.7&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_flavor&quot;</span> : <span class="string">&quot;oss&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_type&quot;</span> : <span class="string">&quot;tar&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_hash&quot;</span> : <span class="string">&quot;c63e621&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_date&quot;</span> : <span class="string">&quot;2020-02-26T14:38:01.193138Z&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_snapshot&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;lucene_version&quot;</span> : <span class="string">&quot;7.7.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;minimum_wire_compatibility_version&quot;</span> : <span class="string">&quot;5.6.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;minimum_index_compatibility_version&quot;</span> : <span class="string">&quot;5.0.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;tagline&quot;</span> : <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="全文搜索-Full-text-Search"><a href="#全文搜索-Full-text-Search" class="headerlink" title="全文搜索(Full-text Search)"></a>全文搜索(Full-text Search)</h4><p>  全文检索是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。<br>  在全文搜索的世界中，存在着几个庞大的帝国，也就是主流工具，主要有：</p>
<ul>
<li>Apache Lucene</li>
<li>Elasticsearch</li>
<li>Solr</li>
<li>Ferret</li>
</ul>
<h4 id="倒排索引（Inverted-Index）"><a href="#倒排索引（Inverted-Index）" class="headerlink" title="倒排索引（Inverted Index）"></a>倒排索引（Inverted Index）</h4><p>  该索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)。Elasticsearch能够实现快速、高效的搜索功能，正是基于倒排索引原理。</p>
<h4 id="节点-amp-集群（Node-amp-Cluster）"><a href="#节点-amp-集群（Node-amp-Cluster）" class="headerlink" title="节点 &amp; 集群（Node &amp; Cluster）"></a>节点 &amp; 集群（Node &amp; Cluster）</h4><p>  Elasticsearch 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个Elasticsearch实例。单个Elasticsearch实例称为一个节点（Node），一组节点构成一个集群（Cluster）。只要将不同的实例节点改成相同的节点名称即可组成一个集群。</p>
<h4 id="索引（Index）"><a href="#索引（Index）" class="headerlink" title="索引（Index）"></a>索引（Index）</h4><p>  Elasticsearch 数据管理的顶层单位就叫做 Index（索引），相当于关系型数据库里的数据库的概念。另外，每个Index的名字必须是小写。</p>
<h4 id="文档（Document）"><a href="#文档（Document）" class="headerlink" title="文档（Document）"></a>文档（Document）</h4><p>  Index里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。Document 使用 JSON 格式表示。同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p>
<h4 id="类型（Type）"><a href="#类型（Type）" class="headerlink" title="类型（Type）"></a>类型（Type）</h4><p>  Document 可以分组，比如employee这个 Index 里面，可以按部门分组，也可以按职级分组。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document，类似关系型数据库中的数据表。<br>  不同的 Type 应该有相似的结构（Schema），性质完全不同的数据（比如 products 和 logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。</p>
<h3 id="文档元数据（Document-metadata）"><a href="#文档元数据（Document-metadata）" class="headerlink" title="文档元数据（Document metadata）"></a>文档元数据（Document metadata）</h3><p>  文档元数据为_index, _type, _id, 这三者可以唯一表示一个文档，_index表示文档在哪存放，_type表示文档的对象类别，_id为文档的唯一标识。</p>
<h4 id="字段（Fields）"><a href="#字段（Fields）" class="headerlink" title="字段（Fields）"></a>字段（Fields）</h4><p>  每个Document都类似一个JSON结构，它包含了许多字段，每个字段都有其对应的值，多个字段组成了一个 Document，可以类比关系型数据库数据表中的字段。<br>  在 Elasticsearch 中，文档（Document）归属于一种类型（Type），而这些类型存在于索引（Index）中，下图展示了Elasticsearch与传统关系型数据库的类比：</p>
<table>
<thead>
<tr>
<th align="center">关系型数据库</th>
<th align="center">ElasticSearch</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DataBase</td>
<td align="center">Index</td>
</tr>
<tr>
<td align="center">Table</td>
<td align="center">Type</td>
</tr>
<tr>
<td align="center">Rows</td>
<td align="center">Documents</td>
</tr>
<tr>
<td align="center">Columns</td>
<td align="center">Fields</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>noSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Bean 的生命周期</title>
    <url>/2021/02/14/Bean%20%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="Bean-的创建"><a href="#Bean-的创建" class="headerlink" title="Bean 的创建"></a>Bean 的创建</h1><h2 id="生成-BeanDefinition"><a href="#生成-BeanDefinition" class="headerlink" title="生成 BeanDefinition"></a>生成 BeanDefinition</h2><p>Spring 启动是首先会扫描指定目录下的所有资源文件，遍历 Resource 生成元数据读取器（MetadataReader），通过 ASM 解析资源文件（class 文件），得到 class 文件的内部信息，并通过 <strong>ClassUtils.getDefaultClassLoader()所获得的类加载器</strong>去加载解析 class 文件得到的类对象。</p>
<p>注1：MetadataReader对象具有以下功能：</p>
<ul>
<li>获取对于的 Resource 资源</li>
<li>获取Resource 资源对于的 class 文件的内部与类相关的信息（类名、注解信息、父类信息，实现的接口信息，是否存在内部类等）</li>
<li>获取 class 文件中存在的注解信息包括类上注解以及方法上注解</li>
</ul>
<p>注 2：<strong>ClassUtils.getDefaultClassLoader()所获得的类加载器</strong>只针对扫描得到的 class 文件，不会加载调用该方法的类</p>
<p>当 MetadataReader 获取到 class 文件的内部信息之后，会生成一个ScannedGenericBeanDefinition对象。</p>
<p><strong>注意此时的BeanDefinition对象中的beanClass属性存储的是当前类的名字，而不是class对象</strong>。（beanClass属性的类型是Object，它即可以存储类的名字，也可以存储class对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MetadataReader包含了对应class的元信息以及注解元信息, MetadataReader</span></span><br><span class="line">	MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line">	<span class="comment">// 判断一个类是不是Component</span></span><br><span class="line">	<span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">		<span class="comment">// 通过扫描@Component得到的BeanDefinition为ScannedGenericBeanDefinition</span></span><br><span class="line">		ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line">		sbd.setResource(resource);</span><br><span class="line">		sbd.setSource(resource);</span><br><span class="line">		<span class="comment">// 再进一步验证是不是备选的Component</span></span><br><span class="line">		<span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Identified candidate component class: &quot;</span> + resource);</span><br><span class="line">			&#125;</span><br><span class="line">			candidates.add(sbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Ignored because not a concrete top-level class: &quot;</span> + resource);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Ignored because not matching any filter: &quot;</span> + resource);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>经过上述过程，会得到一个 BeanDefinition 的集合。</p>
<h2 id="合并-BeanDefinition"><a href="#合并-BeanDefinition" class="headerlink" title="合并 BeanDefinition"></a>合并 BeanDefinition</h2><p>获取父子 BeanDefinition，并进行合并，得到RootBeanDefinition。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 得到合并后的BeanDefinition</span></span><br><span class="line"> <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a merged RootBeanDefinition, traversing the parent bean definition</span></span><br><span class="line"><span class="comment"> * if the specified bean corresponds to a child bean definition.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean to retrieve the merged definition for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a (potentially merged) RootBeanDefinition for the given bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of an invalid bean definition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedLocalBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">	RootBeanDefinition mbd = <span class="keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">	<span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; !mbd.stale) &#123;</span><br><span class="line">		<span class="keyword">return</span> mbd;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> getMergedBeanDefinition(beanName, getBeanDefinition(beanName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并 BeanDefinition—-为了继承抽象类的作用域，是单例的还是原型（因为 <strong>Spring 会将抽象的 BeanDefinition 过滤掉</strong>）合并的结果会产生一个 mergedBeanDefinition，并且这个 BeanDefinition 中元素的类型都是 RootBeanDefinition而原始的 BeanDefinition 中的元素是GenericBeanDefinition 类型（原始的 BeanDefinition 也不是完整的 BeanDefinition）</p>
<p>合并是子 BeanDefinition 覆盖父的 BeanDefinition，不会改动原始的 BeanDefinition。</p>
<p>Spring中通过名字获取 BeanDefiniton,都是从 MergedBeanDefinition 中获取，如果有则返回，如果没有进行合并生成RootBeanDefinition。</p>
<h2 id="加载类"><a href="#加载类" class="headerlink" title="加载类"></a>加载类</h2><p>当创建好 BeanDefinition（RootBeanDefinition）之后，便开始加载当前 BeanDefinition所对应的 class。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line">		<span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line">		<span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">		Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">		<span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">			mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Prepare method overrides.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 对通过XML定义的bean中的look-up方法进行预处理</span></span><br><span class="line">			<span class="comment">// 对于@Lookup注解标注的方法不在这里进行处理，@AutowiredAnnotationBeanPostProcessor会处理@Lookup注解</span></span><br><span class="line">			mbdToUse.prepareMethodOverrides();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">					beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">			<span class="comment">// 1、实例化前 null</span></span><br><span class="line">			Object bean = resolveBeforeInstantiation(beanName, mbdToUse);  <span class="comment">// 对象</span></span><br><span class="line">			<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> bean;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 创建bean   Spring自带的创建bean的方法</span></span><br><span class="line">			Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">			<span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">			<span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>其中 resolveBeanClass() 具体实现是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果beanClass属性的类型是Class，那么直接返回beanClass</span></span><br><span class="line"><span class="keyword">if</span> (mbd.hasBeanClass()) &#123;</span><br><span class="line">		<span class="keyword">return</span> mbd.getBeanClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> AccessController.doPrivileged((PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;) () -&gt;</span><br><span class="line">		doResolveBeanClass(mbd, typesToMatch), getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 加载BeanDefinition中beanClass中所指定的类名对应的类</span></span><br><span class="line">		<span class="keyword">return</span> doResolveBeanClass(mbd, typesToMatch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载类是基于 BeanDefinition 中的Object 类型的 beanClass，并判断 beanClass 是否是 class 类型的对象，如果是 String类型（类的全限定名）则通过 classLoader去加载这个类。</p>
<p>默认使用ClassUtils**.getDefaultClassLoader()**进行类加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getDefaultClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 先取当前线程对应的classloader</span></span><br><span class="line">		<span class="comment">// 再取ClassUtils类的classloader</span></span><br><span class="line">		<span class="comment">// 最后去系统指定的classloader</span></span><br><span class="line"></span><br><span class="line">		ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			cl = Thread.currentThread().getContextClassLoader(); <span class="comment">// APpClassLoader</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="comment">// Cannot access thread context ClassLoader - falling back...</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cl == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// No thread context class loader -&gt; use class loader of this class.</span></span><br><span class="line">			cl = ClassUtils.class.getClassLoader();</span><br><span class="line">			<span class="keyword">if</span> (cl == <span class="keyword">null</span>) &#123;  <span class="comment">// Bootstrap</span></span><br><span class="line">				<span class="comment">// getClassLoader() returning null indicates the bootstrap ClassLoader</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					cl = ClassLoader.getSystemClassLoader(); <span class="comment">// app</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="comment">// Cannot access system ClassLoader - oh well, maybe the caller can live with null...</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>由上述代码可知：</p>
<ul>
<li><p>优先获取当前线程中的ClassLoader</p>
</li>
<li><p>如果为空，则获取加载ClassUtils类的类加载器（正常情况下，就是AppClassLoader，但是如果是在Tomcat中运行，那么则会是Tomcat中为每个应用所创建的WebappClassLoader）</p>
</li>
<li><p>如果为空，那么则是bootstrap类加载器加载的ClassUtils类，那则获取系统类加载器进行加载</p>
</li>
</ul>
<p>优先级：如果一开始就 setBeanClassLoader,则优先级最高，否则优先级安装上方获取 classLoader的前后一致。</p>
<h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><h3 id="实例化前"><a href="#实例化前" class="headerlink" title="实例化前"></a>实例化前</h3><p>允许第三方可以不按照Spring的正常流程来创建一个Bean，可以利用InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation方法来提前返回一个Bean对象，直接结束Bean的生命周期。</p>
<h3 id="推断构造方法"><a href="#推断构造方法" class="headerlink" title="推断构造方法"></a>推断构造方法</h3><p>Spring在基于类生成bean的过程中，需要利用类的构造方法实例化得到一个对象，确定使用哪个构造方法，确定入参的Bean对象，这个过程就叫做推断构造方法。</p>
<p>Spring的判断逻辑如下：</p>
<ol>
<li>如果一个类只存在一个构造方法，不管该构造方法是无参构造方法，还是有参构造方法，Spring都会用这个构造方法</li>
<li>如果一个类存在多个构造方法<ul>
<li>这些构造方法中，存在一个无参的构造方法，那么Spring就会用这个无参的构造方法</li>
<li> 这些构造方法中，不存在一个无参的构造方法，那么Spring就会报错</li>
</ul>
</li>
</ol>
<h3 id="实例化-1"><a href="#实例化-1" class="headerlink" title="实例化"></a>实例化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建一个bean实例(返回一个原始对象)</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">		<span class="comment">// 1. 得到bean的class，并验证class的访问权限是不是public</span></span><br><span class="line">		Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 这是Spring提供给开发者的扩展点</span></span><br><span class="line">		<span class="comment">// 如果我们要自己来实现创建对象的过程, 那么就可以提供一个Supplier的实现类,</span></span><br><span class="line">		<span class="comment">// 当一个BeanDefinition中存在一个Supplier实现类的时候, Spring就利用这个类的get方法来获取实例,</span></span><br><span class="line">		<span class="comment">// 而不再走Spring创建对象的逻辑</span></span><br><span class="line">		Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">		<span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3.通过factoryMethod实例化这个bean</span></span><br><span class="line">		<span class="comment">// factorMethod这个名称在xml中还是比较常见的, 即通过工厂方法来创建bean对象</span></span><br><span class="line">		<span class="comment">// 如果一个bean对象是由@Bean注解创建的, 那么该对象就会走instantiateUsingFactoryMethod方法来创建的</span></span><br><span class="line">		<span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">		<span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">// 如果在创建bean时没有手动指定构造方法的参数，那么则看当前BeanDefinition是不是已经确定了要使用的构造方法和构造方法参数</span></span><br><span class="line">		<span class="comment">// 注意：如果没有手动指定参数，那么就肯定时自动推断出来的，所以一旦发现当前BeanDefinition中已经确定了要使用的构造方法和构造方法参数，</span></span><br><span class="line">		<span class="comment">// 那么就要使用autowireConstructor()方法来构造一个bean对象</span></span><br><span class="line">		<span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">				<span class="comment">// 该BeanDefinition是否已经决定了要使用的构造方法或工厂方法</span></span><br><span class="line">				<span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">					resolved = <span class="keyword">true</span>;</span><br><span class="line">					<span class="comment">// 该BeanDefinition是否已经决定了要使用的构造方法参数</span></span><br><span class="line">					autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">			<span class="comment">// resolved为true，表示当前bean的构造方法已经确定出来了</span></span><br><span class="line">			<span class="comment">// autowireNecessary表示</span></span><br><span class="line">			<span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">				<span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 如果构造方法已经确定了，但是没有确定构造方法参数，那就表示没有构造方法参数，用无参的构造方法来实例化bean</span></span><br><span class="line">				<span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Candidate constructors for autowiring?</span></span><br><span class="line">		Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 通过BeanPostProcessor找出了构造方法</span></span><br><span class="line">		<span class="comment">// 或者BeanDefinition的autowire属性为AUTOWIRE_CONSTRUCTOR</span></span><br><span class="line">		<span class="comment">// 或者BeanDefinition中指定了构造方法参数值</span></span><br><span class="line">		<span class="comment">// 或者在getBean()时指定了args</span></span><br><span class="line">		<span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">				mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">			<span class="comment">// 进行构造方法推断并实例化</span></span><br><span class="line">			<span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line">		<span class="comment">// 没啥用</span></span><br><span class="line">		ctors = mbd.getPreferredConstructors();</span><br><span class="line">		<span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">		<span class="comment">// 用无参的构造方法来实例化bean</span></span><br><span class="line">		<span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h3 id="BeanDefinitionPostProcessor（后置处理器）"><a href="#BeanDefinitionPostProcessor（后置处理器）" class="headerlink" title="BeanDefinitionPostProcessor（后置处理器）"></a>BeanDefinitionPostProcessor（后置处理器）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Apply MergedBeanDefinitionPostProcessors to the specified bean definition,</span></span><br><span class="line"><span class="comment">	 * invoking their &#123;<span class="doctag">@code</span> postProcessMergedBeanDefinition&#125; methods.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> mbd the merged bean definition for the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanType the actual type of the managed bean instance</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyMergedBeanDefinitionPostProcessors</span><span class="params">(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;</span><br><span class="line">				bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="填充属性"><a href="#填充属性" class="headerlink" title="填充属性"></a>填充属性</h2><p>这个步骤中，就会处理@Autowired、@Resource、@Value等注解，也是通过 **InstantiationAwareBeanPostProcessor.postProcessProperties()**扩展点来实现的，比如我们 甚至可以实现一个自己的自动注入功能</p>
<h2 id="执行Aware回调"><a href="#执行Aware回调" class="headerlink" title="执行Aware回调"></a>执行Aware回调</h2><p>完成了属性赋值之后，Spring会执行一些回调，包括:</p>
<ol>
<li>BeanNameAware:回传beanName给bean对象。</li>
<li>BeanClassLoaderAware:回传classLoader给bean对象。 </li>
<li>BeanFactoryAware:回传beanFactory给对象。</li>
</ol>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="初始化前"><a href="#初始化前" class="headerlink" title="初始化前"></a>初始化前</h3><p>初始化前，也是Spring提供的一个扩展点: BeanPostProcessor.postProcessBeforeInitialization()利用初始化前，可以对进行了依赖注入的Bean进行处理。</p>
<p>在Spring源码中:</p>
<ol>
<li>InitDestroyAnnotationBeanPostProcessor会在初始化前这个步骤中执行@PostConstruct的方法，</li>
<li>ApplicationContextAwareProcessor会在初始化前这个步骤中进行其他Aware的回调:<ul>
<li>EnvironmentAware:回传环境变量</li>
<li>EmbeddedValueResolverAware:回传占位符解析器</li>
<li>ResourceLoaderAware:回传资源加载器</li>
<li>ApplicationEventPublisherAware:回传事件发布器</li>
<li>MessageSourceAware:回传国际化资源</li>
<li>ApplicationStartupAware:回传应用其他监听对象，可忽略</li>
<li>ApplicationContextAware:回传Spring容器ApplicationContext</li>
</ul>
</li>
</ol>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><ol>
<li>查看当前Bean对象是否实现了InitializingBean接口，如果实现了就调用其afterPropertiesSet() 方法</li>
<li>执行BeanDefinition中指定的初始化方法</li>
</ol>
<h3 id="初始化后"><a href="#初始化后" class="headerlink" title="初始化后"></a>初始化后</h3><p>这是Bean创建生命周期中的最后一个步骤，也是Spring提供的一个扩展点: BeanPostProcessor.postProcessAfterInitialization()可以在这个步骤中，对Bean最终进行处理，Spring中的AOP就是基于初始化后实现的，初始化后返 回的对象才是最终的Bean对象。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava RateLimiter 限流及源码解析</title>
    <url>/2020/08/12/Guava%20RateLimiter%20%E9%99%90%E6%B5%81%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h4 id="一、RateLimiter-实现原理"><a href="#一、RateLimiter-实现原理" class="headerlink" title="一、RateLimiter 实现原理"></a>一、RateLimiter 实现原理</h4><p>Guava 有两种限流模式：</p>
<ul>
<li>稳定模式（SmoothBursty）:令牌生成速度恒定</li>
<li>渐进模式（SmoothWarmingUp）:令牌生成速度缓慢提升知道维持到一个稳定值</li>
</ul>
<h4 id="二、RateLimiter-创建"><a href="#二、RateLimiter-创建" class="headerlink" title="二、RateLimiter 创建"></a>二、RateLimiter 创建</h4><p>通过 create 方法创建实例，实际上是调用 SmoothBursty 稳定模式创建的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(<span class="keyword">double</span> permitsPerSecond)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> create(permitsPerSecond, SleepingStopwatch.createFromSystemTimer());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, SleepingStopwatch stopwatch)</span> </span>&#123;</span><br><span class="line">  RateLimiter rateLimiter = <span class="keyword">new</span> SmoothBursty(stopwatch, <span class="number">1.0</span> <span class="comment">/* maxBurstSeconds */</span>);</span><br><span class="line">  rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">  <span class="keyword">return</span> rateLimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SmoothBursty 中有两个构造参数：</p>
<ul>
<li>SleepingStopwatch:guava中的一个时钟类实例，会通过这个来计算时间及令牌</li>
<li>maxBurstySeconds：未使用的令牌存活时间，默认是 1</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The work (permits) of how many seconds can be saved up if this RateLimiter is unused?</span></span><br><span class="line"><span class="comment"> * 在RateLimiter未使用时，最多存储几秒的令牌</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">double</span> maxBurstSeconds;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The currently stored permits.</span></span><br><span class="line"><span class="comment"> * 当前存储令牌数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">double</span> storedPermits;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum number of stored permits.</span></span><br><span class="line"><span class="comment"> * 最大存储令牌数 = maxBurstSeconds * stableIntervalMicros(见下文)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">double</span> maxPermits;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The interval between two unit requests, at our stable rate. E.g., a stable rate of 5 permits</span></span><br><span class="line"><span class="comment"> * per second has a stable interval of 200ms.</span></span><br><span class="line"><span class="comment"> * 添加令牌时间间隔 = SECONDS.toMicros(1L) / permitsPerSecond；(1秒/每秒的令牌数)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">double</span> stableIntervalMicros;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The time when the next request (no matter its size) will be granted. After granting a request,</span></span><br><span class="line"><span class="comment"> * this is pushed further in the future. Large requests push this further than small requests.</span></span><br><span class="line"><span class="comment"> * 下一次请求可以获取令牌的起始时间</span></span><br><span class="line"><span class="comment"> * 由于RateLimiter允许预消费，上次请求预消费令牌后</span></span><br><span class="line"><span class="comment"> * 下次请求需要等待相应的时间到nextFreeTicketMicros时刻才可以获取令牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> nextFreeTicketMicros = <span class="number">0L</span>; <span class="comment">// could be either in the past or future</span></span><br></pre></td></tr></table></figure>

<p>其中关键函数：</p>
<ul>
<li><p>setRate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond)</span> </span>&#123;</span><br><span class="line">  checkArgument(</span><br><span class="line">      permitsPerSecond &gt; <span class="number">0.0</span> &amp;&amp; !Double.isNaN(permitsPerSecond), <span class="string">&quot;rate must be positive&quot;</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">    doSetRate(permitsPerSecond, stopwatch.readMicros());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>该方法可以设置令牌桶每秒生成令牌的数量，内部时间通过调用 SmoothRateLimiterd的 doSetRate 来实现</p>
</li>
<li><p>doSetRate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    resync(nowMicros);</span><br><span class="line">    <span class="keyword">double</span> stableIntervalMicros = SECONDS.toMicros(<span class="number">1L</span>) / permitsPerSecond;</span><br><span class="line">    <span class="keyword">this</span>.stableIntervalMicros = stableIntervalMicros;</span><br><span class="line">    doSetRate(permitsPerSecond, stableIntervalMicros);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里先通过调用<code>resync</code>生成令牌以及更新下一期令牌生成时间，然后更新stableIntervalMicros，最后又调用了<code>SmoothBursty</code>的<code>doSetRate</code></p>
</li>
<li><p>resync</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Updates &#123;<span class="doctag">@code</span> storedPermits&#125; and &#123;<span class="doctag">@code</span> nextFreeTicketMicros&#125; based on the current time.</span></span><br><span class="line"><span class="comment"> * 基于当前时间，更新下一次请求令牌的时间，以及当前存储的令牌(可以理解为生成令牌)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resync</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if nextFreeTicket is in the past, resync to now</span></span><br><span class="line">    <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">      <span class="keyword">double</span> newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();</span><br><span class="line">      storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class="line">      nextFreeTicketMicros = nowMicros;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>根据令牌桶算法，桶中的令牌是持续生成存放的，有请求时需要先从桶中拿到令牌才能开始执行，谁来持续生成令牌存放呢？</p>
<p>一种解法是，开启一个定时任务，由定时任务持续生成令牌。这样的问题在于会极大的消耗系统资源，如，某接口需要分别对每个用户做访问频率限制，假设系统中存在6W用户，则至多需要开启6W个定时任务来维持每个桶中的令牌数，这样的开销是巨大的。</p>
<p>另一种解法则是延迟计算，如上<code>resync</code>函数。该函数会在每次获取令牌之前调用，其实现思路为，若当前时间晚于nextFreeTicketMicros，则计算该段时间内可以生成多少令牌，将生成的令牌加入令牌桶中并更新数据。这样一来，只需要在获取令牌时计算一次即可。</p>
<ul>
<li><p>SmoothBursty的 doSetRate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> stableIntervalMicros)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> oldMaxPermits = <span class="keyword">this</span>.maxPermits;</span><br><span class="line">  maxPermits = maxBurstSeconds * permitsPerSecond;</span><br><span class="line">  <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">    <span class="comment">// if we don&#x27;t special-case this, we would get storedPermits == NaN, below</span></span><br><span class="line">    <span class="comment">// Double.POSITIVE_INFINITY 代表无穷啊</span></span><br><span class="line">    storedPermits = maxPermits;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    storedPermits =</span><br><span class="line">        (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">            ? <span class="number">0.0</span> <span class="comment">// initial state</span></span><br><span class="line">            : storedPermits * maxPermits / oldMaxPermits;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>桶中可存放的最大令牌数由maxBurstSeconds计算而来，其含义为最大存储maxBurstSeconds秒生成的令牌。<br> 该参数的作用在于，可以更为灵活地控制流量。如，某些接口限制为300次/20秒，某些接口限制为50次/45秒等。也就是流量不局限于qps。</p>
<h4 id="RateLimiter-其他常用接口"><a href="#RateLimiter-其他常用接口" class="headerlink" title="RateLimiter 其他常用接口"></a>RateLimiter 其他常用接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CanIgnoreReturnValue</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取令牌，返回阻塞的时间</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@CanIgnoreReturnValue</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> microsToWait = reserve(permits);</span><br><span class="line">  stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> * microsToWait / SECONDS.toMicros(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserve</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">  checkPermits(permits);</span><br><span class="line">  <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">    <span class="keyword">return</span> reserveAndGetWaitLength(permits, stopwatch.readMicros());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquire()主要用于获取 permits 个令牌，并计算需要等待的时间，进而挂起等待，并将该值返回，主要通过 reserve 返回需要等待的时间，reserve 中通过 reserveAndGetWaitLength 获取等待时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reserves next ticket and returns the wait time that the caller must wait for.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the required wait time, never negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveAndGetWaitLength</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> momentAvailable = reserveEarliestAvailable(permits, nowMicros);</span><br><span class="line">  <span class="keyword">return</span> max(momentAvailable - nowMicros, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后调用了 reserveEarliestAvailable</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveEarliestAvailable</span><span class="params">(<span class="keyword">int</span> requiredPermits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">  resync(nowMicros);</span><br><span class="line">  <span class="keyword">long</span> returnValue = nextFreeTicketMicros;</span><br><span class="line">  <span class="keyword">double</span> storedPermitsToSpend = min(requiredPermits, <span class="keyword">this</span>.storedPermits);</span><br><span class="line">  <span class="keyword">double</span> freshPermits = requiredPermits - storedPermitsToSpend;</span><br><span class="line">  <span class="keyword">long</span> waitMicros =</span><br><span class="line">      storedPermitsToWaitTime(<span class="keyword">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">          + (<span class="keyword">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);</span><br><span class="line">  <span class="keyword">this</span>.storedPermits -= storedPermitsToSpend;</span><br><span class="line">  <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过resync生成令牌以及同步nextFreeTicketMicros时间戳，freshPermits从令牌桶中获取令牌后还需要的令牌数量，通过storedPermitsToWaitTime计算出获取freshPermits还需要等待的时间，在稳定模式中，这里就是(long) (freshPermits * stableIntervalMicros) ，然后更新nextFreeTicketMicros以及storedPermits，这次获取令牌需要的等待到的时间点， reserveAndGetWaitLength返回需要等待的时间间隔。</p>
<p>从<code>reserveEarliestAvailable</code>可以看出RateLimiter的预消费原理，以及获取令牌的等待时间时间原理（可以解释示例结果），当获取令牌不足时，并没有等待到令牌全部生成，而是<strong>更新了下次获取令牌时的nextFreeTicketMicros，从而影响的是下次获取令牌的等待时间。</strong></p>
<p> <code>reserve</code>这里返回等待时间后，<code>acquire</code>通过调用<code>stopwatch.sleepMicrosUninterruptibly(microsToWait);</code>进行sleep操作，这里不同于Thread.sleep(), 这个函数的sleep是uninterruptibly的，内部实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleepUninterruptibly</span><span class="params">(<span class="keyword">long</span> sleepFor, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//sleep 阻塞线程 内部通过Thread.sleep()</span></span><br><span class="line">  <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">long</span> remainingNanos = unit.toNanos(sleepFor);</span><br><span class="line">    <span class="keyword">long</span> end = System.nanoTime() + remainingNanos;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// TimeUnit.sleep() treats negative timeouts just like zero.</span></span><br><span class="line">        NANOSECONDS.sleep(remainingNanos);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">        remainingNanos = end - System.nanoTime();</span><br><span class="line">        <span class="comment">//如果被interrupt可以继续，更新sleep时间，循环继续sleep</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">      Thread.currentThread().interrupt();</span><br><span class="line">      <span class="comment">//如果被打断过，sleep过后再真正中断线程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sleep 之后，<code>acquire</code>返回 sleep的时间，阻塞结束，获得到令牌。</p>
<p><code>tryAcquire</code>函数可以尝试在timeout时间内获取令牌，如果可以则挂起等待相应时间并返回true，否则立即返回false<br> <code>canAcquire</code>用于判断timeout时间内是否可以获取令牌，通过判断<strong>当前时间+超时时间</strong>是否大于nextFreeTicketMicros 来决定是否能够拿到足够的令牌数，如果可以获取到，则过程同acquire，线程sleep等待，如果通过<code>canAcquire</code>在此超时时间内不能获取到令牌，则可以快速返回，不需要等待timeout后才知道能否获取到令牌。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tryAcquire(permits, <span class="number">0</span>, MICROSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tryAcquire(<span class="number">1</span>, <span class="number">0</span>, MICROSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> timeoutMicros = max(unit.toMicros(timeout), <span class="number">0</span>);</span><br><span class="line">  checkPermits(permits);</span><br><span class="line">  <span class="keyword">long</span> microsToWait;</span><br><span class="line">  <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">    <span class="keyword">long</span> nowMicros = stopwatch.readMicros();</span><br><span class="line">    <span class="keyword">if</span> (!canAcquire(nowMicros, timeoutMicros)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      microsToWait = reserveAndGetWaitLength(permits, nowMicros);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canAcquire</span><span class="params">(<span class="keyword">long</span> nowMicros, <span class="keyword">long</span> timeoutMicros)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> queryEarliestAvailable(nowMicros) - timeoutMicros &lt;= nowMicros;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">queryEarliestAvailable</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nextFreeTicketMicros;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Github+PicGo+Typora 搭建免费图床</title>
    <url>/2023/09/04/Github+PicGo+Typora%20%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h1 id="Github-PicGo-Typora-搭建免费图床"><a href="#Github-PicGo-Typora-搭建免费图床" class="headerlink" title="Github+PicGo+Typora 搭建免费图床"></a>Github+PicGo+Typora 搭建免费图床</h1><h2 id="建立图床仓库"><a href="#建立图床仓库" class="headerlink" title="建立图床仓库"></a>建立图床仓库</h2><ul>
<li><p>新建一个名为image的公共仓库,注意仓库名不能与博客站点的图片目录名相同</p>
</li>
<li><p>进入Settings -&gt; Pages，设置为main分支</p>
</li>
</ul>
<p>注意不勾选“Enforce HTTPS”，否则只能通过https访问，有些时候会用到http协议。</p>
<h2 id="生成Github-Token"><a href="#生成Github-Token" class="headerlink" title="生成Github Token"></a>生成Github Token</h2><p>点击用户头像 –&gt; 选择 Settings。<br>点击 Developer settings。<br>点击 Personal access tokens 并点击 Generate new token 新建一个 Token。<br>填写 Token 描述，勾选 repo，然后点击 Generate token 生成一个 Token。<br>生成之后会显示Token的密钥，复制保存好。注意这个 Token 只会显示一次，自己先保存下来</p>
<h2 id="下载PicGo"><a href="#下载PicGo" class="headerlink" title="下载PicGo"></a>下载PicGo</h2><p>下载地址： <a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a> 根据系统选择合适的版本即可</p>
<p>picgo自带的“GitHub图床”删除图片操作不能同步到github，使用picgo-plugin-github-plus插件可以在picgo相册中删除图片时自动把github上的图片也删除了。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230904111515652.png" alt="image-20230904111515652"></p>
<p>在插件设置中搜索picgo-plugin-github-plus，然后安装即可。</p>
<p>安装好插件后，在图床设置 -&gt; githubPlus中进行githubPlus设置</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230904111909576.png" alt="image-20230904111909576"></p>
<p>repo就是“github用户名/仓库名”。</p>
<p>选择“设为默认图床”，然后确定。</p>
<p>版本2.2.0之后，PicGo 内部会默认开启一个小型的服务器，用于配合其他应用来调用 PicGo 进行上传。</p>
<p>打开 PicGo 详细页面，进入 PicGo 设置–设置Server</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230904111944990.png" alt="image-20230904111944990"></p>
<h2 id="设置Typora"><a href="#设置Typora" class="headerlink" title="设置Typora"></a>设置Typora</h2><p>版本要求：Typora 0.9.84 及以上。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230904112042253.png" alt="image-20230904112042253"></p>
<p>设置完后，点“验证图片上传选项”。<br>验证成功会显示如下结果</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230904112135249.png" alt="image-20230904112135249"></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>使用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK11新特性</title>
    <url>/2021/04/29/JDK11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="局部变量的类型推断"><a href="#局部变量的类型推断" class="headerlink" title="局部变量的类型推断"></a>局部变量的类型推断</h1><p>所谓局部变量的类型推断，即在命名局部变量时，不指定具体的变量类型，直接用 var，变量类型交由编译器进行判断。</p>
<h1 id="字符串加强"><a href="#字符串加强" class="headerlink" title="字符串加强"></a>字符串加强</h1><p>JDK11新增若干字符串相关的 API，类似 Apache 的 StringUtil 中的部分 API</p>
<p>String新增了strip()方法，和trim()相比，strip()可以去掉Unicode空格，例如，中文空格：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断字符串是否为空白</span></span><br><span class="line"><span class="string">&quot; &quot;</span>.isBlank(); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 去除首尾空格</span></span><br><span class="line"><span class="string">&quot; Javastack &quot;</span>.strip(); <span class="comment">// &quot;Javastack&quot;</span></span><br><span class="line"><span class="comment">// 去除尾部空格</span></span><br><span class="line"><span class="string">&quot; Javastack &quot;</span>.stripTrailing(); <span class="comment">// &quot; Javastack&quot;</span></span><br><span class="line"><span class="comment">// 去除首部空格</span></span><br><span class="line"><span class="string">&quot; Javastack &quot;</span>.stripLeading(); <span class="comment">// &quot;Javastack &quot;</span></span><br><span class="line"><span class="comment">// 复制字符串</span></span><br><span class="line"><span class="string">&quot;Java&quot;</span>.repeat(<span class="number">3</span>);<span class="comment">// &quot;JavaJavaJava&quot;</span></span><br><span class="line"><span class="comment">// 行数统计</span></span><br><span class="line"><span class="string">&quot;A\nB\nC&quot;</span>.lines().count(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h1 id="集合容器加强"><a href="#集合容器加强" class="headerlink" title="集合容器加强"></a>集合容器加强</h1><p>相对于 JDK8,JDK11完善了 List/Set/Map集合的 API,新增了of 和 copyOf 方法，它们两个都用来创建不可变的集合（实际上是 JDK9 开始新增的）</p>
<h3 id="API-的使用"><a href="#API-的使用" class="headerlink" title="API 的使用"></a>API 的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ar list = List.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> copy = List.copyOf(list);</span><br><span class="line">System.out.println(list == copy); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">var</span> copy = List.copyOf(list);</span><br><span class="line">System.out.println(list == copy); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>之所以上述两块代码执行结果不一样，是因为在源码中copyOf 方法会先判断来源集合是不是 AbstractImmutableList 类型的，如果是，就直接返回，如果不是，则调用 of 创建一个新的集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">copyOf</span><span class="params">(Collection&lt;? extends E&gt; coll)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ImmutableCollections.listCopy(coll);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">listCopy</span><span class="params">(Collection&lt;? extends E&gt; coll)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coll <span class="keyword">instanceof</span> AbstractImmutableList &amp;&amp; coll.getClass() != SubList.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> (List&lt;E&gt;)coll;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (List&lt;E&gt;)List.of(coll.toArray());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以用 new 创建的集合，不属于不可变 AbstractImmutableList 类的子类，所以 copyOf 方法又创建了一个新的实例，所以为false.</p>
<p>另外从上述代码可知：</p>
<p><strong>使用of和copyOf创建的集合为不可变集合，不能进行添加、删除、替换、排序等操作</strong></p>
<h1 id="Stream-加强"><a href="#Stream-加强" class="headerlink" title="Stream 加强"></a>Stream 加强</h1><p>Stream 是 Java 8 中的新特性，Java 9 开始对 Stream 增加了以下 4 个新方法。</p>
<ol>
<li><p>增加单个参数构造方法，可为null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.ofNullable(<span class="keyword">null</span>).count(); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>增加 takeWhile 和 dropWhile 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">.takeWhile(n -&gt; n &lt; <span class="number">3</span>)</span><br><span class="line">.collect(Collectors.toList()); <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<p>当满足 n&lt;3这个条件时，进行解截取，而 dropWhile 相反</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">.dropWhile(n -&gt; n &lt; <span class="number">3</span>)</span><br><span class="line">.collect(Collectors.toList()); <span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure>

<p>当满足 n&lt;3条件不成立时进行截取</p>
</li>
<li><p>iterate重载</p>
<p>这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。</p>
</li>
</ol>
<h1 id="Optional-加强"><a href="#Optional-加强" class="headerlink" title="Optional 加强"></a>Optional 加强</h1><p>Opthonal 也增加了几个方法，现在可以很方便的将一个 Optional 转换成一个 Stream, 或者当一个空 Optional 时给它一个替代的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional.of(<span class="string">&quot;javastack&quot;</span>).orElseThrow(); <span class="comment">// javastack</span></span><br><span class="line">Optional.of(<span class="string">&quot;javastack&quot;</span>).stream().count(); <span class="comment">// 1</span></span><br><span class="line">Optional.ofNullable(<span class="keyword">null</span>)</span><br><span class="line">.or(() -&gt; Optional.of(<span class="string">&quot;javastack&quot;</span>))</span><br><span class="line">.get(); <span class="comment">// javastack</span></span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDK11</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch 学习（一）概念名称介绍</title>
    <url>/2021/03/01/Elasticsearch%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="Elasticsearch中的重要概念"><a href="#Elasticsearch中的重要概念" class="headerlink" title="Elasticsearch中的重要概念"></a>Elasticsearch中的重要概念</h1><p>在介绍 Elasticsearch 的概念之前，先和传统关系型数据库进行对比</p>
<table>
<thead>
<tr>
<th align="center">关系型数据库</th>
<th>DataBase</th>
<th>Table</th>
<th>Row</th>
<th>Column</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Elasticsearch</td>
<td>Index（索引库）</td>
<td>Type（类型）</td>
<td>Document（文档）</td>
<td>Field(字段)</td>
</tr>
</tbody></table>
<h2 id="索引-index"><a href="#索引-index" class="headerlink" title="索引 index"></a>索引 index</h2><p>根据上述与传统关系型数据的比对，可以知道在 Elasticsearch 中 index 相当于就是一个数据库，或者说是文档的集合。一个索引是由名字（必须全部是小写字母）进行标识的，而这个标识也是后面进行增删改查的关键。</p>
<h2 id="映射-mapping"><a href="#映射-mapping" class="headerlink" title="映射 mapping"></a>映射 mapping</h2><p>mapping是ES对处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认 值、分词器、是否被索引等等，这些都是映射里面可以设置的，可以理解为查询条件，是 key:value形式的 json 数据。</p>
<h2 id="字段-Field"><a href="#字段-Field" class="headerlink" title="字段 Field"></a>字段 Field</h2><p>根据上述与关系型数据库的比对可知，ES 的字段相当于传统关系型数据库的列。</p>
<h2 id="字段类型-Type"><a href="#字段类型-Type" class="headerlink" title="字段类型 Type"></a>字段类型 Type</h2><p>每一个字段都应该有一个对应的类型，例如:Text、Keyword、Byte等。</p>
<h2 id="文档-Document"><a href="#文档-Document" class="headerlink" title="文档 Document"></a>文档 Document</h2><p>在 ES中，文档相当于关系型数据的一行数据，是基础信息单元，以 JSON 格式来表示。</p>
<h2 id="节点-Node"><a href="#节点-Node" class="headerlink" title="节点 Node"></a>节点 Node</h2><p>每个 ES 的实例即为一个节点，每个节点可以通过配置集群名称加入同一个集群，并共同提供服务。</p>
<p>以下是一个 Node 节点的配置。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置集群名称，集群内所有节点的名称必须一致</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">my-application</span></span><br><span class="line"><span class="comment"># 设置节点名称，集群内节点名称必须唯一</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-1</span></span><br><span class="line"><span class="comment"># 表示该节点会不会作为主节点，true表示会；false表示不会</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 当前节点是否用于存储数据，是：true、否：false</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 索引数据存放的位置</span></span><br><span class="line"><span class="comment"># 日志文件存放的位置</span></span><br><span class="line"><span class="comment">#path.logs: /path/to/logs</span></span><br><span class="line"><span class="comment"># 需要锁住物理内存，是：true、否：false</span></span><br><span class="line"><span class="comment">#bootstrap.memory_lock: true</span></span><br><span class="line"><span class="comment"># 系统调用过滤器检查，是：true、否：false</span></span><br><span class="line"><span class="attr">bootstrap.system_call_filter:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 监听地址，用于访问该es</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="comment"># es对外提供的http端口，默认 9200</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="comment"># TCP的默认监听端口，默认 9300</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"><span class="comment"># 是否支持跨域，是：true，在使用head插件时需要此配置</span></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># “*” 表示支持所有域名</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="comment"># 设置这个参数来保证集群中的节点可以知道其它N个有master资格的节点。默认为1，对于大的集群来说，可以设置大一点的值（2-4）</span></span><br><span class="line"><span class="attr">discovery.zen.minimum_master_nodes:</span> <span class="number">2</span></span><br><span class="line"><span class="comment"># es7.x 之后新增的配置，写入候选主节点的设备地址，在开启服务后可以被选为主节点</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> [<span class="string">&quot;127.0.0.1:9300&quot;</span>, <span class="string">&quot;127.0.0.1:9301&quot;</span>, <span class="string">&quot;127.0.0.1:9302&quot;</span>]</span><br><span class="line"><span class="comment"># 判断结点是否脱离时间配置</span></span><br><span class="line"><span class="attr">discovery.zen.fd.ping_timeout:</span> <span class="string">60s</span></span><br><span class="line"><span class="comment"># 判断结点是否脱离次数配置</span></span><br><span class="line"><span class="attr">discovery.zen.fd.ping_retries:</span> <span class="number">5</span></span><br><span class="line"><span class="comment"># es7.x 之后新增的配置，初始化一个新的集群时需要此配置来选举master</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> [<span class="string">&quot;node-1&quot;</span>, <span class="string">&quot;node-2&quot;</span>, <span class="string">&quot;node-3&quot;</span>]</span><br></pre></td></tr></table></figure>



<h2 id="集群-cluster"><a href="#集群-cluster" class="headerlink" title="集群 cluster"></a>集群 cluster</h2><p>多个节点组成的集合，同时提供索引和搜索功能。在一个集群里，可以拥有任意多个节点。而且，如果当前网络中没有运行任何 Elasticsearch节点，这时启动一个节点，会<strong>默认创建并加入一个叫 做“elasticsearch”的集群</strong>。不过在真实环境中集群中的实例个数一般为奇数个，方便进行 master选举.</p>
<h2 id="分片-shards-和副本-replicas"><a href="#分片-shards-和副本-replicas" class="headerlink" title="分片(shards)和副本(replicas)"></a>分片(shards)和副本(replicas)</h2><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>ES 将索引划分成多份，每一份叫做分片。这样可以解决单一节点存储大量数据导致检索数据响应慢的情况。</p>
<p>每个分片本身也是一个功能完善相对独立的索引，可以放置到集群的任意一个节点上。</p>
<p>分片的存在是对内容进行了<strong>水平扩容</strong>，也提高了并行操作的效率，进而提高了吞吐量。</p>
<h3 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h3><p>见名知意，ES 提供了一种故障转移机制：即创建分片的一份或多份拷贝，这些拷贝称之为副本。</p>
<p>副本存在的意义：</p>
<ul>
<li>当分片或街道失败时，副本会代替失效的分片或节点继续提供服务，提高了集群的容错能力，提供了高可用性。但值得注意的是：<code>副本不能与原分片处于同一个节点</code></li>
<li>扩展搜索能力，搜索可以在所有的副本上并行运行每个索引可以被分成多个分片。一个索引有0个或者多个副本。一旦设置了副本，每个索引就有了主分片和副本分片，分片和副本的数量可以在索引创建的时候指定在索引创建之后，可以<strong>在任何时候动态地改变副本的数量，但是不能改变分片的数量</strong></li>
</ul>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>传统关系型数据库一般采用<code>正排索引</code>进行数据检索，所谓正排索引就是通过根据索引找内容可以理解为通过 key去找到对应的完整的 value。而<code>倒排索引</code>实际上就是通过内容去搜索索引，可以理解为通过 value 找到对应的 key。</p>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 内省机制介绍与实际运用</title>
    <url>/2020/09/22/Java-%E5%86%85%E7%9C%81%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<p>一、内省机制的介绍</p>
<p>内省是指计算机程序在运行时（Run time）检查对象（Object）类型的一种能力，通常也可以称作运行时类型检查。 不应该将内省和反射混淆。相对于内省，反射更进一步，是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。</p>
<p>Introspector是一个专门处理JavaBean的工具类，用来获取JavaBean里描述符号，常用的JavaBean的描述符号相关类有BeanInfo、PropertyDescriptor，MethodDescriptor、BeanDescriptor、EventSetDescriptor和ParameterDescriptor</p>
<p>二、什么是JavaBean</p>
<ol>
<li><p>特殊的类，主要作用是传递数据信息，用于访问私有字段且方法具有一定规则要求（get/set）更加宽泛的指 Java对象，一般是指作为参数在方法之间或模块之间传递，，也可以称之为值对象 VO。</p>
</li>
<li><p>JavaBean的信息在Introspector里对应的概念是BeanInfo，它包含了JavaBean所有的Descriptor(描述符)，主要有PropertyDescriptor，MethodDescriptor（MethodDescriptor里面包含ParameterDescriptor）、BeanDescriptor和EventSetDescriptor。</p>
</li>
</ol>
<p>三、属性 Field 和属性描述PropertiesDescriptor 的区别</p>
<p>如果是严格的JavaBean(Field名称不重复，并且Field具备Setter和Getter方法)，它的PropertyDescriptor会通过解析Setter和Getter方法，合并解析结果，最终得到对应的PropertyDescriptor实例。所以PropertyDescriptor包含了属性名称和属性的Setter和Getter方法（如果存在的话）。</p>
<p>四、内省与反射的区别</p>
<ul>
<li>Reflection：反射就是运行时获取一个类的所有信息，可以获取到类的所有定义的信息（包括成员变量，成员方法，构造器等）可以操纵类的字段、方法、构造器等部分。</li>
<li>Introspector：内省基于反射实现，主要用于操作JavaBean，基于JavaBean的规范进行Bean信息描述符的解析，依据于类的Setter和Getter方法，可以获取到类的描述符。如果一个类中的属性没有Setter和Getter方法，无法使用Introspector。</li>
</ul>
<p>五、相关类及 API的使用</p>
<ol>
<li><p>Introspector</p>
<p>该类类似于 BeanInfo 的静态工厂类，主要是提供静态方法通过 Class实例获取 BeanInfo，之后再获取其他描述符。</p>
<ul>
<li>通过Class实例获取到BeanInfo实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanInfo <span class="title">getBeanInfo</span><span class="params">(Class&lt;?&gt; beanClass)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>BeanInfo</p>
<p>BeanInfo是一个接口，具体实现是GenericBeanInfo，通过这个接口可以获取一个类的各种类型的描述符。主要方法：</p>
<ul>
<li>BeanDescriptor getBeanDescriptor()：获取JavaBean描述符。</li>
<li>EventSetDescriptor[] getEventSetDescriptors()：获取JavaBean的所有的EventSetDescriptor。</li>
<li>PropertyDescriptor[] getPropertyDescriptors()：获取JavaBean的所有的PropertyDescriptor。</li>
<li>MethodDescriptor[] getMethodDescriptors()：获取JavaBean的所有的MethodDescriptor。</li>
</ul>
<p>这里要注意一点，通过BeanInfo#getPropertyDescriptors()获取到的PropertyDescriptor数组中，除了Bean属性的之外，还会带有一个属性名为class的PropertyDescriptor实例，它的来源是Class的getClass方法，如果不需要这个属性那么<strong>最好判断后过滤</strong>，这一点需要紧记，否则容易出现问题。</p>
</li>
<li><p>PropertyDescriptor</p>
<p>PropertyDescriptor类表示JavaBean类通过存储器（Setter和Getter）导出一个属性，它应该是内省体系中最常见的类。主要方法：</p>
<ul>
<li>synchronized Class&lt;?&gt; getPropertyType()：获得属性的Class对象。</li>
<li>synchronized Method getReadMethod()：获得用于读取属性值（Getter）的方法；</li>
<li>synchronized Method getWriteMethod()：获得用于写入属性值（Setter）的方法。</li>
<li>int hashCode()：获取对象的哈希值。</li>
<li>synchronized void setReadMethod(Method readMethod)：设置用于读取属性值（Getter）的方法。</li>
<li>synchronized void setWriteMethod(Method writeMethod)：设置用于写入属性值（Setter）的方法。</li>
</ul>
</li>
<li><p>demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BeanInfo beanInfo = Introspector.getBeanInfo(Person.class);</span><br><span class="line">        PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();</span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor propertyDescriptor : propertyDescriptors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">&quot;class&quot;</span>.equals(propertyDescriptor.getName())) &#123;</span><br><span class="line">                System.out.println(propertyDescriptor.getName());</span><br><span class="line">                System.out.println(propertyDescriptor.getWriteMethod().getName());</span><br><span class="line">                System.out.println(propertyDescriptor.getReadMethod().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Long id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>注</strong>：如果框架或者程序用到了JavaBeans Introspector，那么就相当于启用了一个<strong>系统级别的缓存</strong>，这个缓存会存放一些曾加载并分析过的Javabean的引用，当Web服务器关闭的时候，由于这个缓存中存放着这些Javabean的引用，所以垃圾回收器不能对Web容器中的JavaBean对象进行回收，导致内存越来越大。</p>
<p>还有一点值得注意，<strong>清除Introspector缓存的唯一方式是刷新整个缓存缓冲区</strong>，这是<strong>因为JDK没法判断哪些是属于当前的应用的引用</strong>，所以刷新整个Introspector缓存缓冲区会导致把服务器的所有应用的Introspector缓存都删掉。Spring中提供的org.springframework.web.util.IntrospectorCleanupListener就是为了解决这个问题，它会在Web服务器停止的时候，清理一下这个Introspector缓存，使那些Javabean能被垃圾回收器正确回收。</p>
<p>也就是说JDK的Introspector缓存管理是有一定缺陷的。但是如果使用在Spring体系则不会出现这种问题，因为Spring把Introspector缓存的管理移交到Spring自身而不是JDK（或者在Web容器销毁后完全不管），在加载并分析完所有类之后，会针对类加载器对Introspector缓存进行清理，避免内存泄漏的问题，详情可以看CachedIntrospectionResults和SpringBoot刷新上下文的方法AbstractApplicationContext#refresh()中finally代码块中存在清理缓存的方法AbstractApplicationContext#resetCommonCaches();。</p>
<p>但是有很多程序和框架在使用了JavaBeans Introspector之后，都没有进行清理工作，比如Quartz、Struts等，这类操作会成为内存泄漏的隐患。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java特性机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发编程（一）基础概念介绍</title>
    <url>/2020/12/16/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><h4 id="1-时间片"><a href="#1-时间片" class="headerlink" title="1.时间片"></a>1.时间片</h4><p>时间片是 CPU 分配给各个线程的时间，CPU 是通过时间片分配算法来循环执行任务的。</p>
<p><strong>Q：什么是上下文切换？</strong></p>
<p>A：当当前任务所在的时间片结束时，切换之前会保持上一个任务的状态，以便下次切换回这个任务时可以加载这个任务的状态。所以任务<strong>从保存到再次加载的过程</strong>就是一次上下文切换</p>
<p><strong>Q：上下文切换有什么影响？</strong></p>
<p>A：上下文的切换是有开销的，主要体现在多线程环境下，<strong>上下文的切换会影响任务的执行耗时</strong>。所以，多线程不一定比单线程更快（多线程还有创建线程的开销）</p>
<p><strong>Q：如何减少上下文的切换？</strong></p>
<p>A：减少上下文切换的方法有：无锁并发编程 、CAS 算法、使用最少线程和使用协程</p>
<ul>
<li>无锁并发编程：在多线程环境中，尽量不使用锁，如将数据的 ID 用 Hash 算法取模分段，不同的线程处理不同段的数据。</li>
<li>CAS 算法：Compare And Set 比较赋值，原子操作，不需要加锁</li>
<li>使用最少线程：避免创建不需要的线程，避免大量线程处于等待状态</li>
<li>协程：在单线程里实现多任务的任务调度，并在单线程里维持多个任务间的切换</li>
</ul>
<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p><strong>Q：什么是同步，什么是异步？</strong></p>
<p>A：同步（Synchronous）:任务的结果需要内部执行完处理逻辑之后才能拿到；异步（Asynchronous）:更像消息的传递，调用立即返回，但是任务的执行在另一个线程中继续</p>
<h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>Q：什么是并发，什么是并行？</p>
<p>A：并发是指一段时间内多个任务交替进行，而并行是真正意义上的多个任务同时执行；单核 CPU 是不存在真实的并行的，毕竟一个 CPU一次只能执行一个指令，真正的并行存在于多核 CPU 的系统中</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界区是指一种公共资源或共享数据，可以被多个线程使用（读取），但是每次只能由一个线程使用（修改），一旦临界区资源被占用，其他线程只能等待。</p>
<h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p><strong>进程</strong>是程序的一次执行过程，是<strong>系统运行程序的基本单位</strong>，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>Q：什么是死锁？</strong></p>
<p>A：两个线程互相等待对方释放锁</p>
<p><strong>Q：死锁产生的原因是什么？</strong></p>
<p>A：释放锁之前出现异常，没能执行释放锁的操作；亦或释放锁的操作出现异常，导致锁无法正常释放。</p>
<p><strong>Q：如何避免死锁？</strong></p>
<p>A：避免死锁的常见方式：</p>
<ul>
<li>避免一个线程获得多个锁</li>
<li>避免一个线程在锁内同时占用多个临界区资源，尽量一个线程内只占用一个资源</li>
<li>为锁定时，使用 Lock.tryLock(timeOut)替代内部锁机制</li>
<li>对于数据库锁，加锁和解锁必须在同一个数据库连接里，否则会出现解锁失败的情况。</li>
</ul>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发编程（四）Java 对象头与锁升级</title>
    <url>/2020/12/25/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89Java-%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%B8%8E%E9%94%81%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="对象头与对象布局"><a href="#对象头与对象布局" class="headerlink" title="对象头与对象布局"></a>对象头与对象布局</h1><h2 id="对象头的定义"><a href="#对象头的定义" class="headerlink" title="对象头的定义"></a>对象头的定义</h2><blockquote>
<p><strong>object header</strong></p>
<p>Common structure at the beginning of every GC-managed heap object. (Every oop points to an object header.) Includes fundamental information about the heap object’s layout, type, GC state, <strong>synchronization state</strong>, and identity hash code. Consists of two words. In arrays it is immediately followed by a length field. Note that both Java objects and VM-internal objects have a common object header format.</p>
</blockquote>
<p>以上来自 <a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html">OpenJDK 的文档</a></p>
<p><strong>对象头</strong></p>
<p>每个gc管理的堆对象开头的公共结构。(每个oop都指向一个对象标头。)包括堆对象的布局、类型、GC状态、同步状态和标识哈希码的基本信息。<strong>由两个词组成</strong>。在数组中，它后面紧跟着一个长度字段。注意，Java对象和vm内部对象都有一个通用的对象头格式。</p>
<p>由文档可知：对象头是由 mark word 和 klass pointer即</p>
<blockquote>
<p><strong>mark word</strong></p>
<p>The first word of every object header. Usually a set of bitfields including synchronization state and identity hash code. May also be a pointer (with characteristic low bit encoding) to synchronization related information. During GC, may contain GC state bits.</p>
<p><strong>klass pointer</strong></p>
<p>The second word of every object header. Points to another object (a metaobject) which describes the layout and behavior of the original object. For Java objects, the “klass” contains a C++ style “vtable”.</p>
</blockquote>
<p>综上：对象头由实例数据和对齐填充数据构成。其中：对齐填充数据（根据实际情况，当对象头和实例数据在JVM中占的内存空间为8的倍数时，不需要进行填充）</p>
<p>注：（64位）JVM只能识别以8的倍数的对象，所以会根据实际情况对Java对象进行数据的填充，确保该对象的大小为8的倍数。（下文涉及对象头概念若无说明均为 64 位虚拟机环境）</p>
<h2 id="Mark-Word的存储结构"><a href="#Mark-Word的存储结构" class="headerlink" title="Mark Word的存储结构"></a>Mark Word的存储结构</h2><p>32 位虚拟机</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/008eGmZEgy1gns3njjvxoj31840igju8.jpg" alt="img"></p>
<p>64 位虚拟机    </p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/008eGmZEgy1go1cltqkrcj317g0daq74.jpg" alt="img"></p>
<p>对象头一共96bit=12byte,其中mark word占64bit 而klass pointer占32个bit;hotspot默认开启指针压缩（为了节省空间）开启指针压缩的参数：<code>-XX:+UseCompressedOops</code> ，所以klass pointer占32个bit,如果没开启指针压缩的虚拟机 klass pointer占64个bit。</p>
<p>注：在 64 位虚拟机中，以下信息会被压缩：</p>
<p>1.对象的全局静态变量(即类属性)</p>
<p>2.对象头信息：64位平台下，原生对象头大小为16字节，压缩后为12字节</p>
<p>3.对象的引用类型：64位平台下，引用类型本身大小为8字节，压缩后为4字节</p>
<p>4.对象数组类型：64位平台下，数组类型本身大小为24字节，压缩后16字节</p>
<h2 id="如何查看对象布局"><a href="#如何查看对象布局" class="headerlink" title="如何查看对象布局"></a>如何查看对象布局</h2><ol>
<li><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<pre><code>查看</code></pre>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JavaObject objectHead = <span class="keyword">new</span> JavaObject();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(objectHead).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   输出结果</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object.JavaObject object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           05 c0 00 f8 (00000101 11000000 00000000 11111000) (-134168571)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br></pre></td></tr></table></figure>


<p>注：WIN/Linux/MacOS 都是采用小端模式，所以上述打印的对象布局，实际上要颠倒来看，比如00000001 00000000 00000000 00000000—–&gt; 00000000 00000000 00000000 00000001,对照上述 Mark Word的存储结构表来看，当前对象为无锁状态。 </p>
<h1 id="锁升级与对比"><a href="#锁升级与对比" class="headerlink" title="锁升级与对比"></a>锁升级与对比</h1><h2 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h2><p>为了减少获得锁和释放锁时带来的性能消耗，JavaSE1.6引入了 4 种锁的状态，级别由低到高分别是：</p>
<ul>
<li>无锁状态</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态</li>
</ul>
<p>注：锁的级别只可以升级，但是不能降级。目的是提高获得锁和释放锁的效率。</p>
<ol>
<li><p>偏向锁</p>
<p>1.1 引入偏向锁的目的</p>
<p>大多数情况锁不仅不存在多线程竞争，而且总是一个线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<p>1.2 <strong>偏向锁的加锁过程</strong></p>
<p>当线程访问同步块并获得锁时，会在<strong>对象头</strong>和<strong>栈帧</strong>中的锁记录里面存储<strong>锁偏向的线程 ID</strong>,以后该线程在进入和退出同步块时不需要进行 CAS操作来加锁和解锁，只需要简单的测试一下对象头中的 Mark Word里是否存储着指向当前线程的偏向锁。如果成功则表示已经获得锁，如果失败了，则需要再测试对象头中 Mark Word 中偏向锁的标识是否设置成 1，如果没有则需要进行 CAS 操作竞争锁，如果设置了，则尝试使用 CAS将对象头的偏向锁指向当前线程。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230901232843621.png" alt="image-20230901232843621"></p>
<p>1.3 <strong>偏向锁的撤销</strong></p>
<p>偏向锁的撤销是一种等<strong>待竞争出现才释放锁</strong>的机制，需要等待一个<strong>全局安全点</strong>（这个时期没有正在执行的字节码）。</p>
<p>首先会暂停拥有偏向锁的线程，检查该线程是否还处于活动状态，如果不是则将对象头设置为无锁状态；如果持有偏向锁的线程还在活动当中，持有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的 Mark Word 要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p>
<p>1.4 偏向锁的关闭</p>
<p>偏向锁在 JDK6和 JDK7 中是默认启用的，但是在应用程序启动之后才激活。如果要关闭延迟，可以用 JVM参数设置：-XX:BiasedLockingStartupDelay=0;</p>
<p>关闭偏向锁：**-XXUseBiasedLocking=false**</p>
</li>
<li><p>轻量级锁</p>
<p>如果获取偏向锁失败，虚拟机会尝试获取轻量级锁。</p>
<p>2.1 加锁</p>
<p>线程在执行同步块之前，JVM 会在当前线程的栈帧中创建用于存储锁记录（Lock Record）的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称之为 <strong>Displaced Mark Word</strong>，然后线程尝试使用 CAS 将对象头中的 Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败则表示其他线程竞争锁，当前线程会尝试使用自旋来获得锁。</p>
<p>2.2 解锁</p>
<p><strong>使用 CAS 操作将 Displaced Mark Word 替换回到对象头</strong>，如果成功则表示没有出现竞争，如果失败表示当前锁存在竞争，此时锁就会膨胀成重量级锁。</p>
<p>一旦锁升级到重量级锁，此时锁就无法恢复到轻量级锁状态，处于这个状态（重量级锁）不会出现自旋，其他线程尝试获得锁时都会被阻塞，知道当前持有重量级锁的线程释放锁之后再去唤醒这些锁，继续进行锁的竞争。</p>
</li>
<li><p>自旋锁</p>
<p>所谓自旋锁，可以理解为循环。轻量级锁获取失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。避免操作系统实现线程之间的切换时需要从用户态转换到核心态，造成相对较高的时间成本，如果在自旋的过程中，当前的线程可以获得锁则结束自旋，如果一直无法获取锁，则会膨胀成重量级锁。</p>
</li>
<li><p>重量级锁</p>
<p>重量级锁是依赖管程对象 Monitor，Monitor 是通过操作系统的 Mutex互斥量（操作系统维护的 PThread）,而且使用 synchronized 需要操作系统从用户态切换到内核态。</p>
</li>
</ol>
<h3 id="锁的优缺点比对"><a href="#锁的优缺点比对" class="headerlink" title="锁的优缺点比对"></a>锁的优缺点比对</h3><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁与解锁不需要额外的消耗，执行效率高</td>
<td>线程之间存在竞争时，会带来撤销锁的消耗</td>
<td>只适用于一个线程访问同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞（线程交替进行），提高程序的响应时间</td>
<td>存在一直自旋消耗 CPU的情况</td>
<td>追求响应时间</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不会出现自旋情况</td>
<td>线程阻塞，响应时间慢</td>
<td>追求吞吐量，同步块执行速度快</td>
</tr>
</tbody></table>
<h2 id="内置锁（Synchronized）的加锁升级过程"><a href="#内置锁（Synchronized）的加锁升级过程" class="headerlink" title="内置锁（Synchronized）的加锁升级过程"></a>内置锁（Synchronized）的加锁升级过程</h2><p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230902142635395.png" alt="image-20230902142635395"></p>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发编程（六）线程入门</title>
    <url>/2021/01/04/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p>进程（Process）是计算机系统资源分配和调度的基本单位，是操作系统结构的基础。进程是程序执行的基本执行实体；是线程的容器；</p>
<h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><ul>
<li>管道</li>
<li>信号</li>
<li>消息队列</li>
<li>共享内存</li>
<li>信号量</li>
<li>套接字socket  </li>
</ul>
<h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>现代操作系统调度的最小单元，也被称为轻量级进程。每个线程都有自己的计数器，堆栈和局部变量等属性，并且可以访问共享的内存变量。</p>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>线程的优先级是决定线程需要分配多少处理器资源的线程属性。在 Java 中通过整型变量 priority 来设置优先级:setPriority(int level)，默认是 5；优先级区间：1~10；</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>Java 线程在运行的生命周期中有 6 种不同的状态，在给定的一个时刻，线程只能处于一个状态。</p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>初始状态，线程被构建，但是还没调用 start()方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态，Java 线程将操作系统中的就绪和运行两种状态统称“运行中”</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出特点操作（通知或中断）</td>
</tr>
<tr>
<td>TIME_WAITING</td>
<td>超时等待，它可以在指定的时间自行返回</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/0081Kckwgy1gmc1tsyh10j316l0u0apn-20230903120603689.jpg"></p>
<h3 id="线程的启动与终止"><a href="#线程的启动与终止" class="headerlink" title="线程的启动与终止"></a>线程的启动与终止</h3><h4 id="线程的启动"><a href="#线程的启动" class="headerlink" title="线程的启动"></a>线程的启动</h4><p>当线程被创建完成后，需要调用 start()方法启动线程。<strong>注意，不能通过调用 run()启动线程</strong>，虽然可以执行 run()方法内部的代码逻辑，但是实际上是主线程在执行，而不是创建的线程。</p>
<h4 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h4><p> 中断可以理解为线程的一个标识位属性，表示运行中的线程是否被其他线程进行了中断操作。线程可以通过 isInterrupted()判断自身是否被中断，也可以通过 Thread.interrupted()对当前线程的中断标志进行复位。如果当前线程处于终结状态或被中断过，在调用 isInterrupted()方法时会返回 false;</p>
<h4 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h4><p>线程的中断是终止线程的一种方式，但是还有终止线程的方式：cancel()。</p>
<h2 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h2><h4 id="volatile-与-synchronized-关键字"><a href="#volatile-与-synchronized-关键字" class="headerlink" title="volatile 与 synchronized 关键字"></a>volatile 与 synchronized 关键字</h4><p>通过 JMM 的学习我们知道，线程之间的通信是通过主内存（共享内存）进行的。因此避免不了使用 volatile 与 synchronized。</p>
<ul>
<li><p>关键字 volatile 的使用是告知程序在访问该关键字修饰的变量时，需要访问共享内存，同时将共享内存中该变量的值回刷到线程的本地内存中，从而确保该变量在所有线程的内存可见性。</p>
</li>
<li><p>关键字 synchronized 可以修饰方法和同步块。但是在二者的实现略有不同：</p>
</li>
</ul>
<p>对于同步块：synchronized 使用 monitorenter 和 monitorexit 指令</p>
<p>对于同步方法：synchronized 实现同步的原理是依赖方法修饰符上的 ACC_SYNCHRONIZED 来完成的</p>
<p>二者的本质是通过获取 monitor，这个获取过程的具有排他性的。</p>
<h4 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h4><p>等待通知机制是指一个线程A调用的对象O的 wait()方法进入等待状态，而另一个线程B调用了对象 O 的 notify()或者 notifyAll(),A线程收到通知后从对象O 的 wait()方法中返回，继续执行后续操作。该机制通过对象完成线程间的通信。</p>
<ul>
<li>wait()：使<strong>调用该方法的线程释放共享资源锁</strong>，然后从运行状态退出，进入等待队列，直到被再次唤醒。</li>
<li>wait(long)：超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回。</li>
<li>wait(long，int)：对于超时时间更细力度的控制，单位为纳秒。</li>
<li>notify()：<strong>随机唤醒</strong>等待队列中等待同一共享资源的一个线程，并使该线程退出等待队列，进入可运行状态，也就是notify()方法仅通知一个线程。<strong>前提是获得对象的锁。</strong></li>
<li>notifyAll()：使所有正在等待队列中等待同一共享资源的全部线程退出等待队列，进入可运行状态。此时，优先级最高的那个线程最先执行，但也有可能是随机执行，这取决于JVM虚拟机的实现。</li>
</ul>
<p>注：Object.wait()方法在调用前提是：必须包含在对应的 synchronized 语句中，都需要首先获得目标对象的 monitor。</p>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发编程（二）volatile 关键字</title>
    <url>/2020/12/20/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89volatile%20%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h3 id="volatile-的定义与实现原理"><a href="#volatile-的定义与实现原理" class="headerlink" title="volatile 的定义与实现原理"></a>volatile 的定义与实现原理</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>Java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量——Java 语言规范第 3 版</p>
</blockquote>
<p>而关键字 volatile 的作用就是单独获得这个变量，确保在 Java 线程内存模型中其他的线程读取变量值是一致的。</p>
<h4 id="CPU相关术语"><a href="#CPU相关术语" class="headerlink" title="CPU相关术语"></a>CPU相关术语</h4><table>
<thead>
<tr>
<th align="left">术语</th>
<th>英文单词</th>
<th>术语描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">内存屏障</td>
<td>memory barriers</td>
<td>一组处理器指令，用于实现对内存的顺序限制</td>
</tr>
<tr>
<td align="left">缓冲行</td>
<td>cache line</td>
<td>CPU 告诉缓存中可以分配的最新存储单位。处理器填写缓存时会加载整个缓存行，现代 CPU需要执行几百次 CPU指令</td>
</tr>
<tr>
<td align="left">原子操作</td>
<td>atomic operations</td>
<td>不可中断，不可分割的一个或者一系列操作</td>
</tr>
<tr>
<td align="left">缓存行填充</td>
<td>cache line fill</td>
<td>当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个高速缓存行到适当的缓存（L1,L2,L3的或所有的缓存行）</td>
</tr>
<tr>
<td align="left">缓存命中</td>
<td>cache hit</td>
<td>如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器会从缓存中读取操作数而不是从内存中读取</td>
</tr>
<tr>
<td align="left">写命中</td>
<td>write hit</td>
<td>当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这缓存的地址是否在缓存行中，如果存在一个有效的缓冲行，则处理器将这个操作数写回到缓存，而不是写到内存，这个操作被称为写命中。</td>
</tr>
<tr>
<td align="left">写缺失</td>
<td>write misses the cache</td>
<td>一个有效的缓存行被写入到不存在的内存区域</td>
</tr>
</tbody></table>
<h4 id="volatile-的特性"><a href="#volatile-的特性" class="headerlink" title="volatile 的特性"></a>volatile 的特性</h4><ul>
<li>不同线程的内存可见性：当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。</li>
<li>禁止指令重排序，保证指令的有序性：如果一个线程先去写一个变量，另外一个线程再去读，那么写入操作一定在读操作之前。</li>
</ul>
<h4 id="volatile-特性的实现原理"><a href="#volatile-特性的实现原理" class="headerlink" title="volatile 特性的实现原理"></a>volatile 特性的实现原理</h4><h5 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h5><p>当 volatile 修饰的共享变量进行写操作时，代码转成汇编指令时会多出一行Lock 前缀的指令，lock前缀指令实际相当于一个内存屏障，该指令在多核 CPU中会有以下两个操作：</p>
<ul>
<li>将当前处理器缓存行的数据写回到系统内存</li>
<li>回写内存的操作会使其他 CPU 内缓存了该内存地址的数据无效</li>
</ul>
<p>另外，Lock 指令在重排序时不能使后面的指令重排序到内存屏障之前的位置 。</p>
<p>在多核处理器下，为了保证各个处理器的缓存一致，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据检查自己缓存的值是否已经过期，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当前处理器对这个数据进行修改操作时，会重新从系统内存中把数据读到处理器缓存中。</p>
<h5 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h5><p>JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，即不管怎么重排序，程序的执行结果不能改变。JMM具备一些先天的有序性,即不需要通过任何手段就可以保证的有序性，通常称为happens-before原则。</p>
<p>JSR-133定义了如下happens-before规则：</p>
<ul>
<li>程序顺序规则： 一个线程中的每个操作，happens-before于该线程中的任意后续操作</li>
<li>监视器锁规则：对一个线程的解锁，happens-before于随后对这个线程的加锁</li>
<li><strong>volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读</strong></li>
<li>传递性：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C</li>
<li>start()规则： 如果线程A执行操作ThreadB_start()(启动线程B) ,  那么A线程的ThreadB_start()happens-before 于B中的任意操作</li>
<li>join()原则： 如果A执行ThreadB.join()并且成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
<li>interrupt()原则： 对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生</li>
<li>finalize()原则：一个对象的初始化完成先行发生于它的finalize()方法的开始</li>
</ul>
<p>第3条规则，就适用到所讨论的volatile，如果一个线程先去写一个变量，另外一个线程再去读，那么写入操作一定在读操作之前。</p>
<p>举例:<br>1.状态量标记，就如上面对flag的标记：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span></span>&#123;  </span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">volatile</span> bool flag = <span class="keyword">false</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">          a = <span class="number">2</span>;              <span class="comment">//1</span></span><br><span class="line">          flag = <span class="keyword">true</span>;        <span class="comment">//2</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiply</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (flag) &#123;         <span class="comment">//3</span></span><br><span class="line">              <span class="keyword">int</span> ret = a * a;<span class="comment">//4</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种对变量的读写操作，标记为volatile可以保证修改对线程立刻可见。比synchronized,Lock有一定的效率提升。</p>
<p>2.单例模式的实现，典型的双重检查锁定（DCL）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种懒汉的单例模式，使用时才创建对象，而且为了避免初始化操作的指令重排序，给instance加上了volatile。</p>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发编程（五）Java内存模型</title>
    <url>/2020/12/27/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="现代计算机的内存模型"><a href="#现代计算机的内存模型" class="headerlink" title="现代计算机的内存模型"></a><strong>现代计算机的内存模型</strong></h2><p>在现代计算机中，CPU 指令的运行速度远超内存的存取速度，因此不得不在 CPU 和内存之间加入高速缓存来作为内存与处理器的缓冲。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230902103417666.png" alt="image-20230902103417666"></p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a><strong>JMM</strong></h2><p><strong>JMM(JavaMemoryModel)即 Java 内存模型</strong>，定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存（LocalMemory）,<strong>本地内存存储了该线程读/写共享变量的副本</strong>。</p>
<p>这里所说的变量指的是实例变量和类变量，不包含局部变量，因为<strong>局部变量是线程私有</strong>的，因此不存在竞争问题。线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量。</p>
<p>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</p>
<h2 id="本地内存和主内存的关系："><a href="#本地内存和主内存的关系：" class="headerlink" title="本地内存和主内存的关系："></a><strong>本地内存和主内存的关系：</strong></h2><p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230902104240606.png" alt="image-20230902104240606"></p>
<h2 id="MESI（缓存一致性协议）"><a href="#MESI（缓存一致性协议）" class="headerlink" title="MESI（缓存一致性协议）"></a><strong>MESI（缓存一致性协议）</strong></h2><p>MESI 是指4中状态的首字母。每个Cache line有4个状态，可用2个bit表示</p>
<table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">描述</th>
<th align="left">监听任务</th>
</tr>
</thead>
<tbody><tr>
<td align="left">M 修改 (Modified)</td>
<td align="left">该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</td>
<td align="left">缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。</td>
</tr>
<tr>
<td align="left">E 独享、互斥 (Exclusive)</td>
<td align="left">该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。</td>
<td align="left">缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。</td>
</tr>
<tr>
<td align="left">S 共享 (Shared)</td>
<td align="left">该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。</td>
<td align="left">缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。</td>
</tr>
<tr>
<td align="left">I 无效 (Invalid)</td>
<td align="left">该Cache line无效。</td>
<td align="left">无</td>
</tr>
</tbody></table>
<p>当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。                      </p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/008eGmZEgy1gnmd8hi8bpj31480u045q.jpg" alt="img"></p>
<p>注：缓存一致性协议只能保证<code>一行缓存行</code>内存一致性，当数据需要存储到更多的 cacheLine时，MESI 就不能保证，这是缓存一致性协议不再适用，需要升级总线锁去保证变量的内存可见性和一致性。</p>
<h2 id="缓存行伪共享"><a href="#缓存行伪共享" class="headerlink" title="缓存行伪共享"></a>缓存行伪共享</h2><h3 id="什么是伪共享"><a href="#什么是伪共享" class="headerlink" title="什么是伪共享?"></a>什么是伪共享?</h3><p>CPU缓存系统中是以缓存行(cache line)为单位存储的。目前主流的CPU Cache 的Cache Line 大小都是64Bytes。在多线程情况下，如果需要修改“共享同一个缓存行的变量”，就会无意中影响彼此的性能，这就是伪共享(False Sharing)。<br> 举个例子: 现在有2个long 型变量 a 、b，如果有t1在访问a，t2在访问b，而a与b刚好在同一个 cache line中，此时t1先修改a，将导致b被刷新。</p>
<h3 id="怎么解决伪共享"><a href="#怎么解决伪共享" class="headerlink" title="怎么解决伪共享?"></a>怎么解决伪共享?</h3><p><strong>补齐缓存行</strong>。Java8中新增了一个注解:@sun.misc.Contended。加上这个注解的类会自动补齐缓存行，需要注意的是此注解默认是无效的，需要在jvm启动时设置 <code>-XX:- RestrictContended </code>才会生效。</p>
<h2 id="嗅探"><a href="#嗅探" class="headerlink" title="嗅探"></a><strong>嗅探</strong></h2><p>每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p>
<h2 id="总线风暴"><a href="#总线风暴" class="headerlink" title="总线风暴"></a><strong>总线风暴</strong></h2><p>所谓 总线风暴就是 volatile 是基于 MESI 缓存一致性协议，需要不断从主内存嗅探和 循环CAS，过多无效的嗅探会导致总线带宽达到峰值。</p>
<h2 id="总线事务"><a href="#总线事务" class="headerlink" title="总线事务"></a>总线事务</h2><p>每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这些步骤称之为总线事务（Bus Transaction），总线事务包括读事务（Read Transaction）和写事务（Write Transaction）。</p>
<ul>
<li>读事务：从内存中传递数据到处理器</li>
<li>写事务：从处理器传递数据到内存中</li>
</ul>
<h2 id="总线裁决"><a href="#总线裁决" class="headerlink" title="总线裁决"></a>总线裁决</h2><p>总线裁决是指对同一个状态变更的CPU信号（对多个状态为 S的变量进行 Modified 操作）进行判定，判定哪个 CPU 信号有效，即完成 S-&gt;M 的状态切换，而判定无效的 CPU 变量副本会将状态由 S-&gt;I,并尝试重新读取内存中的变量。</p>
<p>注：总线会同步试图并发使用总线的事务。当多个处理器并发发起总线事务时，总线会通过总线仲裁（Bus Arbitration）对竞争做出裁决，<strong>总线仲裁会确保所有处理器都能公平访问内存</strong>。在处理器执行总线事务期间，总线会禁止其他处理器和 IO 设备对内存的读写。也就是说<strong>在任意时间，最多只有一个处理器可以访问内存</strong>。总线的这些工作机制确保了单个总线事务中的内存读写操作具有原子性。</p>
<h2 id="MESI的优化及引入的问题"><a href="#MESI的优化及引入的问题" class="headerlink" title="MESI的优化及引入的问题"></a>MESI的优化及引入的问题</h2><p>缓存的一致性消息传递是要时间的，这就使其<strong>切换时会产生延迟</strong>。当一个缓存被切换状态时其他缓存收到 消息完成各自的切换并且发出回应消息这么一长串的时间中CPU都会等待所有缓存响应完成。可能出现的<code>阻塞</code>都会导致各种各样的性能问题和稳定性问题。</p>
<h3 id="CPU切换状态阻塞"><a href="#CPU切换状态阻塞" class="headerlink" title="CPU切换状态阻塞"></a>CPU切换状态阻塞</h3><p>比如你需要修改本地缓存中的一条信息，那么你必须将I(无效)状态通知到其他拥有该缓存数据的CPU缓 存中，并且等待确认。等待确认的过程会阻塞处理器，这会降低处理器的性能。这个等待远远比一个 指令的执行时间长的多。</p>
<h3 id="Store-Bufferes"><a href="#Store-Bufferes" class="headerlink" title="Store Bufferes"></a>Store Bufferes</h3><p>为了避免这种CPU运算能力的浪费，Store Bufferes被引入使用。处理器把它想要写入到主存的值写到缓 存，然后继续去处理其他事情。当所有失效确认(Invalidate Acknowledge)都接收到时，数据才会最终被提交。</p>
<p>注：使用 Store Bufferes 是存在两个风险的</p>
<ul>
<li>处理器会尝试从存储缓存(Store buffer)中读取值，但它还没有进行提交。这个的解决方案 称为Store Forwarding，它使得加载的时候，如果存储缓存中存在，则进行返回。</li>
<li>保存什么时候会完成，这个并没有任何保证。</li>
</ul>
<h3 id="什么是重排序"><a href="#什么是重排序" class="headerlink" title="什么是重排序?"></a><strong>什么是重排序?</strong></h3><p>在执行程序时，为了提高性能，编译器和处理器常常对指令做重排序。</p>
<h3 id="重排序的类型有哪些呢？源码到最终执行会经过哪些重排序呢？"><a href="#重排序的类型有哪些呢？源码到最终执行会经过哪些重排序呢？" class="headerlink" title="重排序的类型有哪些呢？源码到最终执行会经过哪些重排序呢？"></a><strong>重排序的类型有哪些呢？源码到最终执行会经过哪些重排序呢？</strong></h3><p><strong>重排序分为 3 种类型</strong></p>
<ol>
<li>编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句执行顺序</li>
<li>指令级并行的重排序：现代 CPU采用指令级并行技术将多个指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应的指令执行顺序。</li>
<li>内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是乱序执行。</li>
</ol>
<p>Java 源码到最终实际执行的指令序列，会经过下列 3 种重排序。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/0081Kckwgy1gm2rvjeaowj319s0e4dh7.jpg" alt="从源码到最终执行的指令序列的示意图"></p>
<p>JMM 属于语言级别的内存模型。对于编译器重排序规则，JMM 会禁止特定类型的编译器重排序。而对于处理器重排序，JMM 会要求 Java 编译器在生成指令序列时，插入特定类型的内存屏障指令，从而禁止特定类型的处理器重排序</p>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>内存屏障，也称内存栅栏，内存栅障，屏障指令等， <strong>是一类同步屏障指令</strong>，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作</p>
<p>JMM 把内存屏障指令分为 4 类</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad Barriers</td>
<td>Load1;LoadLoad;Load2</td>
<td>确保 Load1 数据的装载先于 Load2 及所有后续装载指令的装载</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1;StoreStore;Store2</td>
<td>确保 Store1 数据对其他处理器可见（刷新到内存）先于 Store2 及其所有后续存储指令的存储</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1;LoadStore;Store2</td>
<td>确保 Load1 数据装载先于 Store2及其所有后续的存储指令刷新到内存</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>Store1;StoreLoad;Load2</td>
<td>确保 Store1数据对其他处理器变得可见（指刷新到内存）先于 Load2 及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（装载和储存指令）完成之后，才执行该屏障之后的内存访问指令</td>
</tr>
</tbody></table>
<p>其中：StoreLoad Barriers同时具备其他 3 个屏障的效果</p>
<h2 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h2><p>as-if-serial语义的意思是：不管如何重排序，单线程程序执行结果不能被改变。编译器、runtime 和处理器都必须遵守 as-if-serial语义，因此不会对存在数据依赖关系的操作做重排序，因为会改变程序执行结果。</p>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a><strong>happens-before</strong></h2><p>JSR-133定义了如下happens-before规则：</p>
<ul>
<li>程序顺序规则： 一个线程中的每个操作，happens-before于该线程中的任意后续操作</li>
<li>监视器锁规则：对一个线程的解锁，happens-before于随后对这个线程的加锁</li>
<li>volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读</li>
<li>传递性：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C</li>
<li>start()规则： 如果线程A执行操作ThreadB_start()(启动线程B) , 那么A线程的ThreadB_start()happens-before 于B中的任意操作</li>
<li>join()原则： 如果A执行ThreadB.join()并且成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
<li>interrupt()原则： 对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生</li>
<li>finalize()原则：一个对象的初始化完成先行发生于它的finalize()方法的开始</li>
</ul>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发编程（七）线程的创建</title>
    <url>/2021/01/08/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="通过继承Thread类创建线程"><a href="#通过继承Thread类创建线程" class="headerlink" title="通过继承Thread类创建线程"></a>通过继承Thread类创建线程</h1><h2 id="继承-Thread创建线程"><a href="#继承-Thread创建线程" class="headerlink" title="继承 Thread创建线程"></a>继承 Thread创建线程</h2><p>（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体为创建新线程要完成的任务。</p>
<p>（2）创建Thread子类的实例，即创建了线程对象。</p>
<p>（3）调用线程对象的<strong>start()方法来启动该线程</strong>。(注：一个线程的start方法只能被调用一次，多次调用会有异常)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatedThreadByExtendsThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> CreatedThreadByExtendsThread().start();</span><br><span class="line">        <span class="keyword">new</span> CreatedThreadByExtendsThread().start();</span><br><span class="line">        <span class="keyword">new</span> CreatedThreadByExtendsThread().start();</span><br><span class="line">        <span class="keyword">new</span> CreatedThreadByExtendsThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GetName()方法返回调用该方法的线程的名字。</p>
<h2 id="继承-Thread-匿名内部类创建"><a href="#继承-Thread-匿名内部类创建" class="headerlink" title="继承 Thread 匿名内部类创建"></a>继承 Thread 匿名内部类创建</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatedThreadByExtendsAnonymousInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化线程实例</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式主要是Thread的构造函数的区分，当target不为空的时候，会执行匿名内部类里面的run方法</p>
<h1 id="通过Runnable接口创建线程"><a href="#通过Runnable接口创建线程" class="headerlink" title="通过Runnable接口创建线程"></a>通过Runnable接口创建线程</h1><h2 id="实现-Runnable方法创建线程"><a href="#实现-Runnable方法创建线程" class="headerlink" title="实现 Runnable方法创建线程"></a>实现 Runnable方法创建线程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatedThreadByImplRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunnableThreadTest runnableThreadTest = <span class="keyword">new</span> RunnableThreadTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnableThreadTest, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnableThreadTest, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现Runnable接口的方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()  + <span class="string">&quot; is running: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="通过实现-Runnable接口的匿名内部类创建线程"><a href="#通过实现-Runnable接口的匿名内部类创建线程" class="headerlink" title="通过实现 Runnable接口的匿名内部类创建线程"></a>通过实现 Runnable接口的匿名内部类创建线程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 实现 Runnable 的匿名内部类</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createdThreadByImplRunnableInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 初始化线程实例</span></span><br><span class="line">     Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;通过实现 Runnable接口的匿名内部类创建线程...&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     thread.start();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>该方法用 Java8的 lambda 表达式简化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 实现 Runnable 的匿名内部类</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createdThreadByImplRunnableInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 初始化线程实例</span></span><br><span class="line">     Thread thread = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;通过实现 Runnable接口的匿名内部类创建线程...&quot;</span>));</span><br><span class="line">     thread.start();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h1 id="通过Callable和FutureTask创建线程"><a href="#通过Callable和FutureTask创建线程" class="headerlink" title="通过Callable和FutureTask创建线程"></a>通过Callable和FutureTask创建线程</h1><p>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 </p>
<p>（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</p>
<p>（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。 </p>
<p>（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<p>和Runnable接口不一样，Callable接口提供了一个call()方法作为线程执行体，call()方法比run()方法功能要强大：call()方法可以有返回值，可以声明抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatedThreadByImplCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getId() + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;Long&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CreatedThreadByImplCallable());</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;等待完成任务&quot;</span>);</span><br><span class="line">        Long result = task.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;任务结果：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现Callabe接口，可以获取线程执行的结果，FutureTask实际上实现了Runnable接口。</p>
<h1 id="其他创建线程的方法"><a href="#其他创建线程的方法" class="headerlink" title="其他创建线程的方法"></a>其他创建线程的方法</h1><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatedThreadByTimer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        <span class="comment">// 每隔1秒执行一次</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span> , <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatedThreadByThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(()-&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用线程池的方式，可以复用线程，减少频繁开启关闭线程带来的开销，节约系统资源。</p>
<h2 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatedThreadByParallelStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 串行，打印结果为12345</span></span><br><span class="line">        list.stream().forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 并行，打印结果随机，比如35214</span></span><br><span class="line">        list.parallelStream().forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用并行计算的方式，可以提高程序运行的效率，多线程并行执行。</p>
<h2 id="Spring-的异步方法"><a href="#Spring-的异步方法" class="headerlink" title="Spring 的异步方法"></a>Spring 的异步方法</h2><p>首先需要在 SpringBoot 的启动类上面加上<code>@EnableAsync</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在需要进行异步执行的方法上加上<code>@Async</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatedThreadBySpringAsync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实创建线程的本质就是：</p>
<ul>
<li>继承 Thread 类并重新 run()方法</li>
<li>实现 Runnable接口的 run()方法</li>
</ul>
<p>注：当同时继承 Thread 类重写 run()和实现 Runnable 接口的 run()方法时，线程真正执行的方法体是重写Thread的run()方法中的内容。</p>
<h1 id="创建线程方式的比对"><a href="#创建线程方式的比对" class="headerlink" title="创建线程方式的比对"></a>创建线程方式的比对</h1><h2 id="实现Runnable-Callable接口相比继承Thread类的优势"><a href="#实现Runnable-Callable接口相比继承Thread类的优势" class="headerlink" title="实现Runnable/Callable接口相比继承Thread类的优势"></a>实现Runnable/Callable接口相比继承Thread类的优势</h2><p>总体来说一般的业务代码中都是采用实现Runnable接口或者是Callable接口</p>
<ul>
<li><p>可以避免java中单继承的限制</p>
</li>
<li><p>适合多个线程进行资源共享</p>
</li>
<li><p>线程池只能放入Runable或Callable接口实现类，不能直接放入继承Thread的类</p>
</li>
</ul>
<h2 id="Callable和Runnable的区别"><a href="#Callable和Runnable的区别" class="headerlink" title="Callable和Runnable的区别"></a>Callable和Runnable的区别</h2><ul>
<li><p>Callable重写的是call()方法，Runnable重写的方法是run()方法</p>
</li>
<li><p>call()方法执行后可以有返回值，run()方法没有返回值</p>
</li>
<li><p>call()方法可以抛出异常，run()方法不可以</p>
</li>
<li><p>运行Callable任务可以拿到一个Future对象，表示异步计算的结果 。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/2020/09/11/Java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>所谓函数式编程就是将函数（一段操作）作为一个基本单位进行传递。以前的Java中参数只能是具体的变量，函数式编程打破这一规范，可以将整个方法作为一个参数传递。</p>
<p>Java毕竟是面向对象的编程语言，你要传递的东西，必须是一个类或接口的对象或者一个基本类型变量，所以Java就定义了函数式接口，用来承载传递的函数。</p>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口是在JDK1.8中提出的新概念，但对应的却是老结构，在以往版本的JDK中就已经存在这种结构，只是没有定义化。</p>
<p>函数式接口就是只有一个抽象方法的接口。常用的函数式接口有Runnable、Comparator等。</p>
<p>JDK1.8将这些接口取了一个统一的名称函数式接口，为了规范化，同时避免用户自定义函数式接口时错误的添加了其他的抽象方法，<br>而定义了一个注解：@FunctionalInterface，凡是由该注解标注的接口，统统为函数式接口，强制性的只有一个抽象方法。</p>
<p>为了函数式接口的扩展，JDK对接口规范进行了进一步修改，接口中除了可以定义抽象方法之外，还能够定义静态方法，和默认方法，<br>而且这两种方法可以拥有自己的实现。其中静态方法一般作为工具方法，而默认方法是可以被继承重写的，<br>还能拥有一个默认的实现。除此之外，函数式接口中还可以重写Object中定义的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 典型函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Itest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 重写Object中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这是一个默认方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这是一个静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda表达式，简化了匿名内部类的操作方式。</p>
<p>Lamnda表达式可以用在两个地方，一种是集合遍历，另一种就是替换匿名内部类。</p>
<p>前者基于Iterable接口和Map接口中定义的forEach方法，后者则依据函数式接口。</p>
<ul>
<li>forEach方法<br>其实forEach方法是对函数式接口的有效利用，将遍历的书写流程简化，我们不用再写一大堆的for循环框架代码。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LanbdaTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list &#x3D; Collections.EMPTY_LIST;</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">        Map&lt;String,Object&gt; map &#x3D; Collections.EMPTY_MAP;</span><br><span class="line">        map.forEach((k,v) -&gt; System.out.println(k + &quot;:&quot;+ v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
forEach方法的参数是Consumer或者BiConsumer，主要用于消费资源，即需要提供参数，<br>但是没有返回值的方法（函数或操作）。</li>
</ul>
<p>forEach方法最开始是在Iterable接口和Map接口中定义的，这是以默认方法的方式定义的，<br>分别以Consumer和BiConsumer作为入参。</p>
<p>Iterable中的forEach方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Iterable&lt;T&gt; &#123;</span><br><span class="line">    default void forEach(Consumer&lt;? super T&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        for (T t : this) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Iterable的实现类均可以通过重写该方法来自定义遍历的方式。</p>
<p>比如以数组为底层结构的ArrayList、CopyOnWriteArrayList、CopyOnWriteArraySet等都是<br>以普通for循环来实现的遍历。而以链表为底层结构的LinkedList则没有重写forEach方法，<br>采用默认方法中简化的for循环，编译器会对其进行处理，将其采用Iterator进行遍历。</p>
<ul>
<li>Map中的forEach方法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Map&lt;K,V&gt; &#123;</span><br><span class="line">    default void forEach(BiConsumer&lt;? super K, ? super V&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        for (Map.Entry&lt;K, V&gt; entry : entrySet()) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            V v;</span><br><span class="line">            try &#123;</span><br><span class="line">                k &#x3D; entry.getKey();</span><br><span class="line">                v &#x3D; entry.getValue();</span><br><span class="line">            &#125; catch(IllegalStateException ise) &#123;</span><br><span class="line">                &#x2F;&#x2F; this usually means the entry is no longer in the map.</span><br><span class="line">                throw new ConcurrentModificationException(ise);</span><br><span class="line">            &#125;</span><br><span class="line">            action.accept(k, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在常用的HashMap和TreeMap中都对该方法进行了重写，HashMap采用数组+链表（红黑树）的方式实现，<br>但是遍历的时候采用的就是数组+链表双重遍历，因为在HashMap中的红黑树同时还是一个双向链表。<br>而TreeMap中则是使用树结构的<strong>中序遍历</strong>方式实现的。</li>
</ul>
<h4 id="替换匿名内部类"><a href="#替换匿名内部类" class="headerlink" title="替换匿名内部类"></a>替换匿名内部类</h4><p>Lambda替换匿名内部类有一个前提，那就是这个匿名内部类的接口类型必须为函数式接口，<br>如果不是函数式接口，是无法使用Lambda替换的。</p>
<p>常用的函数式接口为Runnable，使用匿名内部类方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LambdaTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;采用匿名内部类&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Lambda替换如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LambdaTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t1 &#x3D; new Thread(()-&gt;System.out.println(&quot;采用Lambda方式&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lambda表达式最大的作用其实就是替换匿名内部类，简化这种写法。</p>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>方法引用出现的目的是为了解决所需的操作已经存在的情况。</p>
<p>当我们需要传递的操作已经存在，那就不必再费尽心思的再写一个出来了，直接使用方法引用来将已有的方法给它就行了。</p>
<p>方法引用使用“::”双英文冒号组成的操作符来指定方法。</p>
<p>这种形式参数不再是显式传递，采用方法引用之后，参数会自动传递，我们举个例子看看简单的原理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LanbdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">(Supplier&lt;String&gt; supplier)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;huahua&quot;</span>);</span><br><span class="line">        System.out.println(getName(person::getName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">huahua</span><br></pre></td></tr></table></figure>

<p>解析：<br>首先我们使用了方法引用：person::getName，Person类中有已定义好的获取name的方法，这里就可以直接引用该方法。<br>Supplier是供应者，可以无中生有，也就是不需要参数，产生一个返回值。</p>
<p>Person中的getName方法，明显就符合Supplier的格式，没有参数，但是返回了一个结果，<br>所以这里就可以直接传递person::getName。</p>
<p>方法引用的种类：</p>
<ul>
<li>类的构造器引用：ArrayList::new、String[]::new</li>
<li>类的静态方法引用：String::valueOf、Integer::valueOf</li>
<li>类的实例方法引用：String::length、Person::getName</li>
<li>对象的实例方法引用：sring::length、person::getName<br>方法引用于Lambda可以算是平等，并列的关系，Lambda用于自定义操作，方法引用用于引用已存在的操作。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程（十二）原子类介绍与使用</title>
    <url>/2021/03/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%8E%9F%E5%AD%90%E7%B1%BB%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Atomic原子类"><a href="#Atomic原子类" class="headerlink" title="Atomic原子类"></a>Atomic原子类</h1><p>所谓原子类就是具有原子操作特征的类，原子操作时不会受到其他线程的干扰。在 JUC 下的 Atomic 根据实际操作的数据类型可以分为 4类，分别是：原子更新基本数据类型、原子更新数组、原子更新引用、原子更新对象属性。这些类都是使用非阻塞算法 CAS 实现的</p>
<h2 id="原子更新基本数据类型类"><a href="#原子更新基本数据类型类" class="headerlink" title="原子更新基本数据类型类"></a>原子更新基本数据类型类</h2><p>该类是使用原子方式更新基本数据类型，主要有以下三个类：</p>
<ul>
<li>AtomicInteger：整型原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean：布尔类型原子类</li>
</ul>
<p>以 AtomicInteger 为例，JDK 提供了以下常用 API</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 以原子方式将输入的数值与实例中的值相加，并返回旧值</span></span><br><span class="line">        <span class="keyword">int</span> getAndAdd = atomicInteger.getAndAdd(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;getAndAdd result is:&quot;</span> + getAndAdd);</span><br><span class="line">        <span class="comment">// 以原子方式将输入的数值与实例中的值相加，并返回新值</span></span><br><span class="line">        <span class="keyword">int</span> addAndGet = atomicInteger.addAndGet(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;addAndGet result is: &quot;</span> + addAndGet);</span><br><span class="line">        <span class="comment">// 如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。</span></span><br><span class="line">        <span class="keyword">boolean</span> b = atomicInteger.compareAndSet(<span class="number">10</span>, <span class="number">13</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;compareAndSet result is: &quot;</span> + b);</span><br><span class="line">        <span class="comment">// 以原子方式自增 1，返回的是自增前的值</span></span><br><span class="line">        <span class="keyword">int</span> andIncrement = atomicInteger.getAndIncrement();</span><br><span class="line">        System.out.println(<span class="string">&quot;getAndIncrement result is: &quot;</span> + andIncrement);</span><br><span class="line">        <span class="comment">// 以原子方式自增 1，返回自增后的值</span></span><br><span class="line">        <span class="keyword">int</span> incrementAndGet = atomicInteger.incrementAndGet();</span><br><span class="line">        System.out.println(<span class="string">&quot;incrementAndGet result is: &quot;</span> + incrementAndGet);</span><br><span class="line">        atomicInteger.lazySet(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 以原子方式设置为 newValue 的值，并返回旧值</span></span><br><span class="line">        <span class="keyword">int</span> andSet = atomicInteger.getAndSet(<span class="number">30</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;getAndSet result is:&quot;</span> + andSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原子更新数组类"><a href="#原子更新数组类" class="headerlink" title="原子更新数组类"></a>原子更新数组类</h2><p>使用原子方式更数组里的元素，Atomic 提供了以下几个类：</p>
<ul>
<li><p>AtomicIntegerArray：原子方式更新整型数组里的元素</p>
</li>
<li><p>AtomicLongArray：原子更新长整型数组里的元素</p>
</li>
<li><p>AtomicRefrenceArray：原子更新引用类型数组里的元素</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicIntegerArray atomicIntegerArray = <span class="keyword">new</span> AtomicIntegerArray(array);</span><br><span class="line">        <span class="keyword">int</span> index0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> delta = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 返回更新后（拷贝）数组下标为 index0 并且加上 delta 之后的值</span></span><br><span class="line">        <span class="keyword">int</span> addAndGet = atomicIntegerArray.addAndGet(index0, delta);</span><br><span class="line">        System.out.println(<span class="string">&quot;addAndGet result is:&quot;</span> + addAndGet);</span><br><span class="line">        System.out.println(<span class="string">&quot;old array[&quot;</span> + index0 + <span class="string">&quot;]&quot;</span> + <span class="string">&quot;is:&quot;</span> + array[index0]);</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 返回更新后（拷贝）数组下标为 index0 并且加上 delta 之前的值</span></span><br><span class="line">        <span class="keyword">int</span> getAndAdd = atomicIntegerArray.getAndAdd(index1, delta);</span><br><span class="line">        System.out.println(<span class="string">&quot;getAndAdd result is:&quot;</span> + getAndAdd);</span><br><span class="line">        System.out.println(<span class="string">&quot;old array[&quot;</span> + index1 + <span class="string">&quot;]&quot;</span> + <span class="string">&quot;is:&quot;</span> + array[index1]);</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 返回更新（自减 1）后（拷贝）数组下标为 index2 的值</span></span><br><span class="line">        <span class="keyword">int</span> decrementAndGet = atomicIntegerArray.decrementAndGet(index2);</span><br><span class="line">        System.out.println(<span class="string">&quot;decrementAndGet result is: &quot;</span> + decrementAndGet);</span><br><span class="line">        System.out.println(<span class="string">&quot;old array[&quot;</span> + index2 + <span class="string">&quot;]&quot;</span> + <span class="string">&quot;is:&quot;</span> + array[index2]);</span><br><span class="line">        <span class="keyword">int</span> index3 = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 返回更新（自增 1）后（拷贝）数组下标为 index3 的值</span></span><br><span class="line">        <span class="keyword">int</span> incrementAndGet = atomicIntegerArray.incrementAndGet(index3);</span><br><span class="line">        System.out.println(<span class="string">&quot;incrementAndGet result is: &quot;</span> + incrementAndGet);</span><br><span class="line">        System.out.println(<span class="string">&quot;old array[&quot;</span> + index3 + <span class="string">&quot;]&quot;</span> + <span class="string">&quot;is:&quot;</span> + array[index3]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="原子更新引用类"><a href="#原子更新引用类" class="headerlink" title="原子更新引用类"></a>原子更新引用类</h2><ul>
<li>AtomicReference：原子更新引用类型类</li>
<li>AtomicReferenceFieldUpdater:原子更新引用类型里的字段</li>
<li>AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，但是标记并不能解决CAS 中可能出现的 ABA 问题，因为该 API 的标记位只有 true/false。</li>
<li>AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
</ul>
<p><strong>AtomicReference</strong>的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicRefrenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 声明原子更新的引用类型</span></span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">25</span>);</span><br><span class="line">        atomicReference.set(user);</span><br><span class="line">        User updatePerson = <span class="keyword">new</span> User(<span class="string">&quot;lisi&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 原子更新引用类型中的属性，调用 unsafe 的compareAndSwapObject更新对象方法</span></span><br><span class="line">        atomicReference.compareAndSet(user, updatePerson);</span><br><span class="line">        </span><br><span class="line">        System.out.println(atomicReference.get().getUserName());</span><br><span class="line">        System.out.println(atomicReference.get().getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String userName, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.userName = userName;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> userName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>AtomicMarkableReference</strong>的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicMarkableReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化、取当前值和 mark 值</span></span><br><span class="line">        <span class="keyword">final</span> Boolean initialRef = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> initialMark = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicMarkableReference&lt;Boolean&gt; atomicMarkableReference = <span class="keyword">new</span> AtomicMarkableReference&lt;&gt;(initialRef, initialMark);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + atomicMarkableReference.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentMark=&quot;</span> + atomicMarkableReference.isMarked());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compare and set</span></span><br><span class="line">        <span class="keyword">final</span> Boolean newReference1 = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> newMark1 = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> compareAndSet = atomicMarkableReference.compareAndSet(initialRef, newReference1, initialMark, newMark1);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + atomicMarkableReference.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentMark=&quot;</span> + atomicMarkableReference.isMarked()</span><br><span class="line">                + <span class="string">&quot;, compareAndSet result is :&quot;</span> + compareAndSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前的值和当前的 mark 值</span></span><br><span class="line">        <span class="keyword">boolean</span>[] arr = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> Boolean currentValue = atomicMarkableReference.get(arr);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> currentMark = arr[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + currentValue + <span class="string">&quot;, currentMark=&quot;</span> + currentMark);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单独设置 mark 值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> attemptMarkResult = atomicMarkableReference.attemptMark(newReference1, <span class="keyword">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + atomicMarkableReference.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentMark=&quot;</span> + atomicMarkableReference.isMarked()</span><br><span class="line">                + <span class="string">&quot;, attemptMarkResult is &quot;</span> + attemptMarkResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新设置当前值和 mark 值</span></span><br><span class="line">        atomicMarkableReference.set(initialRef, initialMark);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + atomicMarkableReference.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentMark=&quot;</span> + atomicMarkableReference.isMarked());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="原子更新对象属性类"><a href="#原子更新对象属性类" class="headerlink" title="原子更新对象属性类"></a>原子更新对象属性类</h2><ul>
<li>AtomicIntegerFieldUpdater:原子更新整形字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整形字段的更新器</li>
<li>AtomicReferenceFieldUpdater ：原子更新引用类型里的字段的更新器</li>
</ul>
<p>要想原子地更新对象的属性需要两步。</p>
<p>第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</p>
<p>第二步，更新的对象属性<strong>必须使用 public volatile 修饰符</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明原子更新的引用类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; atomicReference = AtomicIntegerFieldUpdater.newUpdater(User.class,<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(atomicReference.getAndIncrement(user));</span><br><span class="line">        System.out.println(atomicReference.get(user));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String userName, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.userName = userName;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> userName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程（十）线程池</title>
    <url>/2021/01/06/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="核心线程池的内部实现"><a href="#核心线程池的内部实现" class="headerlink" title="核心线程池的内部实现"></a>核心线程池的内部实现</h2><h3 id="ThreadPoolExecutor-类"><a href="#ThreadPoolExecutor-类" class="headerlink" title="ThreadPoolExecutor 类"></a>ThreadPoolExecutor 类</h3><ol>
<li><p>构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">pubilic <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maxmumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit, </span></span></span><br><span class="line"><span class="function"><span class="params">                           BolockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                           RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<p>各个参数的含义如下：</p>
<ul>
<li><strong>corePoolSize</strong>:指定线程池中的线程数量</li>
<li><strong>maxmumPoolSize</strong>:指定了线程池中最大的线程数。</li>
<li><strong>keepAliveTime</strong>:当线程池线程数量超过 corePoolSize 时，多余的空闲线程的存活时间，即超过 <strong>corePoolSize</strong> 的空闲线程在多长时间内会被销毁。</li>
<li><strong>unit</strong>:keepAliveTime 的单位</li>
<li><strong>workQueue</strong>:任务队列，被提交但尚未执行的任务</li>
<li><strong>threadFactory</strong>:线程工厂，用于创建线程，一般默认的即可</li>
<li><strong>RejectedExecutionHandler</strong>:拒绝策略，当任务过多来不及处理时，如何拒绝任务。</li>
</ul>
</li>
<li><p>workQueue：提交但未执行的任务队列，它是个一个 BlockingQueue 接口的对象，仅存放 Runnable对象。根据实际使用的情况可以使用以下 BlockingQueue 接口</p>
<ul>
<li><p>直接提交队列：由 SynchronoursQueue 对象提供。该对象是一个特殊的 BlockingQueue。SynchronousQueue <strong>没有容量不会保存提交的任务</strong>，每一个插入操作都需要等待一个相应的删除操作，反之，每个删除操作都要等待对应的插入操作。如果进程数量已经达到最大值，则执行拒绝策略，因此使用该队列，通常要设置 很大的 maxnumPoolSize 值，否则很容易执行拒绝策略。</p>
</li>
<li><p>有界的任务队列：有界的任务队列可以使用 ArrayBlockingQueue 类实现，该类的构造函数需要一个参数，定义该队列的最大容量；当使用有界的任务队列时，若有新的任务需要执行：</p>
<ul>
<li>如果线程池的实际线程数小于 corePoolSize，则优先创建新的线程</li>
<li>大于 corePoolSize:<ul>
<li>等待队列未满：加入等待队列</li>
<li>等待队列已满：在总数不大于 maximumPoolSize的前提下创建新的进程执行任务；大于 maximumPoolSize则执行拒绝策略</li>
</ul>
</li>
</ul>
<p>即：有界队列当且仅当任务队列装满，才可以将线程数提升到 corePoolSize 以上，通常情况下要确保核心线程数维持在 corePoolSize</p>
</li>
<li><p>无界的任务队列：无界任务队列可以通过 LinkedBlockingQueue 实现。</p>
<ul>
<li>通常情况下不存在任务入队失败的情况（前提是系统资源正常）</li>
<li>新任务提交时，线程数小于 corePoolSize 时，线程池会生成新的线程执行任务</li>
<li>当系统线程数达到 corePoolSize 后就不会继续增加了。若没空闲资源则进入等待队列；</li>
<li>若任务创建和处理的速度差距很大，无界队列会保持快速增长，直至资源耗尽。</li>
</ul>
</li>
<li><p>优先任务队列：</p>
<ul>
<li>具有优先级的队列</li>
<li>通过 PriorityBlockingQueue 类实现，可以控制任务的执行先后顺序</li>
<li>特殊的无界队列</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="线程池工作过程"><a href="#线程池工作过程" class="headerlink" title="线程池工作过程"></a>线程池工作过程</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">          Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   <strong>当使用线程池的构造函数创建线程池时，线程池中是没有线程的</strong>。而Tomcat的线程池会在创建线程池对象时，创建线程。</p>
<h4 id="任务处理"><a href="#任务处理" class="headerlink" title="任务处理"></a>任务处理</h4><p>   <img src="https://raw.githubusercontent.com/he-You/image/master/image-20230906142645764.png" alt="image-20230906142645764"></p>
<p>   ThreadPoolExecutor中提供了两种执行任务的方法：</p>
<ol>
<li><p>void execute(Runnable command)</p>
</li>
<li><p>Future submit(Runnable task)</p>
<p>实际上submit中最终还是调用的execute()方法，只不过会返回一个Future对象，用来获取任务执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而execute方法执行的核心逻辑代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    if (addWorker(command, true))</span><br><span class="line">        return;</span><br><span class="line">    c &#x3D; ctl.get();</span><br><span class="line">&#125;</span><br><span class="line">if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    int recheck &#x3D; ctl.get();</span><br><span class="line">    if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        reject(command);</span><br><span class="line">    else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">        addWorker(null, false);</span><br><span class="line">&#125;</span><br><span class="line">else if (!addWorker(command, false))</span><br><span class="line">    reject(command);</span><br></pre></td></tr></table></figure>

<p>具体的逻辑为：</p>
</li>
<li><p>如果当前工作线程的数量小于核心线程数，则继续创建新的线程进行任务处理</p>
</li>
<li><p>如果条件1不成立，则尝试进行入队操作，将任务放入等待队列中</p>
</li>
<li><p>如果队列满了，则判断当前线程数是否达到最大线程数，如果小于最大线程数，则继续创建新线程进行任务处理（新的线程处理完任务之后，同样回去队列中获取任务进行处理，当阻塞队列为空时，会淘汰大于核心线程数部分的线程）</p>
</li>
<li><p>如果大于最大线程数，则执行拒绝策略</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230906135252249.png" alt="image-20230906135252249"></p>
</li>
</ol>
<p>   <strong>注意：提交一个Runnable时，不管当前线程池中的线程是否空闲，只要数量小于核心线程数就会创建新线程。</strong></p>
<p>   <strong>注意：ThreadPoolExecutor相当于是非公平的，比如队列满了之后提交的Runnable可能会比正在排队的Runnable先执行。</strong></p>
<h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>   JDK线程池类提供了4种拒绝策略，分别是：</p>
<ol>
<li><p>AbortPolicy :直接抛出异常</p>
</li>
<li><p>CallerRunsPolicy：由提交任务的线程进行处理任务</p>
</li>
<li><p>DiscardOldestPolicy：丢弃掉队列头的任务</p>
</li>
<li><p>DiscardPolicy：不处理，丢弃掉</p>
<p>当然可以根据实际业务场景实现RejectedExecutionHandler接口自定义拒绝策略</p>
<h4 id="线程池的五种状态是如何流转的？"><a href="#线程池的五种状态是如何流转的？" class="headerlink" title="线程池的五种状态是如何流转的？"></a>线程池的五种状态是如何流转的？</h4><p>线程池有五种状态：</p>
</li>
</ol>
<ul>
<li><p>RUNNING：<strong>会</strong>接收新任务并且<strong>会</strong>处理队列中的任务</p>
</li>
<li><p>SHUTDOWN：<strong>不会</strong>接收新任务并且<strong>会</strong>处理队列中的任务</p>
</li>
<li><p>STOP：<strong>不会</strong>接收新任务并且<strong>不会</strong>处理队列中的任务，并且会中断在处理的任务（注意：一个任务能不能被中断得看任务本身）</p>
</li>
<li><p>TIDYING：所有任务都终止了，线程池中也没有线程了，这样线程池的状态就会转为TIDYING，一旦达到此状态，就会调用线程池的terminated()</p>
</li>
<li><p>TERMINATED：terminated()执行完之后就会转变为TERMINATED</p>
<p>这五种状态并不能任意转换，只会有以下几种转换情况：</p>
</li>
</ul>
<ol>
<li><p>RUNNING -&gt; SHUTDOWN：手动调用shutdown()触发，或者线程池对象GC时会调用finalize()从而调用shutdown()</p>
</li>
<li><p>(RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow()触发，如果先调shutdown()紧着调shutdownNow()，就会发生SHUTDOWN -&gt; STOP</p>
</li>
<li><p>SHUTDOWN -&gt; TIDYING：队列为空并且线程池中没有线程时自动转换</p>
</li>
<li><p>STOP -&gt; TIDYING：线程池中没有线程时自动转换（队列中可能还有任务）</p>
</li>
<li><p>TIDYING -&gt; TERMINATED：terminated()执行完后就会自动转换</p>
<h4 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h4><p>可以通过shutdown会哦shutdownNow方法来关闭线程池。原理是遍历线程中的工作线程，然后逐个调用interrupt方法中断线程，所以无法响应中断的任务可能永远无法终止。</p>
<h4 id="线程池的核心线程数、最大线程数该如何设置"><a href="#线程池的核心线程数、最大线程数该如何设置" class="headerlink" title="线程池的核心线程数、最大线程数该如何设置"></a>线程池的核心线程数、最大线程数该如何设置</h4><p>我们都知道，线程池中有两个非常重要的参数：</p>
</li>
<li><p>corePoolSize：核心线程数，表示线程池中的常驻线程的个数</p>
</li>
<li><p>maximumPoolSize：最大线程数，表示线程池中能开辟的最大线程个数</p>
<p>那这两个参数该如何设置呢？</p>
<p>我们对线程池负责执行的任务分为三种情况：</p>
</li>
<li><p>CPU密集型任务，比如找出1-1000000中的素数</p>
</li>
<li><p>IO密集型任务，比如文件IO、网络IO</p>
</li>
<li><p>混合型任务</p>
<p>CPU密集型任务的特点时，线程在执行任务时会一直利用CPU，所以对于这种情况，就尽可能避免发生线程上下文切换。</p>
<p>比如，现在我的电脑只有一个CPU，如果有两个线程在同时执行找素数的任务，那么这个CPU就需要额外的进行线程上下文切换，从而达到线程并行的效果，此时执行这两个任务的总时间为：</p>
<p>任务执行时间*2+线程上下文切换的时间</p>
<p>而如果只有一个线程，这个线程来执行两个任务，那么时间为：</p>
<p>任务执行时间*2</p>
<p>所以对于CPU密集型任务，线程数最好就等于CPU核心数，可以通过以下API拿到你电脑的核心数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   <strong>通常，如果IO型任务执行的时间越长，那么同时阻塞在IO上的线程就可能越多，我们就可以设置更多的线程，但是，线程肯定不是越多越好</strong>，我们可以通过以下这个公式来进行计算：</p>
<p>   线程数 = CPU核心数   *（ 1 + 线程等待时间 / 线程运行总时间 ）</p>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos简介</title>
    <url>/2021/04/07/Nacos%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="Nacos-是什么"><a href="#Nacos-是什么" class="headerlink" title="Nacos 是什么"></a>Nacos 是什么</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p>
</blockquote>
<p>简单来说 nacos 是一个微服务，是一个用于为其他服务提供注册和发现功能的服务</p>
<p>Nacos 的关键特性包括:</p>
<ul>
<li>服务发现和服务健康监测</li>
<li>动态配置服务</li>
<li>动态 DNS 服务</li>
<li>服务及其元数据管理</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="https://raw.githubusercontent.com/he-You/image/master/1561217892717-1418fb9b-7faa-4324-87b9-f1740329f564.jpeg"></p>
<blockquote>
<h3 id="服务-Service"><a href="#服务-Service" class="headerlink" title="服务 (Service)"></a>服务 (Service)</h3><p>服务是指一个或一组软件功能（例如特定信息的检索或一组操作的执行），其目的是不同的客户端可以为不同的目的重用（例如通过跨进程的网络调用）。Nacos 支持主流的服务生态，如 Kubernetes Service、gRPC|Dubbo RPC Service 或者 Spring Cloud RESTful Service.</p>
<h3 id="服务注册中心-Service-Registry"><a href="#服务注册中心-Service-Registry" class="headerlink" title="服务注册中心 (Service Registry)"></a>服务注册中心 (Service Registry)</h3><p>服务注册中心，它是服务，其实例及元数据的数据库。服务实例在启动时注册到服务注册表，并在关闭时注销。服务和路由器的客户端查询服务注册表以查找服务的可用实例。服务注册中心可能会调用服务实例的健康检查 API 来验证它是否能够处理请求。</p>
<h3 id="服务元数据-Service-Metadata"><a href="#服务元数据-Service-Metadata" class="headerlink" title="服务元数据 (Service Metadata)"></a>服务元数据 (Service Metadata)</h3><p>服务元数据是指包括服务端点(endpoints)、服务标签、服务版本号、服务实例权重、路由规则、安全策略等描述服务的数据</p>
<h3 id="服务提供方-Service-Provider"><a href="#服务提供方-Service-Provider" class="headerlink" title="服务提供方 (Service Provider)"></a>服务提供方 (Service Provider)</h3><p>是指提供可复用和可调用服务的应用方</p>
<h3 id="服务消费方-Service-Consumer"><a href="#服务消费方-Service-Consumer" class="headerlink" title="服务消费方 (Service Consumer)"></a>服务消费方 (Service Consumer)</h3><p>是指会发起对某个服务调用的应用方</p>
<h3 id="配置-Configuration"><a href="#配置-Configuration" class="headerlink" title="配置 (Configuration)"></a>配置 (Configuration)</h3><p>在系统开发过程中通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如 WAR，JAR 包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成这个步骤。配置变更是调整系统运行时的行为的有效手段之一。</p>
<h3 id="配置管理-Configuration-Management"><a href="#配置管理-Configuration-Management" class="headerlink" title="配置管理 (Configuration Management)"></a>配置管理 (Configuration Management)</h3><p>在数据中心中，系统中所有配置的编辑、存储、分发、变更管理、历史版本管理、变更审计等所有与配置相关的活动统称为配置管理。</p>
<h3 id="名字服务-Naming-Service"><a href="#名字服务-Naming-Service" class="headerlink" title="名字服务 (Naming Service)"></a>名字服务 (Naming Service)</h3><p>提供分布式系统中所有对象(Object)、实体(Entity)的“名字”到关联的元数据之间的映射管理服务，例如 ServiceName -&gt; Endpoints Info, Distributed Lock Name -&gt; Lock Owner/Status Info, DNS Domain Name -&gt; IP List, 服务发现和 DNS 就是名字服务的2大场景。</p>
<h3 id="配置服务-Configuration-Service"><a href="#配置服务-Configuration-Service" class="headerlink" title="配置服务 (Configuration Service)"></a>配置服务 (Configuration Service)</h3><p>在服务或者应用运行过程中，提供动态配置或者元数据以及配置管理的服务提供者</p>
</blockquote>
<h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>Nacos 客户端通过发送 REST 请求向 Nacos服务端注册自己的服务，并将自己的服务相关的元数据（ip、端口等）存储在 map 中</p>
<h2 id="服务心跳"><a href="#服务心跳" class="headerlink" title="服务心跳"></a>服务心跳</h2><p>在服务注册之后，Nacos 客户端会维护一个定时心跳来持续通知 Nacos 服务端，以此证明自己的存活状态，防止被服务端剔除。默认每隔 5 秒发送一次心跳。</p>
<h2 id="服务同步"><a href="#服务同步" class="headerlink" title="服务同步"></a>服务同步</h2><p>在 Nacos 集群环境中，集群之间的节点会相互同步服务实例，保证服务信息在各个节点中的信息是一致的。</p>
<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>消费者服务在调用服务的时，会发送一个 REST 请求到 Nacos 服务端，并获取服务端内部的注册服务清单，缓存在 Nacos 客户端本地，并且之后会在本地定时拉去更新服务端上服务注册表信息。</p>
<h2 id="服务健康检查"><a href="#服务健康检查" class="headerlink" title="服务健康检查"></a>服务健康检查</h2><p>Nacos Server会开启一个定时任务用来检查注册服务实例的健康情况，对于超过 15s没有收到客户端心跳的实例会将它的healthy属性置为false(客户端服务发现时不会发现)，如果某个实例超过30秒没有收到心跳，直接剔除该实例(被剔除的实例如果恢复发送心跳则会重新 注册)</p>
<p>其中注册表的结构如下：</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230905215446183.png" alt="image-20230905215446183"></p>
]]></content>
      <categories>
        <category>SpringCloud alibaba</category>
      </categories>
      <tags>
        <tag>注册中心</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程（十一）阻塞队列</title>
    <url>/2021/02/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="阻塞队列的定义"><a href="#阻塞队列的定义" class="headerlink" title="阻塞队列的定义"></a>阻塞队列的定义</h1><p><strong>阻塞队列（BlockingQueue）</strong>是一种支持两个附加（<code>阻塞的插入和移除</code>）操作的队列。阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程，直到队列空间不满。阻塞的移除方法：当队列为空时，获取元素的线程会队列变为非空。</p>
<p>根据队列中容量来分，阻塞队列可以分为两类：有界队列和无界队列。</p>
<h1 id="常见的阻塞队列"><a href="#常见的阻塞队列" class="headerlink" title="常见的阻塞队列"></a>常见的阻塞队列</h1><p>JDK7提供了 7 种阻塞队列：</p>
<ul>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue:一个使用优先队列实现的无界阻塞队列。</li>
<li>SynchronousQueue:一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue:一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque:一个由链表结构组成的双向阻塞队列。</li>
</ul>
<ol>
<li><strong>ArrayBlockingQueue</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">     <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">     lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">     notEmpty = lock.newCondition();</span><br><span class="line">     notFull =  lock.newCondition();</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<p>​        默认情况使用 ReentrantLock提供的非公平独占锁进行出入队操作，不保证线程的公平性。</p>
<ol start="2">
<li><p><strong>LinkedBlockingQueue</strong></p>
<p>此队列的默认和最大长度为 Integer.MAX_VALUE。</p>
</li>
<li><p><strong>PriorityBlockingQueue</strong></p>
<p>支持优先级的无界阻塞队列，默认采取自然顺序升序排列，也可以通过自定义类实现 compareTo()方法来指定元素排序规则，或者在初始化该队列时，指定构造参数 Comparator 来对元素进行排序。但是不能保证同优先级元素的顺序。</p>
</li>
<li><p><strong>DelayQueue</strong></p>
<p>DelayQueue是支持延时获取元素的无界阻塞队列，是通过 PriorityQueue 实现的。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素，即满足延迟的时长才能从队列中获取元素。</p>
<p>主要的应用场景是：</p>
</li>
</ol>
<ul>
<li>缓存系统设计：可以将 DelayQueue 用来缓存元素的有效期，使用一个线程轮询 DelayQueue,一旦获取到元素表示缓存的有效期到了。</li>
<li>定时任务调度：DelayQueue 用来保存当天执行的任务和执行时间，一旦从 DelayQueue 中获取到元素就开始执行任务</li>
</ul>
<ol start="5">
<li><p><strong>SynchronousQueue</strong></p>
<p>该阻塞队列是一个不存储元素的队列。每一个 put 操作必须等到一个 take 操作，否则不能继续添加元素，该队列是一个支持公平访问的队列，但是默认情况下是采用非公平方式的。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> SynchronousQueue&#125; with the specified fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair if true, waiting threads contend in FIFO order for</span></span><br><span class="line"><span class="comment"> *        如果为true，则等待线程按照FIFO顺序进行竞争访问;</span></span><br><span class="line"><span class="comment"> *        access; otherwise the order is unspecified.</span></span><br><span class="line"><span class="comment"> *                否则顺序是未指定的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> TransferQueue&lt;E&gt;() : <span class="keyword">new</span> TransferStack&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        SynchronousQueue不存储元素更多的是用来传递元素，负载将生产者线程处理的数据之间传递给消费者线        程。而且SynchronousQueue的吞吐量要高于 LinkedBlockingQueue 和 ArrayBlockingQueue。</p>
<ol start="6">
<li><p><strong>LinkedTransferQueue</strong></p>
<p>该队列是由链表组成的无界 TransferQueue队列。相对于其他的阻塞队列多了 tryTransfer()和 transfer().</p>
<ul>
<li><p>transfer方法</p>
<p>如果当前消费者正在等待消费元素（消费者使用 take()方法或者带时间限制的 poll()方法时），transfer方法可以将生产者传入的元素立即 transfer 给消费者。如果没有消费者等待接收元素，那么该方法会将元素存放到队列的 tail 节点，并等到被消费者消费才返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node pred = tryAppend(s, haveData);(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">continue</span> retry;           <span class="comment">// lost race vs opposite mode</span></span><br><span class="line"><span class="keyword">if</span> (how != ASYNC)</span><br><span class="line">    <span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>代码(1)是试图将当前元素节点 s作为链表的 tail 节点。</p>
<p>代码(2)是让 CPU 自旋等待消费者消费元素。并且设置了自旋时长，超时后使用 Thread.yield()方暂停当前执行的线程，并执行其他线程。</p>
</li>
<li><p>tryTransfer 方法</p>
<p>该方法时用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回 false。该方法与 transfer 方法的区别是该方法无论消费者是否接收，方法都会立即返回，而如果是使用了tryTransfer(E e,long timeout, TimeUnit unit)方法，那么则会等待指定的时间后返回，如果超时没有消费元素则返回 false,如果在超时时间之内消费了元素则返回 true。</p>
</li>
</ul>
</li>
<li><p><strong>LinkedBlockingDeque</strong></p>
<p>该阻塞队列是由链表结构组成的双向阻塞队列。相比于其他阻塞队列，该队列多了 addFirst、addLast、offerFirst、offerLast、peekFirst和 peekLast 等方法，其中与 First 相关的方法表示获取、插入或者移除队列的第一个元素，与 Last 相关的方法表示获取、插入或者移除队列最后一个元素。</p>
</li>
</ol>
<h1 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h1><p>消费者是如何感知队列是否存在元素？</p>
<h2 id="使用通知模式实现"><a href="#使用通知模式实现" class="headerlink" title="使用通知模式实现"></a>使用通知模式实现</h2><p>所谓的通知模式，就是当生产者向满的队列里添加元素是会阻塞住生产者，当消费者消费完所有的队列元素时，会通知生产者当前队列可以。在 ArrayBlockingQueue 中，是通过 AQS 中的 Condition 队列实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">     <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">     lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">     notEmpty = lock.newCondition();</span><br><span class="line">     notFull =  lock.newCondition();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Inserts the specified element at the tail of this queue, waiting</span></span><br><span class="line"><span class="comment">  * for space to become available if the queue is full.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     checkNotNull(e);</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     lock.lockInterruptibly();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (count == items.length)</span><br><span class="line">             notFull.await();</span><br><span class="line">         enqueue(e);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     lock.lockInterruptibly();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">             notEmpty.await();</span><br><span class="line">         <span class="keyword">return</span> dequeue();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Inserts element at current put position, advances, and signals.</span></span><br><span class="line"><span class="comment">  * Call only when holding lock.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">     <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">     items[putIndex] = x;</span><br><span class="line">     <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">         putIndex = <span class="number">0</span>;</span><br><span class="line">     count++;</span><br><span class="line">     notEmpty.signal();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Extracts element at current take position, advances, and signals.</span></span><br><span class="line"><span class="comment">  * Call only when holding lock.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">     <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">     <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">     E x = (E) items[takeIndex];</span><br><span class="line">     items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">         takeIndex = <span class="number">0</span>;</span><br><span class="line">     count--;</span><br><span class="line">     <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">         itrs.elementDequeued();</span><br><span class="line">     notFull.signal();</span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码是与 ArrayBlockingQueue出入队相关方法。</p>
<p>当向队列中插入元素时，如果队列不可用，则使用 LockSupport.park(this)来实现阻塞。而 park 的方法是调用本地方法的 unsafe.park()。该方法会阻塞当前线程，只有以下 4 种情况发生时，该方法才会返回：</p>
<ul>
<li>与 park 相对应的 unpark 执行或者已经执行(指的是 unpark 先执行，然后执行 park 的情况)时。</li>
<li>线程被中断</li>
<li>等待完 time 参数指定的（毫秒数）时长</li>
<li>发生异常</li>
</ul>
<p>由于 unsafe 依赖本地方法，在不同的操作系统中实现方式也不同。</p>
<p>park 方法在 Linux 中是通过系统方法 <strong>pthread_cond_wait</strong> 实现的，该方法是多线程的条件变量函数。</p>
<p>unpark 方法在 Linux 中是通过 <strong>pthread_cond_singal</strong> 实现的。</p>
<p>当线程被阻塞队列阻塞时，线程会进入 WATING （parking）状态。</p>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引为什么使用B+树而不是跳表</title>
    <url>/2023/09/04/MySQL%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B+%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AF%E8%B7%B3%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="MySQL索引为什么使用B-树而不是跳表"><a href="#MySQL索引为什么使用B-树而不是跳表" class="headerlink" title="MySQL索引为什么使用B+树而不是跳表"></a>MySQL索引为什么使用B+树而不是跳表</h1><h2 id="B-树的数据结构"><a href="#B-树的数据结构" class="headerlink" title="B+树的数据结构"></a>B+树的数据结构</h2><p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230904114833961.png" alt="image-20230904114833961"></p>
<p>上图就是B+树的数据结构的示例</p>
<p>一般B+树是由多个页组成的多层级结构，每个页16Kb，对于主键索引来说，最末级的叶子结点放行数据，非叶子结点放的则是索引信息(主键id和页号)，用于加速查询。</p>
<p>如果想要查找行数据5。会先从顶层页的record入手。record里包含了主键id和页号(页地址)。关注黄色的箭头，向左最小id是1，向右最小id是7。那id=5的数据如果存在，那必定在左边箭头。于是顺着的record的页地址就到了6号数据页里，再判断id=5&gt;4，所以肯定在右边的数据页里，于是加载45号数据页。</p>
<p>在45号数据页里，虽然有多行数据，但也不是挨个遍历的，数据页内还有个页目录的信息，它可以通过二分查找的方式加速查询行数据，于是找到id=5的数据行，完成查询。</p>
<p>从上面可以看出，<strong>B+树利用了空间换时间的方式</strong>(构造了一批非叶子结点用于存放索引信息)，将查询时间复杂度从O(n)优化为O(lg(n))。</p>
<h2 id="跳表的数据结构"><a href="#跳表的数据结构" class="headerlink" title="跳表的数据结构"></a>跳表的数据结构</h2><p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230904133239045.png" alt="image-20230904133239045"></p>
<p>上图为跳表的数据结构示意图</p>
<p>最底下一层（1~8）即跳表的原始数据链表，其中的元素是需要<code>有序</code>的，众所周知，单链表的时间复杂度是O(n)，为了方便查询，于是将链表中的部分节点提取出来，在构建出一个新的（有序的）链表，如第二次1-3-5-8，这样原始链表就相当于缩小一半了，比如查询id=4的数据，只需要遍历1-&gt;3-&gt;4</p>
<p>可以看出，跳表也是通过牺牲空间换取时间的方式提升查询性能。<strong>时间复杂度都是lg(n)。</strong></p>
<h2 id="B-树和跳表的区别"><a href="#B-树和跳表的区别" class="headerlink" title="B+树和跳表的区别"></a>B+树和跳表的区别</h2><p>从上面可以看到，B+树和跳表的最下面一层，都包含了所有的数据，且都是顺序的，适合用于范围查询。往上的层级都是构建出来用于提升搜索性能的。这两者实在是太像了。但他们两者在新增和删除数据时，还是有些区别的。</p>
<h3 id="B-树新增数据"><a href="#B-树新增数据" class="headerlink" title="B+树新增数据"></a>B+树新增数据</h3><p><strong>B+树本质上是一种多叉平衡树</strong>。关键在于”平衡”这两个字，对于多叉树结构来说，它的含义是子树们的高度层级尽量一致(一般最多差一个层级)，这样在搜索的时候，不管是到哪个子树分支，搜索次数都差不了太多。</p>
<p>当数据库表不断插入新的数据时，为了维持B+树的平衡，B+树会不断分裂调整数据页。(<strong>为了避免数据页分裂带来的效率下降，MySQL推荐使用自增主键</strong>)</p>
<p>我们知道B+树分为叶子结点和非叶子结点。</p>
<p>当插入一条数据时，叶子结点和它上层的索引结点(非叶子结点)最大容量都是16k，它们都有可能会满。</p>
<p>为了简化问题，我们假设一个数据页只能放三条行数据或索引。</p>
<p>加入一条数据，根据数据页会不会满，分为三种情况。</p>
<ol>
<li><p>叶子节点和非叶子节点都未满，这种情况直接将新的数据插入到叶子节点中就行，如下图：插入数据6</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230904144205675.png" alt="image-20230904144205675"></p>
</li>
<li><p>叶子节点满了，但是索引节点未满，这种情况就需要拆分叶子节点，同时索引节点要增加新的索引信息。</p>
</li>
</ol>
<img src="https://raw.githubusercontent.com/he-You/image/master/image-20230904145639018.png" alt="image-20230904145639018" style="zoom:110%;" />



<ol start="3">
<li><p>叶子节点和索引节点都满了，此时叶子节点和索引节点都需要拆分，同时需要往上再加一层索引节点</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230904151201400.png" alt="image-20230904151201400"></p>
</li>
</ol>
<p>要把三层B+树塞满，那大概需要2kw左右的数据。</p>
<p><strong>B+树的存储总记录数 = <code>根节点指针数 * 单个叶子节点记录条数</code>**（已知一页数据为16kb, 假设一行数据的大小是1k,那么一页可以存放16行数据，而非叶子节点存放的是主键值和指针，假设主键类型为bigint,占8bite,指针占6byte,则非叶子节点的大小约为14byte，这样可以计算出节点大概可以存放16kb/14byte = 1170）</strong>2层B+树的话，可以存放1170*16=18720行数据。3层B+树的话，可以存放1170*1170*16=21902400行数据**，也就差不多2000w条数据了。</p>
<h2 id="跳表新增数据"><a href="#跳表新增数据" class="headerlink" title="跳表新增数据"></a>跳表新增数据</h2><p>跳表同样也是很多层，新增一个数据时，最底层的链表需要插入数据。</p>
<p>此时，是否需要在上面的几层中加入数据做索引呢?</p>
<p>这个就纯靠随机函数了。</p>
<p>理论上为了达到二分的效果，每一层的结点数需要是下一层结点数的二分之一。</p>
<p>也就是说现在有一个新的数据插入了，它有50%的概率需要在第二层加入索引，有25%的概率需要在第三层加个索引，以此类推，直到最顶层。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230904152623987.png" alt="image-20230904152623987"></p>
<p>如果这个随机函数设计成上面这样，当数据量样本足够大的时候，数据的分布就符合我们理想中的”二分”。</p>
<p>跟上面B+树不一样，跳表是否新增层数，纯粹靠随机函数，根本不关心前后上下结点。</p>
<h2 id="两种数据结构的区别"><a href="#两种数据结构的区别" class="headerlink" title="两种数据结构的区别"></a>两种数据结构的区别</h2><p>从上述两种数据结构中我们可以知道，两种数据结构的查询时间复杂度是一样的，都是O(logn)。但是在维护数据结构时，采取的方案是截然不同的。</p>
<p><strong>B+树是多叉树结构，每个结点都是一个16k的数据页，能存放较多索引信息，所以扇出很高</strong>。三层左右就可以存储2kw左右的数据。也就是说查询一次数据，如果这些数据页都在磁盘里，那么<strong>最多需要查询三次磁盘IO</strong>。</p>
<p>跳表是链表结构，一条数据一个结点，如果最底层要存放2kw数据，且每次查询都要能达到二分查找的效果，2kw大概在2的24次方左右，所以，跳表大概高度在24层左右。最坏情况下，这24层数据会分散在不同的数据页里，也即是查一次数据会经历24次磁盘IO。</p>
<p>因此：</p>
<ul>
<li><p>查询操作：B+树存储相同量级的数据时，需要维护的层树要小于跳表，而MySQL是需要和磁盘进行IO交互的，B+树的层高越低，则IO的次数越少，整个查询过程中IO的耗时更少。</p>
</li>
<li><p>写操作，B+树需要拆分合并索引数据页，跳表则独立插入，并根据随机函数确定层数，没有旋转和维持平衡的开销，因此跳表的写入性能会比B+树要好。</p>
</li>
</ul>
<h3 id="那redis为什么使用跳表而不使用B-树或二叉树呢"><a href="#那redis为什么使用跳表而不使用B-树或二叉树呢" class="headerlink" title="那redis为什么使用跳表而不使用B+树或二叉树呢?"></a>那redis为什么使用跳表而不使用B+树或二叉树呢?</h3><p>众所周知Redis是内存数据库，不需要和磁盘进行IO，所以制约查询效率的层高不再是Redis的性能瓶颈，而此时B+树又存在数据插入过程中可能存在的分页和平衡操作反而会带来性能的劣势。因此对于追求高效的Redis来说，跳表是更优的选择。</p>
<p>每种数据结构都有自己的优势和使用场景，或者说都是为了解决某些场景的痛点设计出来。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 索引数据结构与相关问题</title>
    <url>/2021/03/20/MySQL%20%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="索引的定义"><a href="#索引的定义" class="headerlink" title="索引的定义"></a>索引的定义</h1><ul>
<li>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</li>
<li>索引是一种数据结构。数据库索引，是数据库管理系统中一个<code>排好序</code>的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</li>
<li>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</li>
</ul>
<h1 id="如何创建索引"><a href="#如何创建索引" class="headerlink" title="如何创建索引"></a>如何创建索引</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.添加PRIMARY KEY（主键索引）</span><br><span class="line"></span><br><span class="line">ALTER TABLE &#96;table_name&#96; ADD PRIMARY KEY ( &#96;column&#96; ) </span><br><span class="line">2.添加UNIQUE(唯一索引)</span><br><span class="line"></span><br><span class="line">ALTER TABLE &#96;table_name&#96; ADD UNIQUE ( &#96;column&#96; ) </span><br><span class="line">3.添加INDEX(普通索引)</span><br><span class="line"></span><br><span class="line">ALTER TABLE &#96;table_name&#96; ADD INDEX index_name ( &#96;column&#96; )</span><br><span class="line">4.添加FULLTEXT(全文索引)</span><br><span class="line"></span><br><span class="line">ALTER TABLE &#96;table_name&#96; ADD FULLTEXT ( &#96;column&#96;) </span><br><span class="line">5.添加联合索引</span><br><span class="line"></span><br><span class="line">ALTER TABLE &#96;table_name&#96; ADD INDEX index_name ( &#96;column1&#96;, &#96;column2&#96;, &#96;column3&#96; )</span><br></pre></td></tr></table></figure>

<h1 id="索引的种类"><a href="#索引的种类" class="headerlink" title="索引的种类"></a>索引的种类</h1><ul>
<li>主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</li>
<li>唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索引</li>
<li>普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);创建组合索引。</li>
<li>全文索引： 是目前搜索引擎使用的一种关键技术。可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引</li>
</ul>
<p>注：当创建表结构时没有指定主键，MySQL 会优先选择数据不重复的列作为索引，如果不存在这样的列，则会创建虚拟的列，用于创建索引结构类似 row_id。</p>
<h1 id="索引的基本原理与底层数据结构"><a href="#索引的基本原理与底层数据结构" class="headerlink" title="索引的基本原理与底层数据结构"></a>索引的基本原理与底层数据结构</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。<br>索引的原理很简单，就是把无序的数据变成有序的查询把创建了索引的列的内容进行排序对排序结果生成倒排表在倒排表内容上拼上数据地址链在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</p>
<h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><p>既然索引是为了提高查询效率,而和搜索查询相关的数据结构有:</p>
<ul>
<li>B-Tree</li>
<li>B+-Tree</li>
<li>Hash结构</li>
<li>二叉查找树</li>
</ul>
<p>索引的数据结构和具体<strong>存储引擎</strong>的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>
<ul>
<li><strong>B-Tree索引</strong></li>
</ul>
<p>mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/008eGmZEly1goqrbmv5shj31ca0na75d.jpg" alt="img"></p>
<ul>
<li><strong>B+Tree性质</strong></li>
</ul>
<p>n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。<br>所有的叶子结点中包含了全部关键字的信息，即指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。<br>所有的非终端结点可以看成是索引部分，结点中仅含其子数中的最大（或最小）关键字。<br>B+ 树中，数据对象的插入和删除仅在叶节点上进行。<br>B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230904114833961.png" alt="image-20230904114833961"></p>
<p><strong>为什么 MySQL采用 B+Tree 索引，而不是使用二叉查找树结构？</strong></p>
<ol>
<li><p>B+Tree 树的高度更低：普通的二叉查找树，一个节点最多有两个子节点，当存储大量数据时，树的高度就会很高，从而也会影响查询的效率。而 B+树，非叶子节点存储索引，叶子节点存储索引及其数据，这样一层叶子节点可以存储大量数据。</p>
</li>
<li><p>B+树的磁盘读写代价更低:B+树内部(非叶子节点)并没有指向关键信息的指针,只存放索引信息,不存放数据;因此内部节点相对B树更小如果将所有内部节点的索引信息存入同一盘块中,这个盘块能容纳更多的关键字,<br>一次性读入内存要查找的关键字也就越多,相对来说IO读写次数也就越少。</p>
</li>
<li><p>B+树的查询效率更加稳定。由于内部节点并不是最终指向文件内容的节点,而只是指向叶子节点的索引,所以任何查找都必须走一条从根节点到叶子节点的路,所有关键字查询的长度相同,也就是说每个数据的查询效率基本一致(O(logn))</p>
</li>
</ol>
<ul>
<li><p><strong>哈希索引</strong></p>
<p>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</p>
</li>
</ul>
<p><strong>为什么 MySQL采用 B+Tree 索引，而不是使用B树结构？</strong></p>
<ol>
<li>B-树单次查询比较占优势，B+树范围查询比较占优势</li>
<li>B树在提高了IO性能的同时并没有解决元素遍历效率低下的问题，正是为了解决这个问题，B+树应用而生。</li>
<li>B+树只需要去遍历叶子节点就可以实现整棵树的遍历</li>
</ol>
<p>而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。</p>
<p><strong>为什么不使用Hash结构作为数据库索引的数据结构?</strong></p>
<p>Hash算法存在Hash碰撞,即不同的Key通过Hash算法得到的Hash值可能是一样的,即多个Key指向同一个Bucket,而Bucket中又是以链表的方式进行存储Key指向的数据所以:</p>
<ul>
<li>Hash索引比较的是进行Hash运算后的值也无法保证值的大小与Hash运算之前完全一样 ,仅仅能满足”=”与”in”,不能进行范围查询</li>
<li>无法用来进行数据的排序操作 </li>
<li>不能进行部分索引进行查询,因为对于组合索引,Hash运算在是对组合索引合并之后进行的,<br>而不是单独计算Hash值的,索引无法使用组合索引进行数据的查询 </li>
<li>不能避免进行表扫描,因为Hash索引最终查询的还是Bucket中的entry,无法直接通过Hash值查询到数据</li>
<li>遇到大量Hash值相等的情况性能不一定比B+Tree高</li>
</ul>
<p><a href="https://he-you.github.io/2023/09/04/MySQL%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B+%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AF%E8%B7%B3%E8%A1%A8/">为什么MySQL索引结构用B+树，而不用跳表</a></p>
<h2 id="两种存储引擎索引对比"><a href="#两种存储引擎索引对比" class="headerlink" title="两种存储引擎索引对比"></a>两种存储引擎索引对比</h2><ul>
<li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li>
<li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li>
<li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li>
<li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li>
</ul>
<h2 id="聚集索引与稀疏索引"><a href="#聚集索引与稀疏索引" class="headerlink" title="聚集索引与稀疏索引"></a>聚集索引与稀疏索引</h2><p>所谓聚集索引又称为聚簇索引，是指索引文件和数据文件是在一起的</p>
<p>所谓稀疏索引又称之为非聚簇索引，索引文件和数据文件是分离的</p>
<h2 id="使用自增主键索引的优势"><a href="#使用自增主键索引的优势" class="headerlink" title="使用自增主键索引的优势"></a>使用自增主键索引的优势</h2><p>用自增主键维护索引结构，可以避免 mysql 在维护索引结构时，叶子节点分裂，冗余节点进行平衡。而且对于 InnoDB 来说，聚簇索引也是主键索引。其他索引在查询是会进行回表操作，所谓回表即：二级索引查询到叶子节点中的主键位置，然后通过主键再次查询主键索引找到对应的数据。</p>
<h2 id="联合索引与MySQL-最左前缀原则"><a href="#联合索引与MySQL-最左前缀原则" class="headerlink" title="联合索引与MySQL 最左前缀原则"></a>联合索引与MySQL 最左前缀原则</h2><h3 id="如何创建联合索引"><a href="#如何创建联合索引" class="headerlink" title="如何创建联合索引"></a>如何创建联合索引</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#96;table_name&#96; ADD INDEX index_name ( &#96;columnA&#96;, &#96;columnB&#96;, &#96;columnC&#96; )</span><br></pre></td></tr></table></figure>

<p>当创建联合索引时，按照 A，B，C 的顺序维护索引结构的，按照表级维度来说只有 A 是排好顺序的，而 BC 字段只是在某个叶子节点是有序的，所以，对于联合索引来说，只有查询条件包含 columnA 这列时，联合索引才生效。这个规则或者说优先级即为最左前缀原则。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>OAuth2.0</title>
    <url>/2021/10/30/OAuth2.0%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>一、OAuth</p>
<blockquote>
<p>OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。……资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。</p>
</blockquote>
<p>也就是说OAuth的核心作用就是向第三方应用颁发令牌</p>
<p>二、OAuh2.0获得令牌的4种方式</p>
<ul>
<li>授权码（authorization-code）</li>
<li>隐藏式（implicit）</li>
<li>密码式（password）</li>
<li>客户端凭证（client credentials）</li>
</ul>
<p>注：不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。</p>
<p><strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌</strong></p>
<p>该方式最常用，安全性最高，多使用在前后端分离的web应用，所有与资源服务器的通信都是在后端完成的，可以避免令牌泄漏</p>
<p><strong>具体的流程</strong>：</p>
<p>1.客户端A提供链接，由用户点击跳转到资源服务器端B，完成授权。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230809232308055.png" alt="image-20230809232308055"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;b.com&#x2F;oauth&#x2F;authorize?</span><br><span class="line">  response_type&#x3D;code&amp;</span><br><span class="line">  client_id&#x3D;CLIENT_ID&amp;</span><br><span class="line">  redirect_uri&#x3D;CALLBACK_URL&amp;</span><br><span class="line">  scope&#x3D;read</span><br></pre></td></tr></table></figure>

<p>在上面的实例URL中:</p>
<p><code>response_type</code>参数表示要求返回授权码（<code>code</code>），</p>
<p><code>client_id</code>参数让 B 知道是谁在请求，</p>
<p><code>redirect_uri</code>参数是 B 接受或拒绝请求后的跳转网址，</p>
<p><code>scope</code>参数表示要求的授权范围（这里是只读）</p>
<p>2.在用户跳转之后，资源服务器B会要求用户进行登录，然后询问用户是否给予客户端A授权。当用户同意后，B回跳转到<code>redirect_uri</code>参数指定的网址。跳转时会回传一个授权码</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230809232335656.png" alt="image-20230809232335656"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;a.com&#x2F;callback?code&#x3D;AUTHORIZATION_CODE</span><br></pre></td></tr></table></figure>

<p>上述的链接中的code参数就是授权码。</p>
<p>3.当客户端服务A拿到授权码后，就可以向资源网站B请求令牌了。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230809232422583.png" alt="image-20230809232422583"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;b.com&#x2F;oauth&#x2F;token?</span><br><span class="line"> client_id&#x3D;CLIENT_ID&amp;</span><br><span class="line"> client_secret&#x3D;CLIENT_SECRET&amp;</span><br><span class="line"> grant_type&#x3D;authorization_code&amp;</span><br><span class="line"> code&#x3D;AUTHORIZATION_CODE&amp;</span><br><span class="line"> redirect_uri&#x3D;CALLBACK_URL</span><br></pre></td></tr></table></figure>

<p>上面 URL 中:</p>
<p><code>client_id</code>参数和<code>client_secret</code>参数用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求），<code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码，<code>code</code>参数是上一步拿到的授权码，<code>redirect_uri</code>参数是令牌颁发后的回调网址。</p>
<p>4.资源网站B收到请求后就会颁发令牌。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230809232622895.png" alt="image-20230809232622895"></p>
<p>具体是向<code>redirect_uri</code>指定的网址，发送一段JSON:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,</span><br><span class="line">  &quot;token_type&quot;:&quot;bearer&quot;,</span><br><span class="line">  &quot;expires_in&quot;:2592000,</span><br><span class="line">  &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,</span><br><span class="line">  &quot;scope&quot;:&quot;read&quot;,</span><br><span class="line">  &quot;uid&quot;:100101,</span><br><span class="line">  &quot;info&quot;:&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中JSON中的access_token字段就是令牌</p>
<p><strong>第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。</strong></p>
<p>该方式适用于没有后端服务的纯前端web服务</p>
<p>首先A网址需要提供一个连接，要求用户跳转到B网站，授权用户数据给A使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;b.com&#x2F;oauth&#x2F;authorize?</span><br><span class="line">  response_type&#x3D;token&amp;</span><br><span class="line">  client_id&#x3D;CLIENT_ID&amp;</span><br><span class="line">  redirect_uri&#x3D;CALLBACK_URL&amp;</span><br><span class="line">  scope&#x3D;read</span><br></pre></td></tr></table></figure>

<p>在上面的URL中：</p>
<p>response_type参数为token,表示要求直接返回令牌。</p>
<p>然后：用户跳转到B完整，登录后同意给A网站授权。此时，B网站就会跳回redirect_uri指定的网址，并且把令牌作为URL参数传给A网站</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;a.com&#x2F;callback#token&#x3D;ACCESS_TOKEN</span><br></pre></td></tr></table></figure>

<p>A网站的前端拿到令牌，即token参数。</p>
<p>注：令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p>
<p>不过这种方式还是很不安全，只能用于安全要求不高的场景，并且令牌的有效期要非常短，通常是存在当前会话中，当浏览器关闭后，令牌也就随之失效。</p>
<p>第三种方式：密码式</p>
<p><strong>所谓密码式，即允许用户把用户名和密码直接告诉应用，该应用直接使用密码申请令牌。</strong></p>
<p>第一步，A网站要求用户提供B网站的用户名密码。拿到之后，A就直接向B请求令牌。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;oauth.b.com&#x2F;token?</span><br><span class="line">  grant_type&#x3D;password&amp;</span><br><span class="line">  username&#x3D;USERNAME&amp;</span><br><span class="line">  password&#x3D;PASSWORD&amp;</span><br><span class="line">  client_id&#x3D;CLIENT_ID</span><br></pre></td></tr></table></figure>

<p>在上面的URL中，<code>grant_type</code>参数是授权方式，这里的<code>password</code>表示”密码式”，<code>username</code>和<code>password</code>是 B 的用户名和密码。</p>
<p>第二步，B网站验证身份，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</p>
<p>注：这种方式需要用户给出自己的用户名/密码，风险很大，只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。</p>
<p>第四种方式：凭证式</p>
<p>该方式适用于没有前端应用的命令行应用，即直接在命令行中请求令牌。</p>
<p>首先，A应用在每轮行向B发出请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;oauth.b.com&#x2F;token?</span><br><span class="line">  grant_type&#x3D;client_credentials&amp;</span><br><span class="line">  client_id&#x3D;CLIENT_ID&amp;</span><br><span class="line">  client_secret&#x3D;CLIENT_SECRET</span><br></pre></td></tr></table></figure>

<p>在上面的URL中，<code>grant_type</code>参数等于<code>client_credentials</code>表示采用凭证式，<code>client_id</code>和<code>client_secret</code>用来让 B 确认 A 的身份。</p>
<p>然后，B网站通过验证之后，就直接返回令牌。这种方式给出的令牌是针对第三方应用的，而不是针对用户的，即该方式可以实现对多个用户同时授权，也就是说存在多个用户共享令牌的情况。</p>
]]></content>
      <categories>
        <category>身份认证</category>
      </categories>
      <tags>
        <tag>OAuth2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL ON DUPLICATE KEY UPDATE的坑</title>
    <url>/2023/09/04/ON%20DUPLICATE%20KEY%20UPDATE%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h1 id="ON-DUPLICATE-KEY-UPDATE的坑"><a href="#ON-DUPLICATE-KEY-UPDATE的坑" class="headerlink" title="ON DUPLICATE KEY UPDATE的坑"></a>ON DUPLICATE KEY UPDATE的坑</h1><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>在接手的项目中发现一个问题，应该更新的数据并没有更新。后来发现代码中使用了使用了mysql的on duplicate key update语法实现了对数据的save or update。当时通过代码逻辑和这个保存更新的语句来看，逻辑上并没有明显的问题，但是日志确实报的这行语句有问题。</p>
<h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByIds&quot;</span>&gt;</span></span><br><span class="line">    update tb_user</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;set&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;name = case&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;end,&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;i&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">                when id= #&#123;i.id,jdbcType=VARCHAR&#125; then #&#123;i.name,jdbcType=VARCHAR&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;weight = case&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;end,&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;i&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">                when id= #&#123;i.id,jdbcType=VARCHAR&#125; then #&#123;i.weight,jdbcType=DECIMAL&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;high = case&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;end,&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;i&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">                when id= #&#123;i.id,jdbcType=VARCHAR&#125; then #&#123;i.high,jdbcType=DECIMAL&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    where id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        #&#123;item.id,jdbcType=VARCHAR&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码是模拟公司代码</p>
<h2 id="问题验证"><a href="#问题验证" class="headerlink" title="问题验证"></a>问题验证</h2><p>为了确定on duplicate key update是否存在问题，我查阅了MySQL的官方文档：<a href="https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html">https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html</a></p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230904104848284.png" alt="image-20230904104848284"></p>
<p>为了验证这个问题，在本地测试环境创建了一个表进行测试</p>
<p>执行1次的结果:</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
<p>执行2次的结果:</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>4</td>
</tr>
</tbody></table>
<p>执行3次的结果:</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>5</td>
</tr>
</tbody></table>
<p>执行4次的结果:</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>6</td>
</tr>
</tbody></table>
<p>执行5次的结果:</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>7</td>
</tr>
</tbody></table>
<p>通过观察可知，上面的 sql 在主键已经存在时相当于如下 sql。</p>
<blockquote>
<p>UPDATE t1 SET c=c+1 WHERE a=1;</p>
</blockquote>
<p>再试下新增的 sql。</p>
<blockquote>
<p>INSERT INTO t1 (b,c) VALUES (20,30)<br>ON DUPLICATE KEY UPDATE c=c+1;</p>
</blockquote>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>7</td>
</tr>
<tr>
<td>2</td>
<td>20</td>
<td>30</td>
</tr>
</tbody></table>
<p>新增记录成功，id 也自增正常。</p>
<p>在官方资料中有这样的一句话：</p>
<p>If column b is also unique, the INSERT is equivalent to this UPDATE statement instead:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE t1 SET c&#x3D;c+1 WHERE a&#x3D;1 OR b&#x3D;2 LIMIT 1;</span><br></pre></td></tr></table></figure>

<p>If a=1 OR b=2 matches several rows, only one row is updated. In general, you should try to avoid using an ON DUPLICATE KEY UPDATE clause on tables with multiple unique indexes.</p>
<p>接下来实验一下，给 t1 加的 b 也加上唯一索引:</p>
<blockquote>
<p>ALTER TABLE <code>t1</code> ADD UNIQUE INDEX <code>uniq_b</code> (<code>b</code> ASC);</p>
</blockquote>
<p>然后执行如下 sql:</p>
<blockquote>
<p>INSERT INTO t1 (a,b,c) VALUES (3,20,30)<br>ON DUPLICATE KEY UPDATE c=c+1;</p>
</blockquote>
<p>其 t1 表结果如下：</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>7</td>
</tr>
<tr>
<td>2</td>
<td>20</td>
<td>31</td>
</tr>
</tbody></table>
<p>从上面的结果可以看出，其只执行了 update 的操作，从而告诉了我们在使用 on duplicate key update 语句时，应当避免多个唯一索引的场景</p>
<p>当a是一个唯一索引(unique index)时,并且t1表中已经存在a为1的记录时，如下两个sql的效果是一样的。</p>
<blockquote>
<p>INSERT INTO t1 (a,b,c) VALUES (1,2,3)<br>ON DUPLICATE KEY UPDATE c=c+1;</p>
</blockquote>
<blockquote>
<p>UPDATE t1 SET c=c+1 WHERE a=1;</p>
</blockquote>
<blockquote>
<p>ALTER TABLE <code>t1</code> DROP INDEX <code>uniq_b</code> ;</p>
</blockquote>
<blockquote>
<p>ALTER TABLE <code>ntocc_test</code>.<code>t1</code><br>ADD UNIQUE INDEX <code>uniq_b</code> (<code>b</code> ASC);<br>;</p>
</blockquote>
<p>但在innoBD存储类型的表中，当a是一个自增主键时，其效果官方文档中的解释是这样的：</p>
<blockquote>
<p>The effects are not quite identical: For an InnoDB table where a is an auto-increment column, the INSERT statement increases the auto-increment value but the UPDATE does not.</p>
</blockquote>
<p>也就是如果只有一个主键，则会执行新增操作</p>
<p>但当b也是一个唯一索引时，就会执行更新操作<br>上面的语句就会变成这样的：</p>
<blockquote>
<p>UPDATE t1 SET c=c+1 WHERE a=1 OR b=2 LIMIT 1;</p>
</blockquote>
<p>If a=1 OR b=2 matches several rows, only one row is updated. In general, you should try to avoid using an ON DUPLICATE KEY UPDATE clause on tables with multiple unique indexes.</p>
<p>因此应当避免多唯一索引用on deplicate key update语法</p>
<p>后来发现产线数据库中的表除了主键索引还存在org_name的唯一索引。</p>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis高可用集群及相关问题</title>
    <url>/2021/03/16/Redis%20%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h1 id="Redis集群方案"><a href="#Redis集群方案" class="headerlink" title="Redis集群方案"></a>Redis集群方案</h1><h2 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h2><p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230906222419274.png" alt="image-20230906222419274"></p>
<p>主从模式是最简单的实现高可用的方案，核心就是主从同步。主从同步的原理如下：</p>
<ol>
<li>slave发送psync命令到master</li>
<li>master收到psync之后，执行bgsave，生成RDB全量文件</li>
<li>master把slave的写命令记录到缓存</li>
<li>bgsave执行完毕之后，发送RDB文件到slave，slave执行</li>
<li>master发送缓存中的写命令到slave，slave执行</li>
</ol>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>基于主从方案的缺点还是很明显的，假设master宕机，那么就不能写入数据，那么slave也就失去了作用，整个架构就不可用了，除非手动切换，主要原因就是因为没有自动故障转移机制。</p>
<p>而哨兵(sentinel)的功能比单纯的主从架构全面的多了，它具备自动故障转移、集群监控、消息通知等功能。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230906222926178.png" alt="image-20230906222926178"></p>
<p>哨兵可以同时监视多个主从服务器，并且在被监视的master下线时，自动将某个slave提升为master，然后由新的master继续接收命令。</p>
<ol>
<li>初始化sentinel，将普通的redis代码替换成sentinel专用代码</li>
<li>初始化masters字典和服务器信息，服务器信息主要保存ip:port，并记录实例的地址和ID</li>
<li>创建和master的两个连接，命令连接和订阅连接，并且订阅sentinel:hello频道</li>
<li>每隔10秒向master发送info命令，获取master和它下面所有slave的当前信息</li>
<li>当发现master有新的slave之后，sentinel和新的slave同样建立两个连接，同时每个10秒发送info命令，更新master信息</li>
<li>sentinel每隔1秒向所有服务器发送ping命令，如果某台服务器在配置的响应时间内连续返回无效回复，将会被标记为下线状态</li>
<li>选举出sentinel leader，哨兵leader需要半数以上的sentinel同意</li>
<li>哨兵 leader从已下线的的master所有slave中挑选一个，将其转换为master</li>
<li>让所有的slave改为从新的master复制数据</li>
<li>将原来的master设置为新的master的从服务器，当原来master重新回复连接时，就变成了新master的从服务器</li>
</ol>
<h2 id="高可用集群模式"><a href="#高可用集群模式" class="headerlink" title="高可用集群模式"></a>高可用集群模式</h2><p>redis集群是redis提供的分布式数据存储方案，集群通过数据分片sharding来进行数据的共享，同时提供复制和故障转移的功能。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230906223159811.png" alt="image-20230906223159811"></p>
<h1 id="Redis-高可用集群搭建"><a href="#Redis-高可用集群搭建" class="headerlink" title="Redis 高可用集群搭建"></a>Redis 高可用集群搭建</h1><ol>
<li>环境准备</li>
<li>conf 文件修改</li>
<li>命令注意事项</li>
<li>验证集群</li>
</ol>
<h1 id="Redis-集群原理"><a href="#Redis-集群原理" class="headerlink" title="Redis 集群原理"></a>Redis 集群原理</h1><h2 id="节点通信"><a href="#节点通信" class="headerlink" title="节点通信"></a>节点通信</h2><p>一个redis集群由多个节点node组成，而多个node之间通过cluster meet命令来进行连接，节点的握手过程：</p>
<ol>
<li>节点A收到客户端的cluster meet命令</li>
<li>A根据收到的IP地址和端口号，向B发送一条meet消息</li>
<li>节点B收到meet消息返回pong</li>
<li>A知道B收到了meet消息，返回一条ping消息，握手成功</li>
<li>最后，节点A将会通过gossip协议把节点B的信息传播给集群中的其他节点，其他节点也将和B进行握手</li>
</ol>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230906223743744.png" alt="image-20230906223743744"></p>
<p>维护集群的元数据（集群节点信息，主从关系等）有两种方式：集中式和 gossip。而 Redis Cluster 节点间采取的就是 gossip 协议进行通信。</p>
<h3 id="gossip协议"><a href="#gossip协议" class="headerlink" title="gossip协议"></a>gossip协议</h3><p>gossip 是 redis 集群节点之间采用的一种通信协议，主要包括ping，pong，meet，fail等消息。</p>
<ul>
<li><p>meet:某个节点发送meet给新加入的节点，<strong>让新节点加入集群中</strong>，然后新节点就会开始与其他节点进行通信;</p>
</li>
<li><p> ping:每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相<strong>通过 ping交换元数据</strong>(类似自己感知到的集群节点增加和移除，hash slot信息等);</p>
</li>
<li><p>pong: 对ping和meet消息的返回，包含自己的状态和其他信息，也可以用于信息广播和更新;</p>
</li>
<li><p>fail: <strong>某个节点判断另一个节点fail</strong>之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。</p>
</li>
</ul>
<p>gossip 协议的优点在于元数据的更新比较分散，不是集中在一个地方，请求会陆续更新到所有节点上，这样虽然有延时，但是降低了请求压力。</p>
<p><strong>gossip通信的10000端口</strong> </p>
<p>每个节点都有一个专门用于节点间gossip通信的端口，就是自己提供服务的端口号+10000，比如7001，那么 用于节点间通信的就是17001端口。 每个节点每隔一段时间都会往另外几个节点发送ping消息，同时其他节点接收到ping消息之后返回pong消息。</p>
<p>注：gossip 协议保证的是数据的最终一致性。</p>
<h2 id="槽位定位算法"><a href="#槽位定位算法" class="headerlink" title="槽位定位算法"></a>槽位定位算法</h2><p>在 Redis 集群中将所有数据划分成 <code>16384</code> 个存储位置，这些被称为 slots(槽位)，分散在 redis 集群中各个节点。</p>
<p>集群中的每个节点可以处理0-16384个slot，当数据库16384个slot都有节点在处理时，集群处于上线状态，反之只要有一个slot没有得到处理都会处理下线状态。通过cluster addslots命令可以将slot指派给对应节点处理。</p>
<p>当 redis cluster 的客户端连接集群时，客户端会在本地存储一份集群的槽位配置信息，并在槽位信息发生变动（节点生命状态发生变化）时及时的更新客户端保存的槽位信息。</p>
<p><strong>数据定位</strong></p>
<p>Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行<code>取模</code>来得到具体槽位。<br><code> HASH_SLOT = CRC16(key) mod 16384</code></p>
<h2 id="跳转重定位"><a href="#跳转重定位" class="headerlink" title="跳转重定位"></a>跳转重定位</h2><p>当客户端向一个指定的节点A发生指令时，如果通过槽位定位发现请求的数据并不再A 管理的槽位范围之内，那么该节点A会向客户端发送跳转指令，告知客户端到正确的节点上执行指令，客户端在收到跳转指令后，会同步更新本地的槽位映射表缓存。</p>
<h2 id="故障转移与选举原理"><a href="#故障转移与选举原理" class="headerlink" title="故障转移与选举原理"></a>故障转移与选举原理</h2><p>Redis Cluster的高可用性也体现在其优秀的故障转移机制和节点选举上。</p>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>如果节点A向节点B发送ping消息，节点B没有在规定的时间内响应pong，那么节点A会标记节点B为<strong>pfail</strong>疑似下线状态，同时把B的状态通过消息的形式发送给其他节点，如果<code>超过半数以上</code>的节点都标记B为pfail状态，B就会被标记为fail下线状态，此时将会发生故障转移，<code>优先从复制数据较多</code>的从节点选择一个成为主节点，并且接管下线节点的slot，整个过程和哨兵非常类似，都是基于Raft协议做选举。</p>
<h3 id="选举流程"><a href="#选举流程" class="headerlink" title="选举流程"></a>选举流程</h3><p>由于挂掉的master 可能会有多个slave，从而存在多个slave竞争成为master节点的过程， 其过程如下: </p>
<ol>
<li><p>slave发现自己的master变为FAIL </p>
</li>
<li><p>将自己记录的集群currentEpoch（集群选举周期）加1，并广播FAILOVER_AUTH_REQUEST （错误转移请求）消息</p>
</li>
<li><p>其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个 epoch（周期）只发送一次ack（认可消息）</p>
</li>
<li><p>尝试failover的slave收集master返回的FAILOVER_AUTH_ACK </p>
</li>
<li><p>slave收到超过半数master的ack后变成新Master(这里解释了集群为什么至少需要三个主节点，如果只有两 个，当其中一个挂了，只剩一个主节点是不能选举成功的)</p>
</li>
<li><p>slave广播Pong消息通知其他集群节点。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/008eGmZEgy1gonb99d60nj30q819uznc.jpg" alt="img"></p>
<p>注：slave 节点并不是在主节点进入 fail 状态就马上发起选举，而是有一点的延迟，确保 FAIL 状态能够传播到集群中的其他节点。这个延迟时间Redis是通过公式计算出来的：</p>
<p><code>DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms</code></p>
<p>其中SLAVE_RANK表示此slave已经从master复制数据的总量的rank。Rank越小代表已复制的数据越新。这种方 式下，持有最新数据的slave将会首先发起选举(理论上)，该节点成为新的 master 节点后数据也较为完整。</p>
<h2 id="集群脑裂数据丢失问题"><a href="#集群脑裂数据丢失问题" class="headerlink" title="集群脑裂数据丢失问题"></a>集群脑裂数据丢失问题</h2><p>所谓脑裂数据丢失问题是指在没有过半机制的限制时，网络分区可能存在网络通信故障，导致 slave 节点错误判定 master 为 FAIL 状态，并发起集群选举成为 master，此时旧 master 恢复通信，导致旧 master 被迫成为 slave 节点，并同步新的 master 节点的数据，覆盖掉之前的节点数据。</p>
<p><strong>如何规避</strong></p>
<p>规避方法可以在redis配置里加上参数(这种方法不可能百分百避免数据丢失，参考集群leader选举机制):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min‐replicas‐to‐write 1 &#x2F;&#x2F;写数据成功最少同步的slave数量，这个数量可以模仿大于半数机制配置，比如 集群总共三个节点可以配置1，加上leader就是2，超过了半数</span><br></pre></td></tr></table></figure>

<p>注:这个配置在一定程度上会影响集群的可用性，比如slave要是少于1个，这个集群就算leader正常也不能 提供服务了，需要具体场景权衡选择。</p>
<p><strong>集群是否完整才能对外提供服务</strong></p>
<p>当redis.conf的配置<code>cluster-require-full-coverage</code>为no时，表示当负责一个插槽的主库下线且没有相应的从 库进行故障恢复时，集群仍然可用，如果为yes则集群不可用。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>Ribbon简介</title>
    <url>/2021/04/12/Ribbon%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="负载均衡的方案"><a href="#负载均衡的方案" class="headerlink" title="负载均衡的方案"></a>负载均衡的方案</h2><ol>
<li><p>集中式（服务端）负载均衡</p>
<p>在消费者和服务提供方中间使用独立的代理方式进行负载，有硬件的(比如<br>F5)，也有软件的(比如 Nginx)。</p>
</li>
<li><p>客户端负载均衡</p>
<p>客户端更加自己的请求情况做负载均衡，如 Ribbon。</p>
</li>
</ol>
<h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><p>常见的负载均衡算法有：</p>
<ul>
<li>随机：通过随机选择服务执行接口调用。</li>
<li>轮询：将请求依次分配到不同的服务实例中，也是负载均衡默认实现。</li>
<li>加权轮询：给不同的实例服务配置权重，并且根据权重进行请求的分发，权重高的服务实例会得到更多的请求。</li>
<li>地址 Hash：通过客户端请求的地址的 Hash 值进行取模运算进行服务实例的调度。</li>
<li>最小连接数：根据服务实例的请求积压情况将当前请求分发到压力小的服务器上。</li>
</ul>
<h1 id="什么是-Ribbon"><a href="#什么是-Ribbon" class="headerlink" title="什么是 Ribbon"></a>什么是 Ribbon</h1><p>Spring Cloud Ribbon是基于Netflix Ribbon 实现的一套<code>客户端的负载均衡工具</code>，Ribbon客户端组件提 供一系列的完善的配置，如超时，重试等。通过Load Balancer获取到服务提供的所有机器实例， Ribbon会自动基于某种规则(轮询，随机)去调用这些服务。Ribbon也可以实现我们自己的负载均衡算法。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230905225332998.png" alt="image-20230905225332998"></p>
<h2 id="Ribbon-模块"><a href="#Ribbon-模块" class="headerlink" title="Ribbon 模块"></a>Ribbon 模块</h2><ul>
<li>ribbon-loadbalancer：负载均衡模块，可以独立使用，也可以与其他模块一起使用</li>
<li>Ribbon：内置的负载均衡算法</li>
<li>ribbon-eureka：基于 Eureka 封装的模块，可以完成对 Eureka 的集成</li>
<li>ribbon-transport：基于 netty 实现对多协议的支持</li>
<li>ribbon-httpclient：基于 Apache HttpClient 封装的 REST 客户端，集成了负载均衡模块，可以直接在项目中使 用来调用接口</li>
<li>ribbon-example：Ribbon 使用代码示例</li>
<li>ribbon-core：一些比较核心且具有通用性的代码，客户端 API 的一些配置和其他 API 的定义</li>
</ul>
<h2 id="Ribbon-的使用"><a href="#Ribbon-的使用" class="headerlink" title="Ribbon 的使用"></a>Ribbon 的使用</h2><h3 id="SpringCloud与-Ribbon-的整合"><a href="#SpringCloud与-Ribbon-的整合" class="headerlink" title="SpringCloud与 Ribbon 的整合"></a>SpringCloud与 Ribbon 的整合</h3><ol>
<li><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;!‐‐添加ribbon的依赖‐‐&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐cloud‐starter‐netflix‐ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注：如果是 Spring cloud-alibaba，并采用 nacos 作为注册中心时，由于 nacos-discovery 包内部已经依赖了 ribbon，所以无需额外引入 Ribbon 依赖。</p>
</li>
<li><p>添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> heyou(heyou_0423 @ 163.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/12 下午11:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改请求方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">findOrderByUserId</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;根据userId:&quot;</span>+id+<span class="string">&quot;查询订单信息&quot;</span>);</span><br><span class="line">        <span class="comment">// 添加@LoadBalanced</span></span><br><span class="line">        String url = <span class="string">&quot;http://mall-order/order/findOrderByUserId/&quot;</span>+id;</span><br><span class="line">        Result result = restTemplate.getForObject(url,Result.class);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Ribbon-重要接口"><a href="#Ribbon-重要接口" class="headerlink" title="Ribbon 重要接口"></a>Ribbon 重要接口</h2><ul>
<li><strong>IClientConfig</strong>：Ribbon的客户端配置，默认采用DefaultClientConfigImpl实现。</li>
<li><strong>IRule</strong>：Ribbon的负载均衡策略，默认采用ZoneAvoidanceRule实现，该策略能够在多区域环境下选出最佳区域的实例进行访问。</li>
<li> <strong>IPing</strong>：Ribbon的实例检查策略，默认采用DummyPing实现，该检查策略是一个特殊的实现，实际上它并不会检查实例是否可用，而是始终返回true，默认认为所有服务实例都是可用的。</li>
<li> <strong>ServerList</strong>：服务实例清单的维护机制，默认采用ConfigurationBasedServerList实现。 </li>
<li><strong>ServerListFilter</strong>：服务实例清单过滤机制，默认采ZonePreferenceServerListFilter，该策略能够优先过滤出与请求方处于同区域的服务实例。</li>
<li><strong>ILoadBalancer</strong>：负载均衡器，默认采用ZoneAwareLoadBalancer实现，它具备了区域感知的能力。</li>
</ul>
<h2 id="Ribbon负载均衡策略"><a href="#Ribbon负载均衡策略" class="headerlink" title="Ribbon负载均衡策略"></a>Ribbon负载均衡策略</h2><h2 id="均衡策略类型"><a href="#均衡策略类型" class="headerlink" title="均衡策略类型"></a>均衡策略类型</h2><ol>
<li><p><strong>RandomRule</strong>: 随机选择一个Server。</p>
</li>
<li><p><strong>RetryRule</strong>: 对选定的负载均衡策略机上重试机制，在一个配置时间段内当选择Server不成 功，则一直尝试使用subRule的方式选择一个可用的server。</p>
</li>
<li><p><strong>RoundRobinRule</strong>: 轮询选择， 轮询index，选择index对应位置的Server。</p>
</li>
<li><p><strong>AvailabilityFilteringRule</strong>: 过滤掉一直连接失败的被标记为circuit tripped的后端Server，并 过滤掉那些高并发的后端Server或者使用一个AvailabilityPredicate来包含过滤server的逻辑，其 实就是检查status里记录的各个Server的运行状态。</p>
</li>
<li><p> <strong>BestAvailableRule</strong>: 选择一个最小的并发请求的Server，逐个考察Server，如果Server被 tripped了，则跳过。</p>
</li>
<li><p><strong>WeightedResponseTimeRule</strong>: 根据响应时间加权，响应时间越长，权重越小，被选中的可 能性越低。</p>
</li>
<li><p><strong>ZoneAvoidanceRule</strong>: 默认的负载均衡策略，即复合判断Server所在区域的性能和 Server的可用性选择Server，在没有区域的环境下，类似于轮询(RandomRule)</p>
</li>
<li><p><strong>NacosRule</strong>: 同集群优先调用</p>
</li>
</ol>
<h2 id="修改默认负载均衡策略"><a href="#修改默认负载均衡策略" class="headerlink" title="修改默认负载均衡策略"></a>修改默认负载均衡策略</h2><ol>
<li><p>全局配置：调用其他微服务，一律使用指定的负载均衡算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">publicclassRibbonConfig&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*全局配置</span></span><br><span class="line"><span class="comment">* 指定负载均衡策略 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 指定使用Nacos提供的负载均衡策略(优先调用同一集群的实例，基于随机权重)</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">new</span> NacosRule();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>局部配置：调用指定微服务提供的服务时，使用对应的负载均衡算法</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 被调用的微服务名 </span></span><br><span class="line"><span class="string">server‐name:</span></span><br><span class="line">	<span class="attr">ribbon:</span></span><br><span class="line">		<span class="comment"># 指定使用Nacos提供的负载均衡策略(优先调用同一集群的实例，基于随机&amp;权重) </span></span><br><span class="line">		<span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义负均衡策略：通过实现 IRule 接口可以自定义负载策略，主要的选择服务逻辑在 choose 方法中</p>
<ul>
<li><p>实现基于Nacos权重的负载均衡策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosRandomWithWeightRule</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> NacosDiscoveryProperties nacosDiscoveryProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initWithNiwsConfig</span><span class="params">(IClientConfig iClientConfig)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        DynamicServerListLoadBalancer loadBalancer = (DynamicServerListLoadBalancer)getLoadBalancer();</span><br><span class="line">        String serviceName = loadBalancer.getName();</span><br><span class="line">        NamingService namingService = nacosDiscoveryProperties.namingServiceInstance();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// nacos基于权重的算法</span></span><br><span class="line">            Instance instance = namingService.selectOneHealthyInstance(serviceName);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NacosServer(instance);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;获取服务实例异常:&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置自定义策略</p>
<ul>
<li><p>修改 application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 被调用的微服务名 </span></span><br><span class="line"><span class="attr">server-name:</span></span><br><span class="line">	<span class="attr">ribbon:</span></span><br><span class="line">	<span class="comment"># 自定义的负载均衡策略(基于随机&amp;权重)</span></span><br><span class="line">		<span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.tuling.mall.ribbondemo.rule.NacosRandomWithWeightRule=</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>全局配置1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IRuleribbonRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> NacosRandomWithWeightRule(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局配置 2：可以利用@RibbonClient指定微服务及其负载均衡策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, DruidDataSourceAutoConfigure.class&#125;)</span></span><br><span class="line"><span class="meta">@RibbonClients(value=&#123;</span></span><br><span class="line"><span class="meta">// 在SpringBoot主程序扫描的包外定义配置类</span></span><br><span class="line"><span class="meta">        @RibbonClient(name = &quot;mall‐order&quot;,configuration = RibbonConfig.class), </span></span><br><span class="line"><span class="meta">        @RibbonClient(name = &quot;mall‐account&quot;,configuration = RibbonConfig.class)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MallUserApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MallUserApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：该全局配置不能写在@SpringbootApplication注解的@CompentScan扫描得到的地方，否则自 定义的配置类就会被所有的 RibbonClients共享。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="Ribbon-原理"><a href="#Ribbon-原理" class="headerlink" title="Ribbon 原理"></a>Ribbon 原理</h1><h2 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h2><p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230905232504714.png" alt="image-20230905232504714"></p>
<h2 id="LoadBalanced-注解原理"><a href="#LoadBalanced-注解原理" class="headerlink" title="@LoadBalanced 注解原理"></a>@LoadBalanced 注解原理</h2><p>首先看一下@LoadBalanced 注解，从注解的注释可知：该注解是标记 RestTemplate 或者 WebClient 的 bean 对象，是作用于LoadBalancerClient配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation to mark a RestTemplate or WebClient bean to be configured to use a</span></span><br><span class="line"><span class="comment"> * LoadBalancerClient.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123; ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LoadBalanced &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，@Qualifier作筛选条件，筛选出具有负载均衡标识的 RestTemplate。通过以上注解的代码来看，该注解仅仅作为标记使用并定义筛选条件。</p>
<p>而实现负载均衡功能的是LoadBalancerAutoConfiguration类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;LoadBalancerRequestTransformer&gt; transformers = Collections.emptyList();</span><br></pre></td></tr></table></figure>

<p>通过@LoadBalanced 注解的定义可知：被@LoadBalanced注解的restTemplate会被定制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingClass(&quot;org.springframework.retry.support.RetryTemplate&quot;)</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptorConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> LoadBalancerInterceptor <span class="title">ribbonInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">				LoadBalancerClient loadBalancerClient,</span></span></span><br><span class="line"><span class="function"><span class="params">				LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> restTemplate -&gt; &#123;</span><br><span class="line">				List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">						restTemplate.getInterceptors());</span><br><span class="line">				list.add(loadBalancerInterceptor);</span><br><span class="line">				restTemplate.setInterceptors(list);</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>通过LoadBalancerInterceptorConfig为LoadBalancerAutoConfiguration的内部类，被@LoadBalanced标记的 RestTemplate 会添加LoadBalancerInterceptor拦截器。</p>
]]></content>
      <categories>
        <category>SpringCloud alibaba</category>
      </categories>
      <tags>
        <tag>负载均衡器</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL mode 简单介绍与使用</title>
    <url>/2023/09/05/SQL%20mode%20%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="SQL-mode-简单介绍与使用"><a href="#SQL-mode-简单介绍与使用" class="headerlink" title="SQL mode 简单介绍与使用"></a>SQL mode 简单介绍与使用</h1><h2 id="什么是SQL-mode"><a href="#什么是SQL-mode" class="headerlink" title="什么是SQL mode"></a>什么是SQL mode</h2><p>一句话概述：SQL mode 定义MySQL应该支持什么样的SQL语法以及它应该执行什么样的数据验证检查。</p>
<p><strong>MySQL服务器端可以以不同的SQL mode 运行</strong>，并且可以根据sql_mode系统变量的值为不同的客户端应用不同的模式。DBA可以设置全局SQL mode ，每个客户端应用程序可以根据自己的需求设置会话SQL模式。</p>
<h2 id="设置和查看SQL-mode"><a href="#设置和查看SQL-mode" class="headerlink" title="设置和查看SQL mode"></a>设置和查看SQL mode</h2><p>MySQL8 默认的SQL mode包括：</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_only_full_group_by">ONLY_FULL_GROUP_BY</a>：拒绝select列表、HAVING条件或ORDER BY列表引用既不在GROUP BY子句中命名也在功能上依赖于(由GROUP BY唯一确定)列的非聚合列的查询。</p>
<p>对于 group by 的这种聚合操作，如果在select 中的列，没有在group by 中出现，那么这个SQL是不合法的，因为列不在group by的从句中，所以对于设置了这个mode的数据库，在使用group by 的时候，就要用MAX()，SUM()，ANT_VALUE()的这种聚合函数，才能完成GROUP BY 的聚合操作。</p>
<p> <a href="https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_strict_trans_tables">STRICT_TRANS_TABLES</a>为事务性存储引擎启用严格SQL模式，并在可能时为非事务性存储引擎启用严格SQL模式。在该模式下,如果一个值不能插入到一个事务表中,则中断当前的操作,对非事务表不做限制。</p>
<p>比如我们的某个字段设置不能为NULL，而我们插入的数据这个字段为NULL，那么就不能通过，就会报错：</p>
<p>1364 - Field ‘xxxx’ doesn’t have a default value</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_no_zero_in_date">NO_ZERO_IN_DATE</a>NO_ZERO_IN_DATE模式会影响服务器是否允许年部分不为零但月或日部分为0的日期。(该模式影响日期，如“2010-00-01”或“2010-01-00”，但不影响“0000-00-00”。要控制服务器是否允许’0000-00-00’，请使用NO_ZERO_DATE模式。)</p>
<p>NO_ZERO_IN_DATE的效果还取决于是否启用严格SQL模式，如果没有启用严格SQL模式STRICT_TRANS_TABLES，那么启用了NO_ZERO_IN_DATE也没用。</p>
<p>如下SQL的日期月和日为0，启用了严格模式和NO_ZERO_IN_DATE，那么就会报错</p>
<p>INSERT INTO <code>csm</code>.<code>user</code> (<code>name</code>, <code>age</code> ,<code>create_date</code>)<br> VALUES (‘xxxx’, ‘26’, ‘2022-00-00’);</p>
<p> 1292 - Incorrect datetime value: ‘2022-00-00’ for column ‘create_date’ at row 1</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_no_zero_date">NO_ZERO_DATE</a>设置该值,mysql数据库不允许插入零日期,插入零日期会抛出错误而不是警告。</p>
<p>上面的NO_ZERO_IN_DATE可以插入’0000-00-00’，如果使用了严格模式和NO_ZERO_DATE，那么就不可以插入’0000-00-00’。</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_error_for_division_by_zero">ERROR_FOR_DIVISION_BY_ZERO</a>在INSERT或UPDATE过程中,如果数据被零除,则产生错误而非警告。如 果未给出该模式,那么数据被零除时MySQL返回NULL 。对于SELECT，如果被除数为0，那么就会返回NULL，MOD(N,M)也一样。</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_no_engine_substitution">NO_ENGINE_SUBSTITUTION</a>如果指定了此mode，我们在创建表或者修改表的时候，如果去指定了不存在或者不支持的存储引擎，那么就会报错，无法创建和修改，如果没有配置此mode，那么就会将我们指定的存储引擎（不支持或者不存在）的存储引擎替换为默认的存储引擎。</p>
<p>当然MySQL 提供了其他的mode ，完整的mode介绍请看<a href="https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sql-mode-full">官方文档</a></p>
<p><strong>如何查看当前MySQL设置的SQL mode</strong></p>
<p>– 查看全局sql_mode设置<br> SELECT @@GLOBAL.sql_mode;<br> – 查看当前客户端的sql_mode<br> SELECT @@SESSION.sql_mode;</p>
<p><strong>其中：</strong></p>
<p>●   设置GLOBAL变量需要SYSTEM_VARIABLES_ADMIN特权(或已弃用的SUPER特权)，并影响从那时起连接的所有客户端的操作。</p>
<p>●   设置SESSION变量只影响当前客户端。每个客户机可以在任何时候更改其会话sql_mode值。</p>
<p><strong>如何设置SQL mode</strong></p>
<p>设置SQL mode有如下几种方式：</p>
<p>●   可以在启动MySQL服务端时，在命令行中使用<a href="https://dev.mysql.com/doc/refman/8.0/en/server-options.html#option_mysqld_sql-mode">–sql-mode=”modes”</a> 或者在配置文件中使用SQL -mode=”modes”，在my.conf/my.ini中。</p>
<p>●   要显式清除SQL模式，需要在命令行上使用——sql-mode=””将其设置为空字符串，或在选项文件中使用sql-mode=””。</p>
<p>●   也可以在运行时修改mode：</p>
<p>– 设置全局SQL-mode<br> SET GLOBAL sql_mode = ‘modes’;<br> – 设置当前客户端的SQL-mode<br> SET SESSION sql_mode = ‘modes’;</p>
<p>在SpringBoot中配置：可以在配置jdbc url后面追加：&amp;sessionVariables=sql_mode=’STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION’ 定义客户端连接所使用的SQL mode</p>
<p>如下为CSM中配置的数据库连接url配置：</p>
<p>csm.mysql.url=jdbc:mysql://10.120.0.39:3306/csm?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;rewriteBatchedStatements=true&amp;noDatetimeStringSync=true&amp;serverTimezone=Asia/Shanghai&amp;allowMultiQueries=true&amp;sessionVariables=sql_mode=’STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION’</p>
<p>参考文档：</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/faqs-sql-modes.html">https://dev.mysql.com/doc/refman/8.0/en/faqs-sql-modes.html</a></p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_only_full_group_by">https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html</a></p>
<p><a href="https://developer.aliyun.com/article/710525">https://developer.aliyun.com/article/710525</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL Explain工具介绍</title>
    <url>/2021/04/04/MySQL-Explain%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="Explain工具的作用"><a href="#Explain工具的作用" class="headerlink" title="Explain工具的作用"></a>Explain工具的作用</h1><p>简单来说，explain 关键字是用于模拟执行 SQL 语句，分析 SQL查询语句的性能情况，如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中。</p>
<p>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from film where id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/he-You/image/master/008eGmZEgy1gp8y8alsnzj317w042ab0.jpg" alt="img"></p>
<h1 id="Explain-中的列"><a href="#Explain-中的列" class="headerlink" title="Explain 中的列"></a>Explain 中的列</h1><ol>
<li><p>id 列</p>
<p>id 列的编号是 select 的序列号，有几个 select 就有几个 id,并且 id 的顺序是按 select 出现的顺序增长的。id 列越大执行优先级越高，如果 id 列值相同，则从上往下执行，如果 id 为 NULL 则最后执行。</p>
</li>
<li><p>select_type 列</p>
<p>该列表示对应的查询是简单查询还是复杂查询，其中：</p>
<ul>
<li>simple：简单查询，查询不包含子查询和 union</li>
<li>primary：复杂查询中最外层的 select</li>
<li>subquery：包含在 select中的子查询</li>
<li>derived：包含在 from 子句中的子查询。MySQL会将结果放在一个临时表中，也称之为派生表</li>
<li>union：在 union 中的第二个和随后的 select</li>
</ul>
</li>
<li><p>table列</p>
<p>该列表示 explain 当前访问的是哪张表，如果 from 子句中子查询时，table 列时<code>&lt;derivenN&gt;</code>格式，表示当前查询依赖 id=N 的查询，即会执行 id=N的查询语句，如果存在 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的 select 行id。</p>
</li>
<li><p>type 列</p>
<p>该列表示关联类型或者说是访问类型，表示 MySQL 是如何查询表中的行，查找数据行记录的大概范围。</p>
<p>查询性能：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL一般来说，得保证查询达到range级别，最好达到ref </p>
<ul>
<li><strong>NULL</strong>：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如:在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表</li>
<li><strong>const, system</strong>：mysql能对查询的某部分进行优化并将其转化成一个常量(可以看show warnings 的结果)。用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。system是 const的特例，表里只有一条元组匹配时为system</li>
<li><strong>eq_ref</strong>：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</li>
<li><strong>ref</strong>：与 eq_ref不同 ref 使用的普通索引或者唯一性索引的部分前缀，可能会有多个符合条件的行。</li>
<li><strong>range</strong>：范围扫描通常出现在 in()、between、&gt;、&lt;、&gt;=等操作中</li>
<li><strong>index</strong>：扫描全索引就能拿到结果，一般是<strong>扫描某个二级索引</strong>，这种扫描不会从索引树根节点开始快速查找，而是直接 对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这种通常比ALL快一些。</li>
<li><strong>ALL</strong>：即全表扫描，扫描聚簇索引的所有叶子节点，这种查询类型通常可以使用索引来进行优化。</li>
</ul>
</li>
<li><p>possible_keys 列</p>
<p>这一列显示查询可能使用哪些索引来查找。explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引 对此查询帮助不大，选择了全表查询。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提 高查询性能，然后用 explain 查看效果。</p>
</li>
<li><p>key 列</p>
<p>这一列显示mysql实际采用哪个索引来优化对该表的访问。如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</p>
</li>
<li><p>key_len列</p>
<p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。</p>
</li>
<li><p>ref 列</p>
<p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有:const(常量)，字段名(例:id)</p>
</li>
<li><p>rows 列</p>
<p>这一列是mysql估计要<code>读取并检测</code>的行数，注意这个不是结果集里的行数。</p>
</li>
<li><p>Extra 列</p>
<p>这一列展示的是额外信息。常见的重要值如下:</p>
<ul>
<li>Using index:使用覆盖索引</li>
<li>Using where:使用 where 语句来处理结果，并且查询的列未被索引覆盖</li>
<li>Using index condition:查询的列不完全被索引覆盖，where条件中是一个前导列的范围</li>
<li>Using temporary:mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</li>
<li>Using filesort:将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一 般也是要考虑使用索引来优化的。</li>
<li>Select tables optimized away:使用某些聚合函数(比如 max、min)来访问存在索引的某个字段时。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Explain</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务之回滚机制</title>
    <url>/2020/07/11/Spring%20%E4%BA%8B%E5%8A%A1%E4%B9%8B%E5%9B%9E%E6%BB%9A%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol>
<li><p>事务回滚的机制是为了防止程序运行过程中出现异常，导致数据库产生脏数据。即当程序出现异常时，数据库的状态回滚到异常之前的状态；</p>
</li>
<li><p>异常的架构</p>
</li>
</ol>
<p><img src="https://i.loli.net/2020/09/23/aWD4UvbJq6sSTEf.png" alt="exception.png"></p>
<ol start="3">
<li>checked 和 unchecked 异常</li>
</ol>
<p>Spring使用声明式事务处理，<strong>默认情况下，如果被注解的数据库操作方法中发生了unchecked异常</strong>，所有的数据库操作将rollback；<strong>如果发生的异常是checked异常，默认情况下数据库操作还是会提交的。</strong></p>
<p><strong>checked异常：</strong> </p>
<p>表示无效，不是程序中可以预测的。比如无效的用户输入，文件不存在，网络或者数据库链接错误。这些都是外在的原因，都不是程序内部可以控制的。 </p>
<p>必须在代码中显式地处理。比如try-catch块处理，或者给所在的方法加上throws说明，将异常抛到调用栈的上一层。 </p>
<p>继承自java.lang.Exception（java.lang.RuntimeException除外）。</p>
<p><strong>unchecked异常：</strong> </p>
<p>表示错误，程序的逻辑错误。是RuntimeException的子类，比如IllegalArgumentException, NullPointerException和IllegalStateException。 </p>
<p>不需要在代码中显式地捕获unchecked异常做处理。 </p>
<p>继承自java.lang.RuntimeException（而java.lang.RuntimeException继承自java.lang.Exception）。</p>
<h3 id="Transactional的使用"><a href="#Transactional的使用" class="headerlink" title="@Transactional的使用"></a>@Transactional的使用</h3><ol>
<li>相关概念</li>
</ol>
<ul>
<li><p>Spring 的@Transactional 注解是基于动态代理的机制，提供一种事务管理方式；</p>
</li>
<li><p>一般使用是通过如下代码对方法或接口或类注释：</p>
<p><strong>@Transactional(propagation=Propagation.NOT_SUPPORTED)</strong></p>
<p>其中：</p>
<p>Propagation支持7种不同的传播机制：</p>
<p><strong>REQUIRED：</strong>如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。</p>
<p><strong>SUPPORTS：</strong> 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。</p>
<p><strong>NOT_SUPPORTED：</strong>总是非事务地执行，并挂起任何存在的事务。</p>
<p><strong>REQUIRESNEW：</strong>总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</p>
<p><strong>MANDATORY：</strong>如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</p>
<p><strong>NEVER：</strong>总是非事务地执行，如果存在一个活动事务，则抛出异常</p>
<p><strong>NESTED：</strong>如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。</p>
</li>
<li><p>@Transactional 注解只能应用到 public 可见度的方法上。 如果你在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错， 但是这个被注解的方法将不会展示已配置的事务设置。</p>
</li>
</ul>
<ol start="2">
<li>回滚机制</li>
</ol>
<ul>
<li><p>判断是否能够回滚的逻辑如下：<br> (1) 根据@Transactional注解中rollbackFor、rollbackForClassName、noRollbackForClassName配置的值，找到最符合ex的异常类型，如果符合的异常类型不是NoRollbackRuleAttribute，则可以执行回滚。<br> (2) 如果@Transactional没有配置，则默认使用RuntimeException和Error异常。</p>
</li>
<li><p>事务处理：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br></pre></td></tr></table></figure>

<p>交给事务管理器回滚事务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRollback</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            triggerBeforeCompletion(status);</span><br><span class="line">            <span class="comment">//如果有安全点，回滚至安全点</span></span><br><span class="line">            <span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Rolling back transaction to savepoint&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                status.rollbackToHeldSavepoint();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是新事务，回滚事务</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Initiating transaction rollback&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                doRollback(status);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果有事务但不是新事务，则把标记事务状态，等事务链执行完毕后统一回滚</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (status.hasTransaction()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    doSetRollbackOnly(status);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Should roll back transaction but cannot - no transaction available&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">            triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//清空记录的资源并将挂起的资源恢复</span></span><br><span class="line">        cleanupAfterCompletion(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事务处理的逻辑总结起来如下：</p>
<ol>
<li><p>如果存在安全点，则回滚事务至安全点，这个主要是处理嵌套事务，回滚安全点的操作还是交给了数据库处理.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollbackToHeldSavepoint</span><span class="params">()</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasSavepoint()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TransactionUsageException(</span><br><span class="line">                <span class="string">&quot;Cannot roll back to savepoint - no savepoint associated with current transaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    getSavepointManager().rollbackToSavepoint(getSavepoint());</span><br><span class="line">    getSavepointManager().releaseSavepoint(getSavepoint());</span><br><span class="line">    setSavepoint(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>当前事务是一个新事务时，那么直接回滚，使用的是DataSourceTransactionManager事务管理器，所以调用DataSourceTransactionManager中的doRollback方法,直接调用数据库连接的回滚方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRollback</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</span><br><span class="line">    DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();</span><br><span class="line">    Connection con = txObject.getConnectionHolder().getConnection();</span><br><span class="line">    <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Rolling back JDBC transaction on Connection [&quot;</span> + con + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        con.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TransactionSystemException(<span class="string">&quot;Could not roll back JDBC transaction&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>当前存在事务，但又不是一个新的事务，只把事务的状态标记为read-only，等到事务链执行完毕后，统一回滚,调用DataSourceTransactionManager的doSetRollbackOnly</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSetRollbackOnly</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</span><br><span class="line">    DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();</span><br><span class="line">    <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Setting JDBC transaction [&quot;</span> + txObject.getConnectionHolder().getConnection() +</span><br><span class="line">                <span class="string">&quot;] rollback-only&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    txObject.setRollbackOnly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>清空记录的资源并将挂起的资源恢复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanupAfterCompletion</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置完成状态，避免重复调用</span></span><br><span class="line">    status.setCompleted();</span><br><span class="line">    <span class="comment">//如果是新的同步状态，则需要将绑定到当前线程的事务信息清理，传播行为中挂起事务的都会清理</span></span><br><span class="line">    <span class="keyword">if</span> (status.isNewSynchronization()) &#123;</span><br><span class="line">        TransactionSynchronizationManager.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是新事务，清理数据库连接</span></span><br><span class="line">    <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">        doCleanupAfterCompletion(status.getTransaction());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将挂起的事务恢复</span></span><br><span class="line">    <span class="keyword">if</span> (status.getSuspendedResources() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Resuming suspended transaction after completion of inner transaction&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        resume(status.getTransaction(), (SuspendedResourcesHolder) status.getSuspendedResources());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>事务机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis核心数据结构与应用场景介绍</title>
    <url>/2021/03/11/Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="Redis核心数据结构"><a href="#Redis核心数据结构" class="headerlink" title="Redis核心数据结构"></a>Redis核心数据结构</h1><p>在 Redis 中常用的核心数据结构有 5 种，分别是：string、hash、list、set、zset</p>
<h2 id="String结构"><a href="#String结构" class="headerlink" title="String结构"></a>String结构</h2><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p><strong>字符串常用操作命令</strong></p>
<ul>
<li>set key value :存入字符串键值对</li>
<li>mset key value[key value …]:批量存储字符串键值对</li>
<li>setnx key value : 存入一个不存在的字符串键值对</li>
<li>get key : 获取 key 对应的字符串键值</li>
<li>mget key [key ..]:批量获取字符串键值</li>
<li>del key: 删除一个键</li>
<li>expire key seconds :设置键的过期时间（s）</li>
</ul>
<p><strong>原子加减</strong></p>
<ul>
<li>incr key ：将 key 中存储的数值值加 1</li>
<li>decr key : 将 key 中存储的数字值减 1</li>
<li>incrby key increment :将key所储存的值加上increment</li>
<li>decrby key decrement : 将key所储存的值减去decrement</li>
</ul>
<p>string hash list set zset</p>
<h3 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h3><ul>
<li>单值缓存</li>
<li>对象缓存：json 字符串</li>
<li>分布式锁：setnx key:value true  返回 1 表示获取锁成功，返回 0 表示获取锁失败</li>
<li>计数器： INCR </li>
<li>Web 集群 session共享</li>
<li>分布式系统全局序列号 INCRBY orderId 10000// redis 批量生成序列号减少和 redis的请求交互从而提升 redis 性能</li>
</ul>
<h2 id="Hash结构"><a href="#Hash结构" class="headerlink" title="Hash结构"></a>Hash结构</h2><h3 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h3><ul>
<li><p>hest key field value ： 存储一个哈希表key的键值</p>
</li>
<li><p>hsetnx key field value ：存储一个不存在的哈希表key的键值，即如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。如果字段已经存在于哈希表中，操作无效。设置成功，返回 1 。 如果给定字段已经存在且没有操作被执行，返回 0 。</p>
</li>
<li><p>hmset  key field value [field value …]：在一个哈希表key中存储多个键值对</p>
</li>
<li><p>hget key field：获取哈希表key对应的field键值</p>
</li>
<li><p>hmget key field [field …] ：批量获取哈希表key中多个field键值</p>
</li>
<li><p>hdel key field [field …] ：删除哈希表key中的field键值</p>
</li>
<li><p>hlen key ：返回哈希表key中field的数量</p>
</li>
<li><p>hgetall key ：返回哈希表key中所有的键值</p>
</li>
<li><p>hincrby key field increment：为哈希表key中field键的值加上增量increment</p>
</li>
</ul>
<h3 id="对象缓存"><a href="#对象缓存" class="headerlink" title="对象缓存"></a>对象缓存</h3><p>hmset user prefix:name heyou prefix:age 24</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>电商购物车</strong></p>
<p>1）以用户id为key</p>
<p>2）商品id为field</p>
<p>3）商品数量为value</p>
<p>1)添加商品—-&gt;hset car:2021 iphone12pro 1</p>
<p>2)增加数量—-&gt;hset car:2021 iphone12pro 1</p>
<p>3)商品总数—-&gt;hlen car:2021</p>
<p>4)删除商品—-&gt;hdel car:2021 iphone12pro</p>
<p>获取购物车所有商品—-&gt;hgetall car:2021</p>
<p>使用 hash 结构存储数据的优缺点如下：</p>
<p><strong>优点</strong></p>
<ul>
<li>同类数据归类整合存储，方便对数据的管理</li>
<li>相比于 String类型的数据操作消耗的内存和 cpu更小</li>
<li>相比于 string 存储更节省空间</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>过期功能只能设置在 key 上，无法实现对 field 字段设置过期功能</li>
<li>在 Redis 集群架构环境下不适合大规模使用，容易出现 big key 导致集群环境出现数据倾斜</li>
</ul>
<h2 id="list-结构"><a href="#list-结构" class="headerlink" title="list 结构"></a>list 结构</h2><h3 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h3><ul>
<li>Lpush key value [value…]：将一个或多个 value 值插入到 key 列表的最左边</li>
<li>Rpush key  value [value…]：将一个或多个 value 值插入到 key 列表的最左边</li>
<li>Lpop key： 从左边移除并返回 key 列表的元素</li>
<li>Rpop key： 从右边移除并返回 key 列表的元素</li>
<li>Lrange key start stop：返回列表 key 中指定区间内的元素，从下表 start 到 stop</li>
<li>Blpop key [key..] timeout：从 key 列表最左边弹出一个元素，如果列表中没有元素，阻塞等待 timeout 秒，若 tiomeout=0则会一直等待</li>
<li>Brpop key [key..] timeout：从 key 列表最右边弹出一个元素，如果列表中没有元素，阻塞等待 timeout 秒，若 tiomeout=0则会一直等待</li>
</ul>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>常用数据结构</strong></p>
<p>Stack(栈) = LPUSH + LPOP</p>
<p>Queue(队列）= LPUSH + RPOP</p>
<p>Blocking MQ(阻塞队列）= LPUSH + BRPOP</p>
<p><strong>信息流</strong></p>
<p>将信息流对象根据时间倒序放入 list 中，然后依次消费。常见于微博微信朋友圈。</p>
<h2 id="Set-结构"><a href="#Set-结构" class="headerlink" title="Set 结构"></a>Set 结构</h2><p>该集合无法添加重复元素</p>
<h3 id="常用操作-3"><a href="#常用操作-3" class="headerlink" title="常用操作"></a>常用操作</h3><ul>
<li>sadd key member [member…]：向集合 key 中存入元素，如果元素已经存在则忽略,不存在则新增</li>
<li>srem key member [member…]: 从集合中 key 中移除元素</li>
<li>Smembers key：获取集合key 中的所有元素</li>
<li>scard key：获取集合 key 中所有元素的个数 </li>
<li>sismember key member：判断 member 元素是否在集合 key 中</li>
<li>srandmember key [count]：从集合 key 中随机选出 count 个元素，元素不从 key 中删除</li>
<li>Spop key [count]:从集合 key 中随机选出 count 个元素并删除</li>
</ul>
<h3 id="运算操作"><a href="#运算操作" class="headerlink" title="运算操作"></a>运算操作</h3><ul>
<li><p>SINTER key1 [key2 …]  ：交集运算</p>
</li>
<li><p>SINTERSTORE destination key1 [key2 ..] ：将key1和 key2交集结果存入新集合destination中</p>
</li>
<li><p>SUNION key1 [key2 ..]  ：并集运算</p>
</li>
<li><p>SUNIONSTORE destination key1 [key2 …] ：将key1和 key2并集结果存入新集合destination中</p>
</li>
<li><p>SDIFF key [key …] ：差集运算</p>
</li>
<li><p>SDIFFSTORE destination key1 [key2…] ：将key1和 key2差集结果存入新集合destination中</p>
</li>
</ul>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>微信抽奖小程序</strong></p>
<p>1）点击参与抽奖加入集合</p>
<p>SADD key {userlD}</p>
<p>2）查看参与抽奖所有用户</p>
<p>SMEMBERS key  </p>
<p>3）抽取count名中奖者</p>
<p>SRANDMEMBER key [count] / SPOP key [count]</p>
<p><strong>微信微博点赞，收藏，标签</strong></p>
<ol>
<li>点赞</li>
</ol>
<p>SADD like:{消息ID} {用户ID}</p>
<ol start="2">
<li>取消点赞</li>
</ol>
<p>SREM like:{消息ID} {用户ID}</p>
<ol start="3">
<li>检查用户是否点过赞</li>
</ol>
<p>SISMEMBER like:{消息ID} {用户ID}</p>
<ol start="4">
<li>获取点赞的用户列表</li>
</ol>
<p>SMEMBERS like:{消息ID}</p>
<ol start="5">
<li>获取点赞用户数</li>
</ol>
<p>SCARD like:{消息ID}</p>
<p><strong>集合操作（交集、并集、差集）</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goia9e82i6j31120lkdhl.jpg"></p>
<p>SINTER set1 set2 set3 -&gt; { c }</p>
<p>SUNION set1 set2 set3 -&gt;{ a,b,c,d,e }</p>
<p>SDIFF set1 set2 set3 -&gt;{ a }</p>
<p><strong>关注模型</strong></p>
<ol>
<li>z关注的人: </li>
</ol>
<p>z:set-&gt; {g, x}</p>
<ol start="2">
<li><p>y关注的人:</p>
<p>y:set–&gt; {z, b, g, x}</p>
</li>
<li><p>g关注的人: </p>
</li>
</ol>
<p>g:set-&gt; {z, y, b, x, xy)</p>
<ol start="4">
<li>z和y共同关注: </li>
</ol>
<p>SINTER z:set y:set–&gt; {g, x}</p>
<ol start="5">
<li>z关注的人也关注他(y): </li>
</ol>
<p>SISMEMBER g:set y </p>
<p>SISMEMBER x y</p>
<ol start="6">
<li>我可能认识的人: </li>
</ol>
<p>SDIFF y:set z:Set-&gt;(z, b}</p>
<p><strong>商品的筛选</strong></p>
<p>根据商品的特性可以设置多个标签，每个标签设置成一个集合，最终实现多个标签进行筛选，也是通过集合的交集实现的。</p>
<h2 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset 有序集合"></a>Zset 有序集合</h2><h3 id="Zset-常用操作"><a href="#Zset-常用操作" class="headerlink" title="Zset 常用操作"></a>Zset 常用操作</h3><ul>
<li><p>Zadd key score member [[score member]…] ：往有序集合key中加入带分值元素</p>
</li>
<li><p>Zrem key member [member …] ：从有序集合key中删除元素</p>
</li>
<li><p>Zscore key member：返回有序集合key中元素member的分值</p>
</li>
<li><p>Zincrby key increment member //为有序集合key中元素member的分值加上increment </p>
</li>
<li><p>Zcard key ：返回有序集合key中元素个数</p>
</li>
<li><p>Zrange key start stop [withScores] ：正序获取有序集合key从start下标到stop下标的元素[带上分值]</p>
</li>
<li><p>Zrevrange key start stop [withScores] ：倒序获取有序集合key从start下标到stop下标的元素[带上分值]</p>
</li>
</ul>
<h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><ul>
<li><p>ZUnionStore destkey numkeys key [key …] ：并集计算</p>
</li>
<li><p>ZinterStore destkey numkeys key [key …] ：交集计算</p>
</li>
</ul>
<h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>Zset集合操作实现排行榜</strong></p>
<p>1）点击新闻</p>
<p>Zincrby hotNews:20210313 1 学习 redis</p>
<p>2）展示当日排行前十</p>
<p>Zrevrange hotNews:20210313 0 9 withScores </p>
<p>3）七日搜索榜单计算</p>
<p>ZunionStore hotNews:20210306-20210313 7 </p>
<p>hotNews:20210306 hotNews:20210307… hotNews:20210313</p>
<p>4）展示七日排行前十</p>
<p>ZREVRANGE hotNews:20210306-20210313 0 9 withScores</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 如何解决循环依赖问题</title>
    <url>/2021/03/25/Spring%20%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h1><p>简单来说就是两个对象互相调用对方的属性。A 依赖了 B,B 依赖了 A。正常情况下对象的相互依赖并不是一个问题。但是在 Spring 中，由于Spring对象并不是简单的 new 处理的对象，而是有自己的生命周期的，而这里说的循环依赖问题也就是在 Spring bean 对象的生命周期中出现的问题。</p>
<h2 id="简述-SpringBean-的生命周期"><a href="#简述-SpringBean-的生命周期" class="headerlink" title="简述 SpringBean 的生命周期"></a>简述 SpringBean 的生命周期</h2><p>在 Spring中 bean 的创建过程大致如下：</p>
<ol>
<li>Spring 扫描 class 得到 BeanDefinition</li>
<li>根据得到的 BeanDefinition 去开始生成 bean 对象</li>
<li>首先根据class 推断构造方法</li>
<li>根据推断出来的构造方法进行反射得到一个对象，暂且称之为原始对象</li>
<li>开始对原始对象填充属性（进行依赖注入）</li>
<li>如果原始对象中有需要AOP 的方法，则通过这个原始对象生成一个代理对象</li>
<li>将最终生成的代理对象（如果没有 AOP则放入经过后置处理器的对象）放入单例池中</li>
</ol>
<h2 id="循环依赖出现的条件"><a href="#循环依赖出现的条件" class="headerlink" title="循环依赖出现的条件"></a>循环依赖出现的条件</h2><p>假设有两个 service 类：AService 和 BService。AService中注入 BService, BService 中注入 AService。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> BService bService;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> AService aService;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当项目启动时，大致会经过以下流程：</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230905222754094.png" alt="image-20230905222754094"></p>
<p>总结来说，就是 beanA 的创建需要 注入beanB，因此需要获取 beanB，而 beanB 中又注入了 beanA 的属性，需要完整 beanA 对象，这样 beanA和 beanB 之间就出现了环，即 AB 出现了循环依赖。</p>
<h1 id="解决循环依赖的思路"><a href="#解决循环依赖的思路" class="headerlink" title="解决循环依赖的思路"></a>解决循环依赖的思路</h1><p>由上可知，循环依赖的出现是 bean 对象创建过程需要从单例池中获取依赖的 bean 对象，而此时 bean 对象并未完成创建的生命周期，那能不能在 bean 创建过程之中就拿到 bean 对象呢？如果能拿到是不是能完成各自 bean 的创建得到最终完整的 bean 对象？</p>
<h1 id="Spring-是如何解决循环依赖"><a href="#Spring-是如何解决循环依赖" class="headerlink" title="Spring 是如何解决循环依赖"></a>Spring 是如何解决循环依赖</h1><p>根据上面的思路，我们只需要用容器暂时存放不完整的 bean 对象，支持创建 bean 对象的属性填充即可。实际上，Spring 确实是通过一个容器存放早期的不完整的 bean 对象，来解决循环依赖的问题的。</p>
<p>这个存放早期 bean 对象的容器为 <code>earlySingletonObjects</code>。</p>
<h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><p>三级缓存是 Spring 解决循环依赖的一种方案</p>
<h3 id="什么是三级缓存"><a href="#什么是三级缓存" class="headerlink" title="什么是三级缓存"></a>什么是三级缓存</h3><p>所谓三级缓存，其实就是 3 个 map容器：</p>
<p>一级缓存：singletonObjects 即单例池，存放的是经过完整创建过程的 bean 对象</p>
<p>二级缓存：earlySingletonObjects存放的是早期的不完整的 bean 对象</p>
<p>三级缓存：singletonFactories，缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</p>
<h3 id="Spring-解决循环依赖的具体实现"><a href="#Spring-解决循环依赖的具体实现" class="headerlink" title="Spring 解决循环依赖的具体实现"></a>Spring 解决循环依赖的具体实现</h3><p>A 的 bean创建过程中，在进行依赖注入之前，把 A 的原始对象放入缓存中，再进行依赖注入，此时A的Bean依赖了B的Bean，如果B的Bean不存在，则需要创建B的Bean。</p>
<p>而创建B的Bean的过程和A一样，也是先创建一个B的原始对象，然后把B的原始对象提早暴露出来放入缓存中，然后在对B的原始对象进行依赖注入A，此时能从缓存中拿到A的原始对象（虽然是A的原始对象，还不是最终的Bean），B的原始对象依赖注入完了之后，B的生命周期结束，那么A的生命周期也能结束。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230905223251339.png" alt="image-20230905223251339"></p>
<p>如上图所示，加入二级缓存 earlySingletonObjects后，A的 bean 和 B 的 bean 就不需要在创建的过程中依赖单例池中的 bean了，只需要获取二级缓存中的早期 bean对象去完成各自 bean 的属性注入即可。</p>
<h3 id="为什么是三级缓存"><a href="#为什么是三级缓存" class="headerlink" title="为什么是三级缓存"></a>为什么是三级缓存</h3><p>根据上述过程可以发现，使用 Spring的二级缓存就可以解决循环依赖的问题，那 Spring 为什么还要加上一个三级缓存<strong>singletonFactories</strong>呢。</p>
<p>因为在 Spring bean对象的初始化后，Spring 提供了一个扩展点，即 BeanPostProcessor,后置处理器可以去对Bean进行加工，这个加工不仅仅只是能修改Bean的属性值，也可以替换掉当前Bean。</p>
<p>因为，循环依赖是发生在属性注入过程中的，所以很有可能导致，<strong>注入给B对象的A对象和经历过完整生命周期之后的A对象，不是一个对象</strong>。这就是有问题的。</p>
<p><strong>所以在这种情况下的循环依赖，Spring是解决不了的，因为在属性注入时，Spring也不知道A对象后续会经过哪些BeanPostProcessor以及会对A对象做什么处理</strong>。这常见于 AOP。</p>
<h1 id="Spring-解决了哪种循环依赖"><a href="#Spring-解决了哪种循环依赖" class="headerlink" title="Spring 解决了哪种循环依赖"></a>Spring 解决了哪种循环依赖</h1><p>AOP就是通过一个BeanPostProcessor来实现的，这个BeanPostProcessor就是AnnotationAwareAspectJAutoProxyCreator，它的父类是AbstractAutoProxyCreator，而在Spring中AOP利用的要么是JDK动态代理，要么CGLib的动态代理，所以如果给一个类中的某个方法设置了切面，那么这个类最终就需要生成一个代理对象。</p>
<p>一般过程就是：A类—&gt;生成一个普通对象–&gt;属性注入–&gt;基于切面生成一个代理对象–&gt;把代理对象放入singletonObjects单例池中。</p>
<p>因此，为了解决循环依赖，并且支持 AOP 对原始对象的改造，Spring 引入了第三级缓存：singletonFactories。</p>
<p>singletonFactories中存的是某个beanName对应的ObjectFactory，在bean的生命周期中，生成完原始对象之后，就会构造一个ObjectFactory存入singletonFactories中。这个ObjectFactory是一个函数式接口，所以支持Lambda表达式：</p>
<p><strong>() -&gt; getEarlyBeanReference(beanName,mbd,bean)</strong></p>
<p>注：存入singletonFactories时并不会执行lambda表达式，也就是不会执行getEarlyBeanReference方法</p>
<p>该 Lambda就是第三级缓存存放的元素，执行该Lambda表达式就会去执行getEarlyBeanReference方法，而该方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法会去执行<strong>SmartInstantiationAwareBeanPostProcessor</strong>中的<strong>getEarlyBeanReference</strong>方法，而这个接口下的实现类中只有两个类实现了这个方法：</p>
<p>一个是AbstractAutoProxyCreator，</p>
<p>一个是InstantiationAwareBeanPostProcessorAdapter，</p>
<p>它的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InstantiationAwareBeanPostProcessorAdapter</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAutoProxyCreator</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">    <span class="keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">    <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述实现可以知道：在 Spring 中默认只有AbstractAutoProxyCreator真正实现了 getEarlyBeanRefrence方法。也就是使用该类进行 AOP 的。</p>
<p>那这个getEarlyBeanRefrence（）方法的作用是什么呢？</p>
<ol>
<li>通过 beanName 得到一个 cacheKey</li>
<li>将 beanName 和 (原始对象)bean存入 earlyProxyRefrences 中</li>
<li>调用wrapIfNecessary进行AOP，得到一个代理对象。</li>
</ol>
<p>从singletonFactories根据beanName得到一个ObjectFactory，然后执行ObjectFactory，也就是执行getEarlyBeanReference方法，此时会得到一个A原始对象经过AOP之后的代理对象，然后把该代理对象放入earlySingletonObjects中，注意此时并没有把代理对象放入singletonObjects中。</p>
<p>因为A原始对象还没有进行属性填充，所以此时不能直接把A的代理对象放入singletonObjects中，所以只能把代理对象放入earlySingletonObjects，假设现在有其他对象依赖了A，那么则可以从earlySingletonObjects中得到A原始对象的代理对象了，并且是A的同一个代理对象。</p>
<p>当B创建完了之后，A继续进行生命周期，而A在完成属性注入后，会按照它本身的逻辑去进行AOP，而此时我们知道A原始对象已经经历过了AOP，所以对于A本身而言，不会再去进行AOP了，那么怎么判断一个对象是否经历过了AOP呢？会利用上文提到的earlyProxyReferences，在AbstractAutoProxyCreator的<strong>postProcessAfterInitialization</strong>方法中，会去判断当前beanName是否在earlyProxyReferences：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// earlyProxyReferences中存的是哪些提前进行了AOP的bean，beanName:AOP之前的对象</span></span><br><span class="line"><span class="comment">// 注意earlyProxyReferences中并没有存AOP之后的代理对象  BeanPostProcessor</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">	<span class="comment">// 没有提前进行过AOP，则进行AOP</span></span><br><span class="line">	<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过判断this.earlyProxyReferences.remove(cacheKey) != bean判断是否已经创建过代理对象了。</p>
<p>对于A而言，进行了AOP的判断后，以及BeanPostProcessor的执行之后，就需要把A对应的对象放入singletonObjects中了，但是我们知道，应该是要A的代理对象放入singletonObjects中，所以此时需要从earlySingletonObjects中得到代理对象，然后入singletonObjects中。</p>
<h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1><p><strong>singletonObjects</strong>：缓存某个beanName对应的经过了完整生命周期的bean</p>
<p><strong>earlySingletonObjects</strong>：缓存提前通过原始对象进行了AOP之后得到的代理对象，原始对象还没有进行属性注入和后续的BeanPostProcessor等生命周期</p>
<p><strong>singletonFactories</strong>：缓存的是一个ObjectFactory，也就是一个Lambda表达式。在创建一个Bean时，在每个Bean的生成过程中，都会提前暴露一个Lambda表达式，并保存到三级缓存中，这个Lambda表达式<strong>可能用到，也可能用不到</strong>。</p>
<p>如果没有出现循环依赖依赖本bean，那么这个Lambda表达式无用，本bean按照自己的生命周期执行，执行完后直接把本bean放入singletonObjects中即可；</p>
<p>如果出现了循环依赖依赖了本bean，则从三级缓存中获取Lambda表达式，并执行Lambda表达式得到一个AOP之后的代理对象(如果有AOP的话，如果无需AOP，则直接得到一个原始对象)，并把得到的对象放入二级缓存</p>
<p>其实还要一个缓存，就是<strong>earlyProxyReferences</strong>，它用来记录某个<code>原始对象（该缓存中存入的是原始对象）</code>是否进行过AOP了。</p>
<p>此外，在判断是否正在创建中也用到了一个集合：singletonsCurrentlyInCreation</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; singletonsCurrentlyInCreation =</span><br><span class="line">			Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>));</span><br></pre></td></tr></table></figure>

<p>该集合用于判断所需要的 bean 是否真正创建中。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>循环依赖</tag>
      </tags>
  </entry>
  <entry>
    <title>java.lang.UnsupportedOperationException异常</title>
    <url>/2020/10/05/java.lang.UnsupportedOperationException%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>关于操作 List出现的java.lang.UnsupportedOperationException异常</p>
<p>一 、出现该异常的场景</p>
<ul>
<li>需要对 List数据进行增删处理，即对 List 容器中的元素进行 add 或者 remove操作</li>
<li>对 abstractList 的子类进行 add/remove 可能会出现这个异常</li>
</ul>
<p>二、异常的原因</p>
<p>如果 List 的继承于 AbstractList 且没有实现 add()或 remove()时，对 list 对象中的元素进行增加或者删除就会出现这个异常。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 中的重要概念</title>
    <url>/2021/02/07/Spring-%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="Spring-中的重要概念"><a href="#Spring-中的重要概念" class="headerlink" title="Spring 中的重要概念"></a>Spring 中的重要概念</h1><h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2><h3 id="Bean与-Java对象的区别"><a href="#Bean与-Java对象的区别" class="headerlink" title="Bean与 Java对象的区别"></a>Bean与 Java对象的区别</h3><p>在 Spring 中所有的 Bean 都是 Java 对象，但是 Java 对象不一定Bean。</p>
<h3 id="Bean的创建的方式"><a href="#Bean的创建的方式" class="headerlink" title="Bean的创建的方式"></a>Bean的创建的方式</h3><ul>
<li>xml</li>
<li>@Bean</li>
<li>@Component</li>
<li>BeanDefinition</li>
</ul>
<p>如何通过 BeanDefinition 创建 Bean?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义了一个BeanDefinition</span></span><br><span class="line">AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line"><span class="comment">// 当前Bean对象的类型</span></span><br><span class="line">beanDefinition.setBeanClass(Person.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将BeanDefinition注册到BeanFactory中</span></span><br><span class="line">DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">beanFactory.registerBeanDefinition(<span class="string">&quot;person&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Bean</span></span><br><span class="line">System.out.println(beanFactory.getBean(<span class="string">&quot;person&quot;</span>));</span><br></pre></td></tr></table></figure>



<h3 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h3><p>bean对象从创建实例化初始化到最终销毁的过程</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>单例、原型、request、session</p>
<h4 id="单例Bean-默认是单例"><a href="#单例Bean-默认是单例" class="headerlink" title="单例Bean-默认是单例"></a>单例Bean-默认是单例</h4><h5 id="单例池"><a href="#单例池" class="headerlink" title="单例池"></a>单例池</h5><p>存放 Spring 启动时创建的非懒加载、非抽象的单例 bean的集合，在单例模式下，调用 getBean(“beanName”)方法都会尝试从单例池中获取对应的 bean 对象。</p>
<h4 id="原型Bean"><a href="#原型Bean" class="headerlink" title="原型Bean"></a>原型Bean</h4><p>Spring 调用 getBean(“beanName”)时，每次返回一个全新的 bean 对象</p>
<h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><p>@Lazy,懒加载的 bean 不是在 Spring 启动的时候创建出来的，而是在第一次调用 getBean 创建的</p>
<h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><h3 id="BeanDefiniton-的定义"><a href="#BeanDefiniton-的定义" class="headerlink" title="BeanDefiniton 的定义"></a>BeanDefiniton 的定义</h3><p>BeanDefinition 是Spring 中 bean 对象的定义，存放的是 bean 对象的属性信息，Spring 也是根据 BeanDefinition 的 bean 对象的定义创建 bean对象的</p>
<h3 id="BeanDefinition-的获取"><a href="#BeanDefinition-的获取" class="headerlink" title="BeanDefinition 的获取"></a>BeanDefinition 的获取</h3><p>BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</p>
<h3 id="BeanDefinition-的作用"><a href="#BeanDefinition-的作用" class="headerlink" title="BeanDefinition 的作用"></a>BeanDefinition 的作用</h3><p>管理和存储 Spring 中 bean 对象的定义，是一个 map 类型的容器，Spring 在启动时会根据 BeanDefinition 中的信息去创建对应的 bean对象。</p>
<h3 id="XmlBeanDefinitonReader"><a href="#XmlBeanDefinitonReader" class="headerlink" title="XmlBeanDefinitonReader"></a>XmlBeanDefinitonReader</h3><p>用于读取 xml 资源文件中关于 bean 对象的定义，提供 bean对象的注册/移除功能</p>
<h3 id="AnnotatedBeanDefinitionReader"><a href="#AnnotatedBeanDefinitionReader" class="headerlink" title="AnnotatedBeanDefinitionReader"></a>AnnotatedBeanDefinitionReader</h3><p>可以直接把某个类转换为BeanDefinition，并且会解析该类上的注解</p>
<p>注：它能解析的注解是：@Conditional，@Scope、@Lazy、@Primary、@DependsOn、@Role、@Description</p>
<h3 id="ClassPathBeanDefinitonScanner"><a href="#ClassPathBeanDefinitonScanner" class="headerlink" title="ClassPathBeanDefinitonScanner"></a>ClassPathBeanDefinitonScanner</h3><p>路径扫描器，扫描指定路径下的类，并将扫描到的具体注解的类加入到 BeanDefinition 容器中，如果没有@Component（@Service、@Controller 等@Component 的子类型注解）则不会加入 BeanDefinition 中.</p>
<p>这个并不是BeanDefinitionReader，但是它的作用和BeanDefinitionReader类似，它可以进行扫描，可以实现对包路径的扫描，并对扫描到的类进行解析如果存在@Component注解，则会把这个类解析为一个BeanDefinition。</p>
<h3 id="MetadataReader-元数据读取器"><a href="#MetadataReader-元数据读取器" class="headerlink" title="MetadataReader 元数据读取器"></a>MetadataReader 元数据读取器</h3><p>所谓元数据，是指：类名、类的注解、类的内部类、实现的方法、父类、被注解的方法，注解的类型等</p>
<p>元数据读取器就是将元数据信息存入 BeanDefinition中</p>
<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>BeanFactory 是一个接口，用于实现创建bean 对象的工厂。</p>
<h4 id="DefaultListableBeanFactory-BeanFactory-的核心实现类"><a href="#DefaultListableBeanFactory-BeanFactory-的核心实现类" class="headerlink" title="DefaultListableBeanFactory-BeanFactory 的核心实现类"></a>DefaultListableBeanFactory-BeanFactory 的核心实现类</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnfd6gqbfjj329m0u0gpu.jpg"></p>
<h2 id="ApplicationContext–功能更加强大的-BeanFactory"><a href="#ApplicationContext–功能更加强大的-BeanFactory" class="headerlink" title="ApplicationContext–功能更加强大的 BeanFactory"></a>ApplicationContext–功能更加强大的 BeanFactory</h2><p><strong>AnnotationConfigApplicationContext</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotationConfigRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register one or more component classes to be processed.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Calls to &#123;<span class="doctag">@code</span> register&#125; are idempotent; adding the same</span></span><br><span class="line"><span class="comment">	 * component class more than once has no additional effect.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> componentClasses one or more component classes,</span></span><br><span class="line"><span class="comment">	 * e.g. &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125; classes</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span></span>;<span class="comment">//  AnnotatedBeanDefinitionReader</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Perform a scan within the specified base packages.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> basePackages the packages to scan for component classes</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">scan</span><span class="params">(String... basePackages)</span></span>;  <span class="comment">// ClassPathBeanDefinitionScanner</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>void register(Class&lt;?&gt;… componentClasses);实现对AnnotatedBeanDefinitionReader的支持</li>
<li>void scan(String… basePackages)实现对ClassPathBeanDefinitionScanner的支持</li>
</ul>
<p>注：无法直接注册单例 bean</p>
<p>ApplicationContext具有的功能：</p>
<ul>
<li>获取系统环境信息</li>
<li>获取 Bean 信息</li>
<li>获取父子工厂 bean</li>
<li>支持国际化 MessageSource</li>
<li>事件发布功能</li>
<li>获取资源文件 getResource</li>
</ul>
<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>Bean的后置处理器，是 Spring 提供给程序员可以在 bean 的生命周期中对创建 bean 的过程进行干预，是属于BeanFactory中一个属性，通过对 BeanPostProcessor内部方的重写，可以在创建 bean的过程中实现跳过部分默认方法或功能。</p>
<h2 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h2><p>Bean工厂的后置处理器，是属于ApplicationContext中的一个属性，是ApplicationContext在实例化一个BeanFactory后，可以利用BeanFactoryPostProcessor继续处理BeanFactory。</p>
<p>通过BeanFactoryPostProcessor间接的设置BeanFactory，比如上文中的CustomEditorConfigurer就是一个BeanFactoryPostProcessor，我们可以通过它向BeanFactory中添加自定义的PropertyEditor。</p>
<h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>特殊的 bean,是个接口,有两个普通的方法和一个默认方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	String OBJECT_TYPE_ATTRIBUTE = <span class="string">&quot;factoryBeanObjectType&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体的使用流程"><a href="#具体的使用流程" class="headerlink" title="具体的使用流程"></a>具体的使用流程</h3><p>调用 FactoryBean 的 getBean 方法会返回 getObject 中的对象，而不是 FactoryBean 这个类型的 Bean，且该对象（Bean）是在第一次 getBean 中生成并放入 FactoryBean 的缓存<code>FactoryBeanObjectCache</code>中。FactoryBean 中的 getObject()<code>相当于产生一个懒加载的 bean</code>。</p>
<p>首先 applicationContext.getBean()从单例池中获取bean，判断这个 bean 是否是实现了 FactoryBean,如果是则通过 getObject 方法返回 bean,否则直接返回单例池中的 bean。</p>
<p>如果需要获取 FactoryBean 这个类的 bean 需要在 beanName加上前缀“&amp;”若干个（Spring 内部会通过 do-while 循环处理掉前缀），源码中会对 beanName 进行判断，是否是获取类类型的 bean 还是 getObject 方法返回的 bean。</p>
<p>注：使用缓存是为了保证 bean对象是单例的。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>整合第三方框架、如 mybatis</p>
<h3 id="与BeanFactory的区别"><a href="#与BeanFactory的区别" class="headerlink" title="与BeanFactory的区别"></a>与BeanFactory的区别</h3><p>BeanFactory 是个创建 Bean 的工厂，可以产生 FactoryBean。产生的 bean 的类型是各种各样的</p>
<p>FactoryBean 小工厂，产生的 bean 是同一个类型</p>
<h3 id="与-bean-的区别"><a href="#与-bean-的区别" class="headerlink" title="与@bean 的区别"></a>与@bean 的区别</h3><p>@bean 功能单一，FactoryBean 可以实现其他接口，扩展更多的功能。</p>
<h3 id="SmartFactoryBean"><a href="#SmartFactoryBean" class="headerlink" title="SmartFactoryBean"></a>SmartFactoryBean</h3><p>是 FactoryBean 的一种实现类，提供了一个判断是否立即初始化的方法</p>
<ul>
<li>isEagerInit()：是否立即初始化，true—-就不是懒加载 bean。</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Unsafe 类的介绍与应用</title>
    <url>/2021/03/07/Unsafe-%E7%B1%BB%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但是 Unsafe具有类似 C 语言操作内存空间的能力，所有会增加程序发生指针问题的风险。</p>
<h1 id="Unsafe-的-API-及相关使用"><a href="#Unsafe-的-API-及相关使用" class="headerlink" title="Unsafe 的 API 及相关使用"></a>Unsafe 的 API 及相关使用</h1><p>JDK 的 rt.jar 包中的 Unsafe 类提供了硬件级别的原子操作，Unsafe 类中的方法都是 native 方法，他们使用的是 JNI 的方式访问本地的 C++实现库。</p>
<p>Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系 统信息获取、内存屏障、数组操作等几类。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gobhkmgclnj31mo0u0alm.jpg"></p>
<h2 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h2><p>这部分主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法。</p>
<h3 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分配内存, 相当于C++的malloc函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//扩充内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">reallocateMemory</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"><span class="comment">//在给定的内存块中设置值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> bytes, <span class="keyword">byte</span> value)</span></span>;</span><br><span class="line"><span class="comment">//内存拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">copyMemory</span><span class="params">(Object srcBase, <span class="keyword">long</span> srcOffset, Object destBase, <span class="keyword">long</span> destOffset, <span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//获取给定地址值，忽略修饰限定符的访问限制。与此类似操作还有: getInt，getDouble，getLong，getChar等</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">getObject</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"><span class="comment">//为给定地址设置值，忽略修饰限定符的访问限制，与此类似操作还有: putInt,putDouble，putLong，putChar等</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"><span class="comment">//为给定地址设置byte类型的值（当且仅当该内存地址为allocateMemory分配	时，此方法结果才是确定的）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putByte</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">byte</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>通常 Java 创建的对象都是在堆中分配内存的，堆内存是交由 JVM进行管理。正常情况下 Java 程序是无法直接使用 JVM 之外的内存空间的，而 Unsafe 提高了开辟堆外内存的方法。</p>
<p><strong>使用堆外内存的目的</strong></p>
<ul>
<li>对垃圾回收停顿的改善。使用堆外内存时，可以保持较小的堆内存规模，从而在 GC 时减少回收停顿对于应用的影响。</li>
<li>提升程序 I/O 操作的性能。</li>
</ul>
<h2 id="CAS相关"><a href="#CAS相关" class="headerlink" title="CAS相关"></a>CAS相关</h2><p>Unsafe 类中与 CAS 相关的 API 主要是以下三个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  CAS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o         包含要修改field的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset    对象中某field的偏移量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expected  期望值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update    更新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>          true | false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="线程调度方面"><a href="#线程调度方面" class="headerlink" title="线程调度方面"></a>线程调度方面</h2><p>Unsafe 在线程调度方面的使用主要体现在线程的挂起恢复以及锁等方面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取消阻塞线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object thread)</span></span>;</span><br><span class="line"><span class="comment">//阻塞线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"><span class="comment">//获得对象锁（可重入锁）</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorEnter</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="comment">//释放对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorExit</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="comment">//尝试获取对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">tryMonitorEnter</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中 park 和 unpark 方法可实现线程的挂起与恢复。LockSupport 的 park 和 unpark 即使用 Unsafe 对应的方法实现阻塞和唤醒的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>在 JDK1.8 中引入的 API，用于定义内存屏障，主要有以下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">loadFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">storeFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止load、store操作重排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">fullFence</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>JDK1.8中引入一种锁的新的机制：StampedLock。可以理解为读写锁的改进版，它提供了一种乐观读锁的实现，这种乐观读锁完全不会阻塞写线程获取写锁，主要是通过它内部的validate 方法校验锁状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns true if the lock has not been exclusively acquired</span></span><br><span class="line"><span class="comment">  * since issuance of the given stamp. Always returns false if the</span></span><br><span class="line"><span class="comment">  * stamp is zero. Always returns true if the stamp represents a</span></span><br><span class="line"><span class="comment">  * currently held lock. Invoking this method with a value not</span></span><br><span class="line"><span class="comment">  * obtained from &#123;<span class="doctag">@link</span> #tryOptimisticRead&#125; or a locking method</span></span><br><span class="line"><span class="comment">  * for this lock has no defined effect or result.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> stamp a stamp</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the lock has not been exclusively acquired</span></span><br><span class="line"><span class="comment">  * since issuance of the given stamp; else false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">     U.loadFence();</span><br><span class="line">     <span class="keyword">return</span> (stamp &amp; SBITS) == (state &amp; SBITS);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>其中 U.loadFence()就是使用 Unsafe 类的与内存屏障相关的方法。</p>
<h1 id="如何使用-Unsafe实例"><a href="#如何使用-Unsafe实例" class="headerlink" title="如何使用 Unsafe实例"></a>如何使用 Unsafe实例</h1><p>由于 Unsafe 的特殊性， 它不能像其他类一样在方法中之间实例化使用。Unsafe类为一单例实现，提供静态方法getUnsafe获取Unsafe实例，<strong>当且仅当调用getUnsafe方法的类为引导类加载器所加载</strong>时才合法，否则抛出SecurityException异常。</p>
<p>所以获取 Unsafe 实例有以下两种方法：</p>
<ul>
<li><p>通过Java命令行命令<code>-Xbootclasspath/a</code>把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过Unsafe.getUnsafe方法安全的获取Unsafe实例。</p>
<p><code>java -Xbootclasspath/a:$&#123;path&#125;</code>   // 其中path为调用Unsafe相关方法的类所在jar包路径 </p>
</li>
<li><p>通过反射获取Unsafe的单例对象,然后再使用其内部的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">reflectGetUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (Unsafe) field.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Unsafe</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 更新语句的执行</title>
    <url>/2023/08/08/%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一条SQL更新语句的执行过程"><a href="#一条SQL更新语句的执行过程" class="headerlink" title="一条SQL更新语句的执行过程"></a>一条SQL更新语句的执行过程</h1><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p>
<p>在InnoDB中 redo log大小是固定的，可以循环写入数据，说白了就是一个环形队列，如下图：</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230808231414204.png" alt="image-20230808231414204"></p>
<p>write pos 是当前记录的位置，一边写一边后移。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>write pos 和 checkpoint 之间的还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“环形队列”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p>
<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 <code>crash-safe</code>。</p>
<h3 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h3><p>Mysql整体其实就两大块：服务层和引擎层，上面说道的redo log是InnoDB特有的日志，而Server层也有自己的日志，即bin log（归档日志）</p>
<p>这两种日志的不同点有：</p>
<ol>
<li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li>
<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=1 这一行的 c 字段加 1 ”。</li>
<li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<p>下面是update语句执行的大体流程图</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230808233447682.png" alt="image-20230808233447682"></p>
<p>在上面的流程图中，有个比较重要的点就是：<strong>两段式提交</strong></p>
<h3 id="两段式提交"><a href="#两段式提交" class="headerlink" title="两段式提交"></a>两段式提交</h3><p>两段式提交出发点就是为了让redolog和binlog直接的逻辑保持一致。binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果要回复过去一段时间的数据，那么备份一定会保存过去一段时间的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，具体的业务场景选择不同的备份策略。通常的做法是找到最新一次全量备份的数据，然后根据binlog对历史操作进行重放。</p>
<p>由于redolog和binlog有着本质的区别，二者有着各自的独立逻辑。如果不进行两段式提交，那么要么先写完redo log再写binog，要么写完binlog再写redolog。</p>
<ol>
<li><strong>先写 redo log 后写 binlog。</strong>假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</li>
<li><strong>先写 binlog 后写 redo log。</strong>如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</li>
</ol>
<p>综上所述：如果先后写入两个log，都有可能会出现数据不一致的情况，这里的不一致是指实际的数据和预期的数据不一致。而采用两段式提交，由于redolog和binlog具有一定的关联，在恢复数据时，redolog用于恢复主机故障时的未更新的物理数据，binlog用于备份操作。每个阶段的log操作都是记录在磁盘的，在恢复数据时，<strong>redolog 状态为commit则说明binlog也成功，直接恢复数据；如果redolog是prepare，则需要查询对应的binlog事务是否成功，决定是回滚还是执行。</strong></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL 查询语句的执行</title>
    <url>/2023/08/07/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一条SQL查询语句的执行过程"><a href="#一条SQL查询语句的执行过程" class="headerlink" title="一条SQL查询语句的执行过程"></a>一条SQL查询语句的执行过程</h1><h2 id="MySQL逻辑架构图"><a href="#MySQL逻辑架构图" class="headerlink" title="MySQL逻辑架构图"></a>MySQL逻辑架构图</h2><p><img src="https://raw.githubusercontent.com/he-You/image/master/MySQL%E7%9A%84%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="image-20230807224200391"></p>
<p>从上图可以看出，MySQL大体可以分为两个部分：<code>Server层</code>和<code>存储引擎层</code></p>
<p>其中Server层包括：</p>
<ul>
<li>连接器</li>
<li>查询缓存（上图未画出，8.0版本去掉了）</li>
<li>分析器</li>
<li>优化器</li>
<li>执行器</li>
<li>所有的内置函数，以及不依赖存储引擎的功能（如存储过程、触发器、视图）</li>
</ul>
<p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB。</p>
<p>下面将逐一介绍Server层各个组件的作用</p>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>顾名思义，就是用来和客户端建立连接、获取权限、维持和管理连接的组件。这里的权限主要是验证访问数据库的权限，而详细的权限验证是在优化器优化阶段进行的。</p>
<p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，可以在 show processlist 命令中看到它，其中Command列显示为“Sleep”的这一行，就表示现在系统里面有空闲的连接</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230807231559390.png" alt="image-20230807231559390"></p>
<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。</p>
<p>既然提到连接器，这里不得不说<code>长连接</code>和<code>短连接</code></p>
<ul>
<li>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。</li>
<li>短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</li>
</ul>
<p>建立连接的过程通常是比较复杂的，所以在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。但是全部使用长连接后，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。</p>
<p>所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p>
<p>为了解决这个问题，有如下两种方案：</p>
<ol>
<li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li>
<li>可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态</li>
</ol>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>分析器主要就做以下两个工作</p>
<ol>
<li>词法分析：分析传入的字符串是什么</li>
<li>语法分析：分析语句是否合法</li>
</ol>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c&#x3D;10 and t2.d&#x3D;20;</span><br></pre></td></tr></table></figure>

<p>在上面的查询语句中：</p>
<p>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</p>
<p>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</p>
<p>优化器的作用就是：当存在不同的执行方案时，优化器会决定使用哪个方案，使得SQL执行的效率更高。</p>
<p>当优化器选择好执行方案后，便进入了执行器阶段</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>用来真正执行语句。在开始执行语句前会先判断是否具有表级权限，权限验证通过后开始执行，执行器调用存储引擎将满足条件的结果集，返回给客户端。</p>
<p>至此，一条查询语句执行完毕。</p>
<h2 id="InnoDB执行过程"><a href="#InnoDB执行过程" class="headerlink" title="InnoDB执行过程"></a>InnoDB执行过程</h2><p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230908110344128.png" alt="image-20230908110344128"></p>
<ol>
<li>从磁盘中加载数据到缓冲池中，加载目标记录数据所在的页的整页数据。数据库的CRUD操作都是直接操作buffer pool,一般buffer pool的大小设置为机器内存的60~70%左右</li>
<li>将旧的数据写入undolog,便于出现问题时进行事务回滚</li>
<li>将新值更新到缓冲池中</li>
<li>MySQL服务端执行器写入redolog到redolog缓冲</li>
<li>redolog顺序写入磁盘，准备提交事务</li>
<li>binlog写入磁盘</li>
<li>写入commit标记到redo日志文件中，提交事务完成，该标记为了保证事务提交后redolog与binlog数据一致</li>
<li>在系统空闲时，将buffer pool中的数据以页为单位随机写入磁盘</li>
</ol>
<h3 id="什么是redolog和binglog？"><a href="#什么是redolog和binglog？" class="headerlink" title="什么是redolog和binglog？"></a>什么是redolog和binglog？</h3><table>
<thead>
<tr>
<th></th>
<th>redo log</th>
<th>bin log</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>物理日志，即数据页中的真实二级制数据，恢复速度快</td>
<td>逻辑日志，即sql语句，因需要逐条执行，恢复速度慢</td>
</tr>
<tr>
<td>存储格式</td>
<td>nnodb存储引擎数据的单位是页，redo log也是基于页进行存储，一页默认16k</td>
<td>statement：SQL语句的形式<br />row：记录相关行的每一列的值（官方推荐）</td>
</tr>
<tr>
<td>主要用途</td>
<td>重做数据页</td>
<td>数据复制</td>
</tr>
<tr>
<td>所在层级</td>
<td>innodb存储引擎中</td>
<td>MySQL服务端</td>
</tr>
</tbody></table>
<h3 id="redo-log-写入磁盘过程"><a href="#redo-log-写入磁盘过程" class="headerlink" title="redo log 写入磁盘过程"></a>redo log 写入磁盘过程</h3><p>redo log 从头开始写，写完一个文件继续写另一个文件，写到最后一个文件末尾就又回到第一个文件开头循环写，如 下面这个图所示。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230908133854191.png" alt="image-20230908133854191"></p>
<p>其中：</p>
<ol>
<li>write pos 是记录当前记录的位置，一边写一边移动，四个文件写满后，重新回到第一个文件进行写入</li>
<li>check point是当前要擦除的位置，也是往后进行移动的，擦除记录前要把记录更新到数据文件里。</li>
</ol>
<p>write pos 和 checkpoint 之间的部分就是空着的可写部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示redo log写满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一 下。</p>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>需要两阶段提交机制的原因：如果redo log持久化并进行了提交，而binlog未持久化数据库就crash了，则从库从binlog拉取数据会少于主库，造成不一致。因此需要内部事务来保证两种日志的一致性。</p>
<ul>
<li>prepare：redolog写入log buffer，并fsync持久化到磁盘，在redolog事务中记录2PC的XID，在redolog事务打上prepare标识</li>
<li>commit：binlog写入log buffer，并fsync持久化到磁盘，在binlog事务中记录2PC的XID，同时在redolog事务打上commit标识</li>
</ul>
<p>其中，prepare和commit阶段所提到的“事务”，都是指内部XA事务，即2PC</p>
<h4 id="两阶段提交的属性差异"><a href="#两阶段提交的属性差异" class="headerlink" title="两阶段提交的属性差异"></a>两阶段提交的属性差异</h4><ul>
<li><strong>先写 redo log 后写 binlog：</strong>假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启，由于 binlog 没写完就 crash 了，如果用 binlog 来恢复临时库的话，与原库的值不同</li>
<li><strong>先写 binlog 后写 redo log：</strong>如果 binlog 写完之后 crash，redo log 还没写，崩溃恢复以后这个事务无效，恢复出来的这一行与原库的值不同，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>关于Spring的bean</title>
    <url>/2020/09/12/%E5%85%B3%E4%BA%8ESpring%E7%9A%84bean/</url>
    <content><![CDATA[<p>Spring中的bean默认都是单例的,Spring的单例是基于BeanFactory也就是Spring容器的，单例Bean在此容器内只有一个，Java的单例是基于 JVM，每个 JVM 内只有一个实例。</p>
<h1 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h1><p>创建一个bean定义，其实质是用该bean定义对应的类来创建真正实例的“配方”。<br>把bean定义看成一个配方很有意义，它与class很类似，只根据一张“处方”就可以创建多个实例。<br>不仅可以控制注入到对象中的各种依赖和配置值，还可以控制该对象的作用域。<br>这样可以灵活选择所建对象的作用域，<br>而不必在Java Class级定义作用域。Spring Framework支持五种作用域，分别阐述如下表。</p>
<p>五种作用域中，request、session 和 global session 三种作用域仅在基于web的应用中使用，只能用在基于 web 的 Spring ApplicationContext 环境。</p>
<h2 id="singleton——唯一-bean-实例"><a href="#singleton——唯一-bean-实例" class="headerlink" title="singleton——唯一 bean 实例"></a><strong>singleton——唯一 bean 实例</strong></h2><p>当一个 bean 的作用域为 singleton，那么Spring IoC容器中只会存在一个共享的 bean 实例，并且所有对 bean 的请求，只要 id 与该 bean 定义相匹配，则只会返回bean的同一实例。 singleton 是单例类型(对应于单例模式)，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，但我们可以指定Bean节点的 lazy-init=”true” 来延迟初始化bean，这时候，只有在第一次获取bean时才会初始化bean，即第一次请求该bean时才初始化。 每次获取到的对象都是同一个对象。注意，singleton 作用域是Spring中的缺省作用域。要在XML中将 bean 定义成 singleton ，可以这样配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;ServiceImpl&quot; class&#x3D;&quot;cn.csdn.service.ServiceImpl&quot; scope&#x3D;&quot;singleton&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>也可以通过 @Scope 注解（它可以显示指定bean的作用范围。）的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Scope(&quot;singleton&quot;)</span><br><span class="line">public class ServiceImpl&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prototype——每次请求都会创建一个新的-bean-实例"><a href="#prototype——每次请求都会创建一个新的-bean-实例" class="headerlink" title="prototype——每次请求都会创建一个新的 bean 实例"></a><strong>prototype——每次请求都会创建一个新的 bean 实例</strong></h2><p>当一个bean的作用域为 prototype，表示一个 bean 定义对应多个对象实例。<br>prototype 作用域的 bean 会导致在每次对该 bean 请求（将其注入到另一个 bean 中，或者以程序的方式调用容器的 getBean() 方法<strong>）<br>时都会创建一个新的 bean 实例。prototype 是原型类型，<br>它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而<br>**且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的 bean 应该使用 prototype 作用域，<br>而对无状态的 bean 则应该使用 singleton 作用域。</strong> 在 XML 中将 bean 定义成 prototype ，可以这样配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;account&quot; class&#x3D;&quot;com.foo.DefaultAccount&quot; scope&#x3D;&quot;prototype&quot;&#x2F;&gt;  </span><br><span class="line"> 或者</span><br><span class="line">&lt;bean id&#x3D;&quot;account&quot; class&#x3D;&quot;com.foo.DefaultAccount&quot; singleton&#x3D;&quot;false&quot;&#x2F;&gt; </span><br></pre></td></tr></table></figure>
<p>注解方式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">public class ServiceImpl&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>request——每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效<br>request只适用于Web程序，每一次 HTTP 请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效，<br>当请求结束后，该对象的生命周期即告结束。 在 XML 中将 bean 定义成 request ，可以这样配置：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;loginAction&quot; class&#x3D;cn.csdn.LoginAction&quot; scope&#x3D;&quot;request&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure></li>
<li>session——每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效<br>session只适用于Web程序，session 作用域表示该针对每一次 HTTP 请求都会产生一个新的 bean，<br>同时该 bean 仅在当前 HTTP session 内有效.<br>与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，<br>而别的 HTTP session 中根据 userPreferences 创建的实例，<br>将不会看到这些特定于某个 HTTP session 的状态变化。当HTTP session最终被废弃的时候，<br>在该HTTP session作用域内的bean也会被废弃掉。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userPreferences&quot; class&#x3D;&quot;com.foo.UserPreferences&quot; scope&#x3D;&quot;session&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure></li>
<li>globalSession<br>global session 作用域类似于标准的 HTTP session 作用域，<br>不过仅仅在基于 portlet 的 web 应用中才有意义。<br>Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portle t所共享。<br>在global session 作用域中定义的 bean 被限定于全局portlet Session的生命周期范围内。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.foo.Preferences &quot;scope&#x3D;&quot;globalSession&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h1><p>实现<em>Aware接口 在Bean中使用Spring框架的一些对象</em><br>有些时候我们需要在 Bean 的初始化中使用 Spring 框架自身的一些对象来执行一些操作，比如获取 ServletContext 的一些参数，获取 ApplicaitionContext 中的 BeanDefinition 的名字，获取 Bean 在容器中的名字等等。为了让 Bean 可以获取到框架自身的一些对象，Spring 提供了一组名为*Aware的接口。</p>
<p>这些接口均继承于org.springframework.beans.factory.Aware标记接口，并提供一个将由 Bean 实现的set*方法,Spring通过基于setter的依赖注入方式使相应的对象可以被Bean使用。 网上说，这些接口是利用观察者模式实现的，类似于servlet listeners，目前还不明白，不过这也不在本文的讨论范围内。 介绍一些重要的Aware接口：</p>
<ul>
<li>ApplicationContextAware: 获得ApplicationContext对象,可以用来获取所有Bean definition的名字。</li>
<li>BeanFactoryAware:获得BeanFactory对象，可以用来检测Bean的作用域。</li>
<li>BeanNameAware:获得Bean在配置文件中定义的名字。</li>
<li>ResourceLoaderAware:获得ResourceLoader对象，可以获得classpath中某个文件。</li>
<li>ServletContextAware:在一个MVC应用中可以获取ServletContext对象，可以读取context中的参数。</li>
<li>ServletConfigAware： 在一个MVC应用中可以获取ServletConfig对象，可以读取config中的参数。</li>
</ul>
<p>BeanPostProcessor<br>上面的*Aware接口是针对某个实现这些接口的Bean定制初始化的过程， Spring同样可以针对容器中的所有Bean，<br>或者某些Bean定制初始化过程，只需提供一个实现BeanPostProcessor接口的类即可。<br>该接口中包含两个方法，postProcessBeforeInitialization和postProcessAfterInitialization。<br>postProcessBeforeInitialization方法会在容器中的Bean初始化之前执行，postProcessAfterInitialization方法在容器中的Bean初始化之后执行。</p>
<p>要将BeanPostProcessor的Bean像其他Bean一样定义在配置文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean class&#x3D;&quot;com.giraffe.spring.service.CustomerBeanPostProcessor&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>Spring Bean的生命周期是这样的：</p>
<ul>
<li>Bean容器找到配置文件中 Spring Bean 的定义。</li>
<li>Bean容器利用Java Reflection API创建一个Bean的实例。</li>
<li>如果涉及到一些属性值 利用set方法设置一些属性值。</li>
<li>如果Bean实现了BeanNameAware接口，调用setBeanName()方法，传入Bean的名字。</li>
<li>如果Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。</li>
<li>如果Bean实现了BeanFactoryAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。</li>
<li>与上面的类似，如果实现了其他*Aware接口，就调用相应的方法。</li>
<li>如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessBeforeInitialization()方法</li>
<li>如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。</li>
<li>如果Bean在配置文件中的定义包含init-method属性，执行指定的方法。</li>
<li>如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessAfterInitialization()方法</li>
<li>当要销毁Bean的时候，如果Bean实现了DisposableBean接口，执行destroy()方法。</li>
<li>当要销毁Bean的时候，如果Bean在配置文件中的定义包含destroy-method属性，执行指定的方法。</li>
</ul>
<p>图:<br><img src="../spring/img/SpringBean.png"><br>或:<br><img src="../spring/img/SpringBean2.png"></p>
<p>其实很多时候我们并不会真的去实现上面说描述的那些接口，那么下面我们就除去那些接口，针对bean的单例和非单例来描述下bean的生命周期：</p>
<p><strong>单例管理的对象</strong><br>当scope=”singleton”，即默认情况下，会在启动容器时（即实例化容器时）时实例化。<br>但我们可以指定Bean节点的lazy-init=”true”来延迟初始化bean，<br>这时候，只有在第一次获取bean时才会初始化bean，即第一次请求该bean时才初始化。<br>如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;ServiceImpl&quot; class&#x3D;&quot;cn.csdn.service.ServiceImpl&quot; lazy-init&#x3D;&quot;true&quot;&#x2F;&gt;  </span><br></pre></td></tr></table></figure>
<p>如果想对所有的默认单例bean都应用延迟初始化，可以在根节点beans设置default-lazy-init属性为true，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;beans default-lazy-init&#x3D;&quot;true&quot; …&gt;</span><br></pre></td></tr></table></figure>
<p>默认情况下，Spring 在读取 xml 文件的时候，就会创建对象。在创建对象的时候先调用构造器，然后调用 init-method 属性值中所指定的方法。对象在被销毁的时候，会调用 destroy-method 属性值中所指定的方法（例如调用Container.destroy()方法的时候）。</p>
<p><strong>非单例管理的对象</strong><br>当scope=”prototype”时，容器也会延迟初始化 bean，Spring 读取xml 文件的时候，<br>并不会立刻创建对象，而是在第一次请求该 bean 时才初始化（如调用getBean方法时）。<br>在第一次请求每一个 prototype 的bean 时，Spring容器都会调用其构造器创建这个对象，<br>然后调用init-method属性值中所指定的方法。<br>对象销毁的时候，Spring 容器不会帮我们调用任何方法，因为是非单例，<br>这个类型的对象有很多个，Spring容器一旦把这个对象交给你之后，就不再管理这个对象了。</p>
<p>为了测试prototype bean的生命周期life.xml配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;life_prototype&quot; class&#x3D;&quot;com.bean.LifeBean&quot; scope&#x3D;&quot;prototype&quot; init-method&#x3D;&quot;init&quot; destroy-method&#x3D;&quot;destory&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>测试程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LifeTest &#123;</span><br><span class="line">    @Test </span><br><span class="line">    public void test() &#123;</span><br><span class="line">        AbstractApplicationContext container &#x3D; new ClassPathXmlApplicationContext(&quot;life.xml&quot;);</span><br><span class="line">        LifeBean life1 &#x3D; (LifeBean)container.getBean(&quot;life_singleton&quot;);</span><br><span class="line">        System.out.println(life1);</span><br><span class="line"></span><br><span class="line">        LifeBean life3 &#x3D; (LifeBean)container.getBean(&quot;life_prototype&quot;);</span><br><span class="line">        System.out.println(life3);</span><br><span class="line">        container.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LifeBean()构造函数</span><br><span class="line">this is init of lifeBean</span><br><span class="line">com.bean.LifeBean@573f2bb1</span><br><span class="line">LifeBean()构造函数</span><br><span class="line">this is init of lifeBean</span><br><span class="line">com.bean.LifeBean@5ae9a829</span><br><span class="line">……</span><br><span class="line">this is destory of lifeBean com.bean.LifeBean@573f2bb1</span><br></pre></td></tr></table></figure>

<p>可以发现，对于作用域为 prototype 的 bean ，其destroy方法并没有被调用。<br>如果 bean 的 scope 设为prototype时，当容器关闭时，destroy 方法不会被调用。<br>对于 prototype 作用域的 bean，有一点非常重要，那就是 Spring不能对一个 prototype bean 的整个生命周期负责：<br>容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就对该prototype实例不闻不问了。<br>不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法。<br>但对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用。清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，<br>都是客户端代码的职责（让Spring容器释放被prototype作用域bean占用资源的一种可行方式是，通过使用bean的后置处理器，<br>该处理器持有要被清除的bean的引用）。谈及prototype作用域的bean时，<br>在某些方面你可以将Spring容器的角色看作是Java new操作的替代者，任何迟于该时间点的生命周期事宜都得交由客户端来处理。</p>
<p>Spring 容器可以管理 singleton 作用域下 bean 的生命周期，在此作用域下，Spring 能够精确地知道bean何时被创建，何时初始化完成，以及何时被销毁。<br>而对于 prototype 作用域的bean，Spring只负责创建，当容器创建了 bean 的实例后，bean 的实例就交给了客户端的代码管理，<br>Spring容器将不再跟踪其生命周期，并且不会管理那些被配置成prototype作用域的bean的生命周期。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBean</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发编程（三）synchronized 关键字</title>
    <url>/2020/12/21/synchronized%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="synchronized-的使用及实现原理"><a href="#synchronized-的使用及实现原理" class="headerlink" title="synchronized 的使用及实现原理"></a>synchronized 的使用及实现原理</h1><h2 id="synchronized关键字的使用"><a href="#synchronized关键字的使用" class="headerlink" title="synchronized关键字的使用"></a>synchronized关键字的使用</h2><h3 id="利用-synchronized-实现同步的-3-种形式"><a href="#利用-synchronized-实现同步的-3-种形式" class="headerlink" title="利用 synchronized 实现同步的 3 种形式"></a>利用 synchronized 实现同步的 3 种形式</h3><h4 id="对于普通的同步方法，锁的是当前实例对象"><a href="#对于普通的同步方法，锁的是当前实例对象" class="headerlink" title="对于普通的同步方法，锁的是当前实例对象"></a>对于普通的同步方法，锁的是当前实例对象</h4><p>所谓的实例对象锁就是用synchronized修饰实例对象中的实例方法(非静态方法)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSync</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//共享资源(临界资源)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * synchronized 修饰实例方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AccountingSync instance=<span class="keyword">new</span> AccountingSync();</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出结果:</span></span><br><span class="line"><span class="comment">     * 2000000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对于静态同步方法，锁的是当前类的-Class-对象"><a href="#对于静态同步方法，锁的是当前类的-Class-对象" class="headerlink" title="对于静态同步方法，锁的是当前类的 Class 对象"></a>对于静态同步方法，锁的是当前类的 Class 对象</h4><p>由于静态成员不专属于任何一个实例对象，是类成员，因此通过class对象锁可以控制静态 成员的并发操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSyncClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作用于静态方法,锁是当前class对象,也就是</span></span><br><span class="line"><span class="comment">     * AccountingSyncClass类对应的class对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非静态,访问时锁不一样不会发生互斥</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase4Obj</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//new新实例</span></span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncClass());</span><br><span class="line">        <span class="comment">//new心事了</span></span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncClass());</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();t2.start();</span><br><span class="line"></span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：如果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，不会发生互斥现象，因为<strong>访问静态 synchronized 方法占用的锁是当前类的class对象</strong>，而访问<strong>非静态 synchronized 方法占用的锁是当前实例对象锁</strong>，毕竟锁的对象是不一样的。</p>
<h4 id="对于同步方法块，锁的是-Synchronized-括号里配置的对象"><a href="#对于同步方法块，锁的是-Synchronized-括号里配置的对象" class="headerlink" title="对于同步方法块，锁的是 Synchronized 括号里配置的对象"></a>对于同步方法块，锁的是 Synchronized 括号里配置的对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSync</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AccountingSync instance=<span class="keyword">new</span> AccountingSync();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略其他耗时操作....</span></span><br><span class="line">        <span class="comment">//使用同步代码块对变量i进行同步操作,锁对象为instance</span></span><br><span class="line">        <span class="keyword">synchronized</span>(instance)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="synchronized的实现原理"><a href="#synchronized的实现原理" class="headerlink" title="synchronized的实现原理"></a>synchronized的实现原理</h2><p>一句话总结：JVM 是基于进入和退出 Monitor 对象实现方法同步和代码块同步的；但是二者的实现细节是不一样的。</p>
<h3 id="synchronized代码块底层原理"><a href="#synchronized代码块底层原理" class="headerlink" title="synchronized代码块底层原理"></a>synchronized代码块底层原理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncCodeBlock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//同步代码</span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 javap 对上述代码进行反编译得到字节码文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">heyou</span>.<span class="title">concurrency</span>.<span class="title">demo</span>.<span class="title">SyncCodeBlock</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">  <span class="comment">//........省略常量池中数据</span></span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="keyword">public</span> com.zejian.concurrencys.SyncCodeBlock();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">  <span class="comment">//===========syncTask方法实现================</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: monitorenter  <span class="comment">//注意此处，进入同步方法</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: dup</span><br><span class="line">         6: getfield      #2             // Field i:I</span><br><span class="line">         <span class="number">9</span>: iconst_1</span><br><span class="line">        <span class="number">10</span>: iadd</span><br><span class="line">        11: putfield      #2            // Field i:I</span><br><span class="line">        <span class="number">14</span>: aload_1</span><br><span class="line">        <span class="number">15</span>: monitorexit   <span class="comment">//注意此处，退出同步方法</span></span><br><span class="line">        <span class="number">16</span>: goto          <span class="number">24</span></span><br><span class="line">        <span class="number">19</span>: astore_2</span><br><span class="line">        <span class="number">20</span>: aload_1</span><br><span class="line">        <span class="number">21</span>: monitorexit <span class="comment">//注意此处，退出同步方法</span></span><br><span class="line">        <span class="number">22</span>: aload_2</span><br><span class="line">        <span class="number">23</span>: athrow</span><br><span class="line">        <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">      <span class="comment">//省略其他字节码.......</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;SyncCodeBlock.java&quot;</span></span><br></pre></td></tr></table></figure>

<p>从上述字节码文件可知：</p>
<ul>
<li>同步语句块使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置</li>
<li>当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功</li>
<li>方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，<strong>编译器会自动产生一个异常处理器</strong>，这个异常处理器声明可处理所有的异常，它的<u><strong>目的就是用来执行 monitorexit 指令</strong></u>。从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。</li>
</ul>
<h3 id="synchronized方法底层原理"><a href="#synchronized方法底层原理" class="headerlink" title="synchronized方法底层原理"></a>synchronized方法底层原理</h3><p><strong>方法级的同步是隐式，即无需通过字节码指令来控制</strong>的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 <strong>ACC_SYNCHRONIZED</strong> 访问标志区分一个方法是否同步方法。</p>
<p>当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor， 然后再执行方法，最后在方法完成(无论是正常完成还是非正常完成)时释放monitor。</p>
<p>在方法执行期间，执行线程持有了monitor，独占 monitor 对象，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个<strong>同步方法所持有的monitor将在异常抛到同步方法之外时自动释放</strong>。</p>
<p>注：Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的<strong>操作系统的Mutex Lock</strong>来实现的，而操作系统实现线程之间的切换时需要<strong>从用户态转换到内核态</strong>，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。</p>
<p>TIPS:</p>
<blockquote>
<p>内核态和用户态的概念，是Linux为了有效实现CPU的权限分级和数据隔离的目标而出现的，是通过组合CPU的分段机制+分页机制而形成的。还是以X86_64架构为例，在当CPU处于保护模式下时（X86_64CPU有5种模式，保护模式是其中之一，此时CPU.CR0.PE=1），当CPU.CS=系统代码段时（CS.CPL=0）为内核态，此时通过CPU的指令有操控全部寄存器的权限（包括FLAGS和CR寄存器），当CPU.CS=用户代码段时（CS.CPL=3）为用户态，此时通过CPU的指令只有操控部分寄存器的权限。</p>
</blockquote>
<p>总之：</p>
<ul>
<li>用户态和内核态是用来 CPU 权限分级和数据隔离的一种实现（分段机制+分页机制）</li>
<li>CPU.CS=系统代码段时（CS.CPL=0）为内核态</li>
<li>CPU.CS=用户代码段时（CS.CPL=3）为用户态</li>
<li>内核态权限&gt;用户态</li>
</ul>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优雅的构建请求路径</title>
    <url>/2020/09/16/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E6%9E%84%E5%BB%BA%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>UriComponentsBuilder 是 Spring 提供的一个 UriComponents 类的构建类,通过他可以方便的构建我们请求的 url</p>
<h3 id="UriComponentsBuilder的主要属性"><a href="#UriComponentsBuilder的主要属性" class="headerlink" title="UriComponentsBuilder的主要属性"></a>UriComponentsBuilder的主要属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 协议：HTTP/HTTPS</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> String scheme;</span><br><span class="line"><span class="comment">// 协议特定部分,用来处理一些特殊协议,http协议用不到</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> String ssp;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> String userInfo;</span><br><span class="line"><span class="comment">// 域名</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> String host;</span><br><span class="line"><span class="comment">// 端口</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> UriComponentsBuilder.CompositePathComponentBuilder pathBuilder;</span><br><span class="line"><span class="comment">// 查询参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MultiValueMap&lt;String, String&gt; queryParams = <span class="keyword">new</span> LinkedMultiValueMap();</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> String fragment;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; uriVariables = <span class="keyword">new</span> HashMap(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> encodeTemplate;</span><br><span class="line"><span class="keyword">private</span> Charset charset;</span><br></pre></td></tr></table></figure>

<h3 id="实例化静态方法"><a href="#实例化静态方法" class="headerlink" title="实例化静态方法"></a>实例化静态方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UriComponentsBuilder <span class="title">newInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UriComponentsBuilder <span class="title">fromPath</span><span class="params">(String path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UriComponentsBuilder <span class="title">fromUri</span><span class="params">(URI uri)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UriComponentsBuilder <span class="title">fromUriString</span><span class="params">(String uri)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UriComponentsBuilder <span class="title">fromHttpUrl</span><span class="params">(String httpUrl)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UriComponentsBuilder <span class="title">fromHttpRequest</span><span class="params">(HttpRequest request)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UriComponentsBuilder <span class="title">fromOriginHeader</span><span class="params">(String origin)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="构建示例"><a href="#构建示例" class="headerlink" title="构建示例:"></a>构建示例:</h3><ul>
<li>构建完整的 url</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UriComponents uriComponents = UriComponentsBuilder.newInstance()</span><br><span class="line">                .scheme(<span class="string">&quot;http&quot;</span>)</span><br><span class="line">                .host(<span class="string">&quot;www.github.com&quot;</span>)</span><br><span class="line">                .path(<span class="string">&quot;/he-You&quot;</span>)</span><br><span class="line">                .queryParam(<span class="string">&quot;query&quot;</span>,<span class="string">&quot;userName&quot;</span>)</span><br><span class="line">                .encode();</span><br><span class="line">        System.out.println(uriComponents.toString());</span><br></pre></td></tr></table></figure>

<ul>
<li>构建模板 url</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UriComponents uriComponents = UriComponentsBuilder.newInstance()</span><br><span class="line">                .scheme(<span class="string">&quot;http&quot;</span>).host(<span class="string">&quot;www.github.com&quot;</span>)</span><br><span class="line">                .path(<span class="string">&quot;/he-You&quot;</span>)</span><br><span class="line">                .path(<span class="string">&quot;/&#123;project&#125;&quot;</span>)</span><br><span class="line">                .path(<span class="string">&quot;/category/&#123;booking&#125;&quot;</span>)</span><br><span class="line">                .build()</span><br><span class="line">                .expand(<span class="string">&quot;42&quot;</span>, <span class="string">&quot;21&quot;</span>)</span><br><span class="line">                .encode();</span><br><span class="line">        System.out.println(uriComponents.toString());</span><br></pre></td></tr></table></figure>

<p>打印结果：<a href="http://github.com/he-You/42/category/21">http://github.com/he-You/42/category/21</a></p>
<p>expand 有多个实现,支持传入可变参数和Map.</p>
<ul>
<li>构建编码的 url</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UriComponents uriComponents = UriComponentsBuilder.newInstance()</span><br><span class="line">                .scheme(<span class="string">&quot;http&quot;</span>).host(<span class="string">&quot;www.github.com&quot;</span>)</span><br><span class="line">                .path(<span class="string">&quot;/he-You&quot;</span>)</span><br><span class="line">                .path(<span class="string">&quot;/&#123;project&#125;&quot;</span>)</span><br><span class="line">                .path(<span class="string">&quot;/category/&#123;booking&#125;&quot;</span>)</span><br><span class="line">                .build()</span><br><span class="line">                .expand(<span class="string">&quot;42&quot;</span>, <span class="string">&quot;21&quot;</span>)</span><br><span class="line">                .encode(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(uriComponents.toString());</span><br></pre></td></tr></table></figure>

<h3 id="在-Servlet-环境中"><a href="#在-Servlet-环境中" class="headerlink" title="在 Servlet 环境中"></a>在 Servlet 环境中</h3><p>使用子类ServletUriComponentsBuilder提供的静态工厂方法可以从一个Servlet request中获取有用的URI信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpServletRequest request = ...</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Re-use host, scheme, port, path and query string</span></span><br><span class="line"><span class="comment">// Replace the &quot;accountId&quot; query param</span></span><br><span class="line"> </span><br><span class="line">ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromRequest(request)</span><br><span class="line">        .replaceQueryParam(<span class="string">&quot;accountId&quot;</span>, <span class="string">&quot;&#123;id&#125;&quot;</span>).build()</span><br><span class="line">        .expand(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">        .encode();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析volatile</title>
    <url>/2020/09/10/%E6%B5%85%E6%9E%90volatile/</url>
    <content><![CDATA[<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>1 . 保证了不同线程对该变量操作的内存可见性;<br>2 . 禁止指令重排序</p>
<p>JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，<br>通过解决这三个问题，可以解除缓存不一致的问题。而volatile跟可见性和有序性都有关。</p>
<p>1 . **原子性(Atomicity)**： Java中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要做一定做完，要么就没有执行。<br>例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i &#x3D; 2;</span><br><span class="line">j &#x3D; i;</span><br><span class="line">i++;</span><br><span class="line">i &#x3D; i + 1；</span><br></pre></td></tr></table></figure>

<p>上面4个操作中，<br>i=2是读取操作，必定是原子性操作，<br>j=i你以为是原子性操作，其实吧，分为两步，一是读取i的值，然后再赋值给j,这就是2步操作了，称不上原子操作，<br>i++和i = i + 1其实是等效的，读取i的值，加1，再写回主存，那就是3步操作了。</p>
<p>所以上面的举例中，最后的值可能出现多种情况，就是因为满足不了原子性。<br>这么说来，只有简单的读取，赋值是原子操作，还只能是用数字赋值，用变量的话还多了一步读取变量值的操作。<br>有个例外是，虚拟机规范中允许对64位数据类型(long和double)，分为2次32为的操作来处理，但是最新JDK实现还是实现了原子操作的。<br>JMM只实现了基本的原子性，像上面i++那样的操作，<strong>必须借助于synchronized和Lock来保证整块代码的原子性了</strong>。<br>线程在释放锁之前，必然会把i的值刷回到主存的。</p>
<p>2 . 可见性(Visibility)：<br>说到可见性，Java就是利用volatile来提供可见性的。<br>当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。<br>其实通过synchronized和Lock也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是synchronized和Lock的开销都更大。</p>
<p>3 . 有序性（Ordering）</p>
<p>JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double pi &#x3D; 3.14;    &#x2F;&#x2F;A</span><br><span class="line">double r &#x3D; 1;        &#x2F;&#x2F;B</span><br><span class="line">double s&#x3D; pi * r * r;&#x2F;&#x2F;C</span><br></pre></td></tr></table></figure>
<p>上面的语句，可以按照A-&gt;B-&gt;C执行，结果为3.14,但是也可以按照B-&gt;A-&gt;C的顺序执行，因为A、B是两句独立的语句，<br>而C则依赖于A、B，所以A、B可以重排序，但是C却不能排到A、B的前面。<br>JMM保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。</p>
<p>JMM具备一些先天的有序性,即不需要通过任何手段就可以保证的有序性，通常称为happens-before原则。<br>&lt;&lt;JSR-133：Java Memory Model and Thread Specification&gt;&gt;<br>定义了如下happens-before规则：</p>
<ul>
<li>程序顺序规则： 一个线程中的每个操作，happens-before于该线程中的任意后续操作</li>
<li>监视器锁规则：对一个线程的解锁，happens-before于随后对这个线程的加锁</li>
<li>volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读</li>
<li>传递性：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C</li>
<li>start()规则： 如果线程A执行操作ThreadB_start()(启动线程B) ,  那么A线程的ThreadB_start()happens-before 于B中的任意操作</li>
<li>join()原则： 如果A执行ThreadB.join()并且成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
<li>interrupt()原则： 对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生</li>
<li>finalize()原则：一个对象的初始化完成先行发生于它的finalize()方法的开始</li>
</ul>
<p>第1条规则程序顺序规则是说在一个线程里，所有的操作都是按顺序的，但是在JMM里其实只要执行结果一样，是允许重排序的，这边的happens-before强调的重点也是单线程执行结果的正确性，但是无法保证多线程也是如此。<br>第2条规则监视器规则其实也好理解，就是在加锁之前，确定这个锁之前已经被释放了，才能继续加锁。<br>第3条规则，就适用到所讨论的volatile，如果一个线程先去写一个变量，另外一个线程再去读，那么写入操作一定在读操作之前。<br>第4条规则，就是happens-before的传递性。</p>
<p>从内存语义上来看</p>
<p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存</p>
<p>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</p>
<h4 id="volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？"><a href="#volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？" class="headerlink" title="volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？"></a>volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？</h4><p>要想保证原子性，只能借助于synchronized,Lock以及并发包下的atomic的原子操作类了，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。</p>
<h4 id="volatile底层的实现机制"><a href="#volatile底层的实现机制" class="headerlink" title="volatile底层的实现机制"></a>volatile底层的实现机制</h4><p>如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。<br>lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能:</p>
<p>1 . 重排序时不能把后面的指令重排序到内存屏障之前的位置<br>2 . 使得本CPU的Cache写入内存<br>3 . 写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。</p>
<p>举例:<br>状态量标记，就如上面对flag的标记：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span></span>&#123;  </span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">volatile</span> bool flag = <span class="keyword">false</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">          a = <span class="number">2</span>;              <span class="comment">//1</span></span><br><span class="line">          flag = <span class="keyword">true</span>;        <span class="comment">//2</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiply</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (flag) &#123;         <span class="comment">//3</span></span><br><span class="line">              <span class="keyword">int</span> ret = a * a;<span class="comment">//4</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种对变量的读写操作，标记为volatile可以保证修改对线程立刻可见。比synchronized,Lock有一定的效率提升。</p>
<p>2.单例模式的实现，典型的双重检查锁定（DCL）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种懒汉的单例模式，使用时才创建对象，而且为了避免初始化操作的指令重排序，给instance加上了volatile。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/2021/01/05/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h3 id="布隆过滤器-Bloom-Filter"><a href="#布隆过滤器-Bloom-Filter" class="headerlink" title="布隆过滤器-Bloom Filter"></a>布隆过滤器-Bloom Filter</h3><p>布隆过滤器的原理是，当一个元素被加入集合时，通过K个Hash函数将这个元素映射成一个位数组中的K个点，<br>把它们置为1。当检查一个元素是否存在时，我们只要将元素通过K个Hash函数进行计算,<br>看看这些点是不是都是1就（大约）知道集合中有没有它了：<br>如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素<strong>很可能在</strong>。这就是布隆过滤器的基本思想</p>
<p>Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，</p>
<p>每个字符串跟k个bit对应。从而降低了冲突的概率。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/0081Kckwgy1gmd6wwgyv4j30oi0d8t9h-20230906224412370.jpg"></p>
<p><strong>由于Hash函数存在Hash碰撞的情况,布隆过滤器无法100%保证检索的数据存在</strong>,但是能100%判断出数据不存在,这样就可以用于<strong>解决缓存穿透</strong>的情况了</p>
<p>缺陷:<br>根据上面我们可以知道,布隆过滤器有存在误判的情况,而且由于进行了k次Hash计算,删除就变得十分复杂;即:</p>
<ul>
<li><p>存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。<br>如果bloom filter中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。</p>
</li>
<li><p>删除困难。一个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为0，<br>可能会影响其他元素的判断。可以采用Counting Bloom Filter</p>
</li>
</ul>
<p><strong>Bloom Filter 实现</strong></p>
<p>布隆过滤器有许多实现与优化，Guava中就提供了一种Bloom Filter的实现。在实现布隆过滤器的时候需要注意两点:即<strong>数据量n和误判率fpp</strong><br>同时需要计算bit数组的大小和Hash函数的个数K;</p>
<p>对于一个确定的场景，我们预估要存的数据量为n，期望的误判率为fpp，然后需要计算我们需要的Bit数组的大小m，以及hash函数的个数k，并选择hash函数</p>
<p><strong>Java实现:</strong></p>
<p>第一步:依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>23.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br></pre></td></tr></table></figure>
<p>第二步:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBloomFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//100w个数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> total = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BloomFilter bloomFilter = BloomFilter.create(Funnels.integerFunnel(), total);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化100w条数据到过滤器中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">            bloomFilter.put(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配已在过滤器中的值，是否有匹配不上的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bloomFilter.mightContain(i)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;元素检查未命中&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配不在过滤器中的50000个值，有多少匹配出来</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = total; i &lt; total + <span class="number">50000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bloomFilter.mightContain(i)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;误判的数量：&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">误判的数量：1566</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>运行结果表示，遍历这一百w个在过滤器中的数时，都被识别出来了。5w个不在过滤器中的数，误判了1566个，错误率是0.03左右。</p>
<p>打开BloomFilter 源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> expectedInsertions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> create(funnel, (<span class="keyword">long</span>)expectedInsertions);</span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(funnel, expectedInsertions, <span class="number">0.03D</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions, <span class="keyword">double</span> fpp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(funnel, expectedInsertions, fpp, BloomFilterStrategies.MURMUR128_MITZ_64);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> expectedInsertions, <span class="keyword">double</span> fpp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(funnel, (<span class="keyword">long</span>)expectedInsertions, fpp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BloomFilter 一共四个create方法，不过最终都是走向第四个。看一下每个参数的含义：</p>
<ul>
<li>funnel：数据类型(一般是调用Funnels工具类中的)</li>
<li>expectedInsertions：期望插入的值的个数</li>
<li>fpp 错误率(默认值为0.03)</li>
<li>strategy 哈希算法Bloom Filter的应用</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>缓存击穿</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程环境下的异常处理</title>
    <url>/2021/01/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="线程的默认异常处理"><a href="#线程的默认异常处理" class="headerlink" title="线程的默认异常处理"></a>线程的默认异常处理</h1><p>线程不允许抛出未捕获的checked exception（比如sleep时的InterruptedException），但是 unchecked exception异常可能会导致线程终止<strong>也就是说各个线程需要自己把自己的checked exception处理掉</strong>。我们可以查看一下Thread类的run()方法声明，方法声明上没有对抛出异常进行任何约束。</p>
<h1 id="如何处理线程中抛出的异常"><a href="#如何处理线程中抛出的异常" class="headerlink" title="如何处理线程中抛出的异常"></a>如何处理线程中抛出的异常</h1><p>对于可传播的异常，并没有任何 catch 子句。在线程死亡之前，异常会传递到一个用于处理为捕获异常的处理器。最终由 JVM 来处理这个异常。这个处理器必须属于一个实现了 Thread.UncaughtExceptionHandler接口的类。这个接口只有一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Method invoked when the given thread terminates due to the</span></span><br><span class="line"><span class="comment">     * given uncaught exception.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Any exception thrown by this method will be ignored by the</span></span><br><span class="line"><span class="comment">     * Java Virtual Machine.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看Thread类的源码，可以看到有个dispatchUncaughtException方法，此方法就是用来处理线程中抛出的异常的。JVM会调用dispatchUncaughtException方法来寻找异常处理器(UncaughtExceptionHandler)，处理异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dispatch an uncaught exception to the handler. This method is</span></span><br><span class="line"><span class="comment"> * intended to be called only by the JVM.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchUncaughtException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    getUncaughtExceptionHandler().uncaughtException(<span class="keyword">this</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码注释道：这个方法向handler分派未捕获的异常，而且<strong>仅由 JVM 调用</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the handler invoked when this thread abruptly terminates</span></span><br><span class="line"><span class="comment"> * due to an uncaught exception. If this thread has not had an</span></span><br><span class="line"><span class="comment"> * uncaught exception handler explicitly set then this thread&#x27;s</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;ThreadGroup&lt;/tt&gt; object is returned, unless this thread</span></span><br><span class="line"><span class="comment"> * has terminated, in which case &lt;tt&gt;null&lt;/tt&gt; is returned.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the uncaught exception handler for this thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title">getUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uncaughtExceptionHandler != <span class="keyword">null</span> ?</span><br><span class="line">        uncaughtExceptionHandler : group;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UncaughtExceptionHandler必须显示的设置，否则<code>默认为null</code>。若为null，则使用线程默认的handler，即该线程所属的ThreadGroup。</p>
<p>注：ThreadGroup 为线程组，是可以管理线程的集合，默认情况下，创建的所有线程都属于同一个线程组。</p>
<p><strong>ThreadGroup自身就是一个handler</strong>，查看ThreadGroup的源码就可以发现，ThreadGroup实现了Thread.UncaughtExceptionHandler接口，它的 uncaughtException方法执行以下操作：</p>
<ul>
<li>如果该线程组有父线程组，那么调用父线程组的 uncaughtException方法</li>
<li>否则，如果 Thread.getDefaultException方法返回一个非 null 的处理器，则调用该处理器。</li>
<li>否则，如果 Throwable是 ThreadDeath 的一个实例，什么都不做</li>
<li>否则，将线程的名字以及 Throwable 的栈轨迹输出到 System.err。</li>
</ul>
<p>由此可知，最终JVM是调用未捕获的异常处理器的uncaughtException()方法来处理异常的，并且是直接打印到控制台。</p>
<h1 id="如何自定义异常"><a href="#如何自定义异常" class="headerlink" title="如何自定义异常"></a>如何自定义异常</h1><p>实际上，Thead确实已经提供了一个setUncaughtExceptionHandler方法，只需要将自定义未捕获异常处理器作为参数传入进入就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCaughtExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 发生异常</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//自定义未捕获异常处理器</span></span><br><span class="line">        thread.setUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;已捕获的异常为：&quot;</span>+e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line">已捕获的异常为：/ by zero</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1 id="线程池中自定义处理异常"><a href="#线程池中自定义处理异常" class="headerlink" title="线程池中自定义处理异常"></a>线程池中自定义处理异常</h1><p>线程池中的线程是有线程工厂创建的。在 ThreadPoolExecutor类的构造方法中，DefaultThreadFactory类，该类中有个newThread()方法，这就是线程产生方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title">defaultThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">        namePrefix + threadNumber.getAndIncrement(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是线程池创建线程的方法。通过覆盖默认的 newThread 方法，为新创建的线程提供一个UncaughtExceptionHandler 由于DefaultThreadFactory是Executors类的内部类，我们不能直接继承该类，只能实现该工厂类的接口——ThreadFactory接口，来实现我们自己的线程工厂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">        <span class="comment">//自定义UncaughtExceptionHandler</span></span><br><span class="line">        t.setUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：<code>只有通过execute()方法提交任务，才能将它抛出的异常交给未捕获异常处理器</code>。而通过submit()方法提交的任务，无论是抛出未检查异常还是已检查异常，都将被认为是任务返回状态的一部分。如果一个由submit()方法提交的任务由于抛出了异常而结束，该异常将被Future.get()封装在ExecutionException中重新抛出。 </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务组件之 Feign</title>
    <url>/2021/04/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6Feign/</url>
    <content><![CDATA[<h1 id="什么是Feign"><a href="#什么是Feign" class="headerlink" title="什么是Feign"></a>什么是Feign</h1><p>Feign是Netflix开发的声明式、模板化的HTTP客户端，其灵感来自Retrofit、JAXRS-2.0以及WebSocket。 Feign可帮助我们更加便捷、优雅地调用HTTP API。</p>
<p> Feign支持多种注解，例如Feign自带的注解或者JAX-RS注解等。Spring Cloud openfeign对Feign进行了 增强，使其支持Spring MVC注解，另外还整合了Ribbon和Eureka，从而使得Feign的使用更加方便</p>
<h2 id="使用-Feign-的场合和优势"><a href="#使用-Feign-的场合和优势" class="headerlink" title="使用 Feign 的场合和优势"></a>使用 Feign 的场合和优势</h2><p>一般来说Java 调用接口有以下几种方式：</p>
<ol>
<li>Httpclient</li>
<li>Okhttp</li>
<li>HttpURLConnection</li>
<li>RestTemplate</li>
</ol>
<p>之所以在微服务中推荐使用 Feign的方式进行服务间的调用，主要是减少项目中静态 URL 的配置，使代码更具有可读性。</p>
<h1 id="Feign-的使用"><a href="#Feign-的使用" class="headerlink" title="Feign 的使用"></a>Feign 的使用</h1><p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230905223638017.png" alt="image-20230905223638017"></p>
<h2 id="SpringCloud-Alibaba-整合-Feign"><a href="#SpringCloud-Alibaba-整合-Feign" class="headerlink" title="SpringCloud-Alibaba 整合 Feign"></a>SpringCloud-Alibaba 整合 Feign</h2><ol>
<li><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- openfeign 远程调用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义调用接口，并打上 @FeignClient注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;mall-order&quot;,path = &quot;/order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderFeignService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findOrderByUserId/&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="function">Result <span class="title">findOrderByUserId</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> Integer userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动类开启@EnableFeignClients注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, DruidDataSourceAutoConfigure.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MallUserFeignDemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MallUserFeignDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>发起调用，类似 mybatis 的使用，只需要将定义的接口 bean 注入到要使用的类中即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderFeignService orderFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/findOrderByUserId/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">findOrderByUserId</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//feign调用</span></span><br><span class="line">        Result result = orderFeignService.findOrderByUserId(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="Spring-Cloud-Feign的自定义配置及使用"><a href="#Spring-Cloud-Feign的自定义配置及使用" class="headerlink" title="Spring Cloud Feign的自定义配置及使用"></a>Spring Cloud Feign的自定义配置及使用</h1><h2 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h2><ol>
<li><p>全局配置类，指定日志级别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志级别</span></span><br><span class="line"><span class="comment">     * 通过源码可以看到日志等级有 4 种，分别是：</span></span><br><span class="line"><span class="comment">     * NONE：不输出日志。</span></span><br><span class="line"><span class="comment">     * BASIC：只输出请求方法的 URL 和响应的状态码以及接口执行的时间。</span></span><br><span class="line"><span class="comment">     * HEADERS：将 BASIC 信息和请求头信息输出。</span></span><br><span class="line"><span class="comment">     * FULL：输出完整的请求信息。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 日志级别枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">Level</span> </span>&#123;</span><br><span class="line">        NONE,</span><br><span class="line">        BASIC,</span><br><span class="line">        HEADERS,</span><br><span class="line">        FULL;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Level</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过源码可知，日志等级有 4 种，分别是：</p>
<ul>
<li>NONE：不记录任何日志(默认使用级别)，该级别性能最好，可以适用于生产环境</li>
<li>BASIC：仅记录请求方法、URL、响应状态代码以及执行时间，可以使用于生产环境追踪问题</li>
<li>HEADERS：记录BASIC级别的基础上，记录请求和响应的header</li>
<li>FULL：记录请求和响应的header、body和元数据，一般用于开发环境进行问题的定位</li>
</ul>
</li>
<li><p>局部配置-注解配置</p>
<p>在@FeignClient 注解中指定使用的配置类使调用的微服务生效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> heyou(heyou_0423 @ 163.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/24 下午5:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;mall-order&quot;,path = &quot;/order&quot;,configuration = FeignConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderFeignService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findOrderByUserId/&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="function">Result <span class="title">findOrderByUserId</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> Integer userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：当指定注解中的配置类时，该配置类不能添加@Configuration 注解。</p>
</li>
<li><p>局部配置-yml 配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">	<span class="attr">client:</span></span><br><span class="line">		<span class="attr">config:</span></span><br><span class="line">			<span class="string">mall‐order:</span> <span class="comment">#对应微服务 </span></span><br><span class="line">			<span class="attr">loggerLevel:</span> <span class="string">FULL</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>注：打印日志时，配置的日志目录需要准确，否则无法正常输出日志</p>
<h2 id="契约配置"><a href="#契约配置" class="headerlink" title="契约配置"></a>契约配置</h2><p>Spring Cloud 在 Feign 的基础上做了扩展，可以让 Feign 支持 Spring MVC 的注解来调用。原生的 Feign 是不支持 Spring MVC 注解的，如果你想在 Spring Cloud 中使用原生的注解方式来定义客户端也是 可以的，通过配置契约来改变这个配置，Spring Cloud 中默认的是 SpringMvcContract。</p>
<ol>
<li><p>修改契约配置，支持原生 Feign 的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 使用Feign原生的注解配置</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Contract <span class="title">feignContract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Contract.Default();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注：修改契约配置后，不再支持springmvc的注解，需要使用Feign原生的注解</p>
</li>
<li><p>使用原生 Feign 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;mall‐order&quot;, path = &quot;/order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderFeignService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestLine(&quot;GET /findOrderByUserId/&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="function">Result <span class="title">findOrderByUserId</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> Integer userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>yml 配置契约 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">feign:</span><br><span class="line">  client:</span><br><span class="line">  	config:</span><br><span class="line">  		mall‐order: #对应微服务</span><br><span class="line">  			loggerLevel: FULL</span><br><span class="line">  contract: feign.Contract.Default #指定Feign原生注解契约配置</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="拦截器认证"><a href="#拦截器认证" class="headerlink" title="拦截器认证"></a>拦截器认证</h2><ol>
<li><p>Feign配置 Basic认证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启Basic认证</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BasicAuthRequestInterceptor <span class="title">basicAuthRequestInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">&quot;heyou&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次 feign 发起http调用之前，会去执行拦截器中的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Called for every request. Add data using methods on the supplied &#123;<span class="doctag">@link</span> RequestTemplate&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般用于自定义 header 信息或者对 body 中的信息进行修改。</p>
</li>
<li><p>自定义拦截器认证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignAuthRequestInterceptor</span> <span class="keyword">implements</span> <span class="title">RequestInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate requestTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 业务逻辑  模拟认证逻辑</span></span><br><span class="line">        String access_token = UUID.randomUUID().toString();</span><br><span class="line">        requestTemplate.header(<span class="string">&quot;Authorization&quot;</span>,access_token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FeignAuthRequestInterceptor <span class="title">feignAuthRequestInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FeignAuthRequestInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
]]></content>
      <categories>
        <category>SpringCloud alibaba</category>
      </categories>
      <tags>
        <tag>服务调用组件</tag>
      </tags>
  </entry>
  <entry>
    <title>监听Springboot启动事件完成消息通知</title>
    <url>/2023/09/05/%E7%9B%91%E5%90%ACSpringboot%E5%90%AF%E5%8A%A8%E4%BA%8B%E4%BB%B6%E5%AE%8C%E6%88%90%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5/</url>
    <content><![CDATA[<h1 id="监听Springboot启动事件完成消息通知"><a href="#监听Springboot启动事件完成消息通知" class="headerlink" title="监听Springboot启动事件完成消息通知"></a>监听Springboot启动事件完成消息通知</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于版本发布是用k8s，作为开发无法及时感知项目启动情况，所以利用Springboot中的事件，完成消息通知功能，当项目启动成功或失败时，将消息发送到钉钉工作台。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>事件监听机制可以理解为是一种<strong>观察者模式</strong>，有数据发布者（事件源）和数据接受者（监听器）；</p>
<p>在Java中，事件对象都是继承java.util.EventObject对象，事件监听器都是java.util.EventListener实例；</p>
<p>EventObject对象不提供默认构造器，需要外部传递source参数，即用于记录并跟踪事件的来源；在Spring中事件对象为ApplicationEvent，继承EventObject，源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationEvent</span> <span class="keyword">extends</span> <span class="title">EventObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** use serialVersionUID from Spring 1.2 for interoperability. */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7099057708183571937L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** System time when the event happened. */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestamp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new &#123;<span class="doctag">@code</span> ApplicationEvent&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> source the object on which the event initially occurred or with</span></span><br><span class="line"><span class="comment">	 * which the event is associated (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ApplicationEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(source);</span><br><span class="line">		<span class="keyword">this</span>.timestamp = System.currentTimeMillis();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the system time in milliseconds when the event occurred.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.timestamp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而事件监听器为ApplicationListener，继承EventListener</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Handle an application event.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> event the event to respond to</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E event)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>实现Spring事件监听有两种方式</strong>：</p>
<ol>
<li>面向接口编程，实现ApplicationListener接口；</li>
<li>基于注解驱动，@EventListener（Spring自定义的注解）；</li>
</ol>
<p>在项目启动通知功能中，使用的是实现接口的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationStartListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;info.application.start.notice:true&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> applicationStartNotice;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;info.application.start.notice.user:&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String applicationStartNoticeUsers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.application.name:&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String applicationName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.profiles.active:&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String profile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;info.application.start.notice.url:&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String mscNoticeUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent applicationEvent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (applicationEvent <span class="keyword">instanceof</span> ApplicationReadyEvent) &#123;</span><br><span class="line">            sendMsgAfterEnven(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (applicationEvent <span class="keyword">instanceof</span> ApplicationFailedEvent) &#123;</span><br><span class="line">            sendMsgAfterEnven(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送启动消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startFlag 是否启动成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMsgAfterEnven</span><span class="params">(<span class="keyword">boolean</span> startFlag)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="keyword">if</span> (applicationStartNotice &amp;&amp; StringUtils.isNotBlank(applicationStartNoticeUsers)) &#123;</span><br><span class="line">            String ip = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ip = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;获取网络IP异常&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, String&gt; msgTemplateParamMap = Maps.newHashMap();</span><br><span class="line">            msgTemplateParamMap.put(<span class="string">&quot;applicationName&quot;</span>, applicationName);</span><br><span class="line">            msgTemplateParamMap.put(<span class="string">&quot;startResult&quot;</span>, startFlag ? <span class="string">&quot;成功&quot;</span> : <span class="string">&quot;失败&quot;</span>);</span><br><span class="line">            msgTemplateParamMap.put(<span class="string">&quot;profile&quot;</span>, profile);</span><br><span class="line">            msgTemplateParamMap.put(<span class="string">&quot;IP&quot;</span>, ip);</span><br><span class="line">            msgTemplateParamMap.put(<span class="string">&quot;createTime&quot;</span>, DateUtil.formatDate(<span class="keyword">new</span> Date()));</span><br><span class="line">            MscSendMsgParam mscSendMsgParam = <span class="keyword">new</span> MscSendMsgParam();</span><br><span class="line">            Set&lt;String&gt; noticeUserIds = Arrays.stream(applicationStartNoticeUsers.split(<span class="string">&quot;,&quot;</span>)).collect(Collectors.toSet());</span><br><span class="line">            mscSendMsgParam.setUserIds(noticeUserIds);</span><br><span class="line">            mscSendMsgParam.setMscSendMsgUrl(mscNoticeUrl);</span><br><span class="line">            mscSendMsgParam.setMsgTemplateCode(CommonMsgTemplateCode.APP_START);</span><br><span class="line">            SendMsgUtils.sendMsgAfterAppStart(mscSendMsgParam, msgTemplateParamMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>事件监听</tag>
      </tags>
  </entry>
  <entry>
    <title>算法（一）基础数据类型</title>
    <url>/2020/10/12/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="一、-背包"><a href="#一、-背包" class="headerlink" title="一、 背包"></a>一、 背包</h4><ol>
<li><p>概念</p>
<p>背包是一种不支持从中删除元素的集合数据类型，它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素,且迭代的顺序与用例无关</p>
</li>
<li><p>demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stats</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Bag&lt;Double&gt; numbers = <span class="keyword">new</span> Bag&lt;Double&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!StdIn.isEmpty())&#123;</span><br><span class="line">            numbers.add(StdIn.readDouble());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> N = numbers.size();</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> x : numbers) &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> std = Math.sqrt(sum/(N-<span class="number">1</span>))；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h4><ol>
<li><p>概念</p>
<p>队列是一种基于先进先出（FIFO）策略的集合类型，也是公平的策略，队列中保存元素的相对顺序。</p>
</li>
<li><p>demo</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] readInts(String name)&#123;</span><br><span class="line">    In in = <span class="keyword">new</span> In(name);</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> Queue&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!in.isEmpty())&#123;</span><br><span class="line">        q.enqueue(in.readInt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = q.size();</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        a[i] = q.dequeue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="三、栈"><a href="#三、栈" class="headerlink" title="三、栈"></a>三、栈</h4><ol>
<li><p>栈，又称之为下压栈，是一种基于后进先出（LIFO）策略的集合</p>
</li>
<li><p>demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reverse</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!StdIn.isEmpty())&#123;</span><br><span class="line">            stack.push(StdIn.readInt());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i: stack) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定容栈：即容量固定的栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定容字符串栈的抽象数据类型与实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> heyou(heyou_0423 @ 163.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/9/26 22:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedCapacityStackOfStrings</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Item[] a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixedCapacityStackOfStrings</span><span class="params">(<span class="keyword">int</span> cap)</span></span>&#123;</span><br><span class="line">        a = (Item[]) <span class="keyword">new</span> Object[cap];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        a[N+<span class="number">1</span>] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[--N];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fnPrint</span><span class="params">(String exp)</span></span>&#123;</span><br><span class="line">        String[] split = exp.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        FixedCapacityStackOfStrings f = <span class="keyword">new</span> FixedCapacityStackOfStrings(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s:split) &#123;</span><br><span class="line">            <span class="comment">// 这里要多判断一下,f函数的成员变量n是否为零.如果为零,则说明数组里面没东西了,不能用pop()去取数据,否则则会报错</span></span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;-&quot;</span>) &amp;&amp; !f.isEmpty())&#123;</span><br><span class="line">                <span class="comment">// 取数据的前提是:数组里面还有数据才可以</span></span><br><span class="line">                Object pop = f.pop();</span><br><span class="line">                System.out.println(pop);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                f.push(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------end-------------------&quot;</span>);</span><br><span class="line">        System.out.println(f.size()+<span class="string">&quot; left on stack &quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String exp=<span class="string">&quot;to be or not to - be - - that - - - is&quot;</span>;</span><br><span class="line">        fnPrint(exp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="四、链表"><a href="#四、链表" class="headerlink" title="四、链表"></a>四、链表</h4><ol>
<li><p>概念</p>
<p>链表是一种递归的数据结构，它要么为空，要么指向下一个节点（node）的引用，该节点含有一个泛型的元素和一个指向另一条链表的引用。</p>
</li>
<li><p>内部类的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    Item item;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链表的特性</p>
<ul>
<li>可以出来任意数据类型的数据</li>
<li>所需要的空间总是和集合的大小成正比</li>
<li>操作所需要的时间总是和集合大小无关</li>
<li>不支持随机访问</li>
</ul>
</li>
<li><p>下压栈的链表实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下压栈的链表实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> heyou(heyou_0423 @ 163.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/10/7 22:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义链表节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        Item item;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        Node oldFirst = first;</span><br><span class="line">        first = <span class="keyword">new</span> Node();</span><br><span class="line">        first.item = item;</span><br><span class="line">        first.next = oldFirst;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Item item = first.item;</span><br><span class="line">        first = first.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Item</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node curretnt = first;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> curretnt != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Item item = curretnt.item;</span><br><span class="line">            curretnt = curretnt.next;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>多级缓存架构与 Redis 常见问题与解决方案</title>
    <url>/2021/03/19/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E4%B8%8E%20Redis%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="多级缓存架构"><a href="#多级缓存架构" class="headerlink" title="多级缓存架构"></a>多级缓存架构</h1><p><img src="https://raw.githubusercontent.com/he-You/image/master/008eGmZEly1goq7kxttl9j311f0u0dj6.jpg" alt="img"></p>
<p>如上图所示：改架构由LVS负载均衡、Nginx 负载均衡、web 层、缓存层、微服务层、DB 层组成。其中：</p>
<ul>
<li>LVS（Linux Virtual Server）即Linux虚拟服务器，Linux内核中实现了基于IP的数据请求负载均衡调度。终端用户的Web请求会发送给LVS调度器，调度器根据自己预设的算法决定将该请求发送给后端的某台Web服务器。</li>
<li>Keepalived：用来防止服务器单点故障的发生，通过配合 Nginx 可以实现 web 前端服务的高可用。</li>
<li>Nginx：热点数据放在 Nginx 本地缓存中</li>
<li>Ehcache: 是一个<code>纯Java</code>的进程内<code>缓存框架</code>,是广泛使用的开源Java分布式缓存，面向通用缓存,Java EE和轻量级容器</li>
</ul>
<p>在多级缓存架构中，请求优先获取缓存中的数据，如果缓存层没有命中数据，则去 DB 存储层请求数据。</p>
<h1 id="常见的-Redis-缓存问题"><a href="#常见的-Redis-缓存问题" class="headerlink" title="常见的 Redis 缓存问题"></a>常见的 Redis 缓存问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>所谓缓存穿透，是指查询了一个在各级缓存都不存在的数据，从而让数据请求直接到达 DB 进行查询。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p>缓存空对象：如果缓存没命中，去数据库查询，如果数据库查询结果不存在，则构造一个空的对象缓存到 Redis 中，并设置过期时间。</p>
</li>
<li><p>**<a href="https://he-you.github.io/2021/01/05/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">布隆过滤器</a>**：布隆过滤器就是一个大型的bit数组和几个不一样的无偏 hash 函数。所谓无偏就是能够把元素的 hash 值算得比较均匀。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/008eGmZEly1goq87ynfpkj31us0j0766.jpg" alt="img"></p>
</li>
</ol>
<p>向布隆过滤器中添加 key 时，会使用多个 hash 函数对 key 进行 hash 算得一个整数索引值然后对位数组长度 进行<code>取模运算</code>得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就 完成了 add 操作。</p>
<p>向布隆过滤器询问 key 是否存在时，跟 add 一样，也会把 hash 的几个位置都算出来，看看位数组中这几个位 置是否都为 1，<strong>只要有一个位为 0，那么说明布隆过滤器中这个key 不存在</strong>。</p>
<p>如果都是 1，这并不能说明这个 key 就一定存在，只是极有可能存在，因为这些位被置为 1 可能是因为其它的 key 存在所致。如果这个位数组 比较稀疏，这个概率就会很大，如果这个位数组比较拥挤，这个概率就会降低。 这种方法适用于数据命中不高、 数据相对固定、 实时性低(通常是数据集较大) 的应用场景， 代码维护较为复杂， 但是缓存空间占用很少。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿，是大批量请求访问某个 key时，这个key 缓存过期了，导致大量请求直接到达数据库，数据库瞬时压力过大甚至挂掉的场景。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>使用互斥锁（mutex lock)：</li>
</ol>
<p>简单地来说，就是在缓存失效的时候，不是直接请求DB，而是先加分布式锁（比如redis的setNx），如果加锁成功，再进行load db的操作并回设缓存；如果加锁失败，说明已经有别的进程在加锁重设缓存，我们只需要等待重试或者直接返回客户端失败让用户手动重试。</p>
<p>这是比较简单，也是很常用的一种解决方式。值得注意的是，我们加锁的时候一定要设置过期时间（如redis的expire），否则会有死锁的风险。</p>
<ol start="2">
<li>提前更新缓存：</li>
</ol>
<p>上面一种方案，因为用户是有感知的，如果不想影响用户体验，可以进一步优化为对缓存加锁，并记录它的过期时间，当我们读取缓存的时候，先判断它是否快到过期时间，如果是则在返回缓存数据的同时，后台异步请求DB重设缓存，更新它的过期时间。而如果我们获取缓存是缓存已经过期，则还需要我们按照上一个方案处理。</p>
<ol start="3">
<li>永不失效：</li>
</ol>
<p>在上面情况下，我们进一步思考，如果我们设置缓存的过期时间非常长（比如3天），同时我们对缓存加标记录设置缓存的时间，每次我们读取缓存的时候，拿到设置缓存的时间跟现在的时间做比对，如果相差时间超过10分钟，我们在后台异步更新缓存。这样对于热点数据而言，就相当于缓存“永不失效”了。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指同一时间大批量key的缓存过期，使得大量请求直接打到存储层，存储层调用量急剧增加，造成存储层出现<code>级联宕机</code>的情况。</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>在批量增加缓存数据时，将这批数据设置不同的过期时间。</li>
<li>增加限流中间件，在必要时进行熔断并降级</li>
<li>提前预估流量，进行压测提前演练</li>
</ol>
<h2 id="热点-Key"><a href="#热点-Key" class="headerlink" title="热点 Key"></a>热点 Key</h2><p>所谓热点 key问题就是突然有几十万的请求去访问redis上的某个特定key，那么这样会造成流量过于集中，从而导致这台redis的服务器宕机进而引发雪崩。</p>
<h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>提前将热点 key 分散到不同的服务器中，降低单一服务器的访问压力</li>
<li>加入二级缓存，提前将热 key 数据加载到内存中，如果 redis 宕机，从内存中查询。</li>
</ol>
<h2 id="缓存与数据库双写不一致"><a href="#缓存与数据库双写不一致" class="headerlink" title="缓存与数据库双写不一致"></a>缓存与数据库双写不一致</h2><p>在高并发场景下，不同线程之间的执行耗时可能不一样，当有多个线程同时操作 DB 和缓存时，就有可能出现数据库的值与缓存中的值不一致的情况。</p>
<h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>对于并发几率小的数据（如用户个人数据），可以给缓存加上过期时间，每隔一段时间主动更新缓存</li>
<li>当并发量大时，依然给缓存数据添加过期时间，定时刷新缓存</li>
<li>当必须要保证双写一致时，可以通过添加分布式锁（读多写少的场景最好使用读写锁）保证线程串行化执行，这样可以有效规避双写不一致问题，但是使用分布式锁会出现性能问题</li>
<li>引入阿里开源中间件 canal通过监听数据库的 binlog 日志去修改缓存，但是引入中间件会增加系统的复杂度</li>
</ol>
<h1 id="缓存清除策略"><a href="#缓存清除策略" class="headerlink" title="缓存清除策略"></a>缓存清除策略</h1><p>Redis 对于过期键提供了三种清除策略</p>
<h2 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h2><p>惰性删除指的是当我们查询key的时候才对key进行检测，如果已经达到过期时间，则删除。显然，他有一个缺点就是如果这些过期的key没有被访问，那么他就一直无法被删除，而且一直占用内存。</p>
<h2 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h2><p>定期删除指的是redis每隔一段时间对数据库做一次检查，删除里面的过期key。由于不可能对所有key去做轮询来删除，所以redis会每次随机取一些key去做检查和删除。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/008eGmZEly1goq6x2dzjmj30q60ry3zz.jpg" alt="img"></p>
<h2 id="主动内存淘汰策略"><a href="#主动内存淘汰策略" class="headerlink" title="主动内存淘汰策略"></a>主动内存淘汰策略</h2><p>当Redis当前使用的内存超过 maxmemory 限定时，会触发主动清理策略，Redis 主动清理策略有 8 种，可以分为以下三种场景：</p>
<h3 id="针对过期-key-的处理"><a href="#针对过期-key-的处理" class="headerlink" title="针对过期 key 的处理"></a>针对过期 key 的处理</h3><ul>
<li><strong>volatile-ttl</strong>:在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删 除，越早过期的越先被删除。</li>
<li> <strong>volatile-random</strong>:就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。 </li>
<li> <strong>volatile-lru</strong>:会使用 LRU 算法筛选设置了过期时间的键值对删除。</li>
<li> <strong>volatile-lfu</strong>:会使用 LFU 算法筛选设置了过期时间的键值对删除。</li>
</ul>
<h3 id="针对所有-key-的处理"><a href="#针对所有-key-的处理" class="headerlink" title="针对所有 key 的处理"></a>针对所有 key 的处理</h3><ul>
<li><strong>allkeys-random</strong>:从所有键值对中随机选择并删除数据。</li>
<li><strong>allkeys-lru</strong>:使用 LRU 算法在所有数据中进行筛选删除。 </li>
<li> <strong>allkeys-lfu</strong>:使用 LFU 算法在所有数据中进行筛选删除。</li>
</ul>
<h3 id="不处理"><a href="#不处理" class="headerlink" title="不处理"></a>不处理</h3><ul>
<li>noeviction:不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</li>
</ul>
<p>注：</p>
<ol>
<li>LRU 算法即Least Recently Used，最近最少使用，Redis 用于淘汰长时间未被访问的数据，以<code>最近一次访问时间</code>作为参考。</li>
<li>LFU 算法即Least Frequently Used，最不经常使用，Redis 用于淘汰最近一段时间被访问次数最少的数据，以<code>次数</code>作为衡量标准。</li>
</ol>
<p>对于热点数据，使用 LFU 更好一点。另外要根据自身业务类型，配置好maxmemory-policy(默认是noeviction)，推荐使用volatile-lru。如果不设置最大内存，当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap)，会让 Redis 的性能急剧下降。 当Redis运行在主从模式时，只有主<strong>结点才会执行过期删除策略</strong>，然后把删除操作”del key”同步到从结点删除数据。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2021/01/23/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="红黑树的定义"><a href="#红黑树的定义" class="headerlink" title="红黑树的定义"></a>红黑树的定义</h1><p>红黑树是二叉树的一种变种,为保证左右子树相对平衡不会出现极端情况(退化成斜树，可以理解为单链表)而采取节点上色的方案,将节点标记为红色或者黑色，在<strong>计算树的深度时只统计黑色节点的数量</strong>，不统计红色节点数量。</p>
<p>而保持左右子树深度相同的原因是减少树的最大深度，从而提高查询的效率，尽量维持左右子树的深度一致，避免某个子树深度过深的情况出现。</p>
<p>如果某个子树深度过深，查找算法的时间复杂度就下降为链表的时间复杂度O(n)，为了保证左右子树的平衡，红黑树定义了一些规则或者特点来维持平衡。</p>
<h1 id="红黑树的主要特征"><a href="#红黑树的主要特征" class="headerlink" title="红黑树的主要特征"></a>红黑树的主要特征</h1><ul>
<li>每个节点要么是黑色，要么是红色。（节点非黑即红）</li>
<li>根节点为黑色</li>
<li>每个叶子节点（NIL）是黑色（值得提醒注意的是，在Java中，叶子结点是为null的结点。）。</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。（也就是说父子节点不能同时为红色）</li>
<li>从一个节点到该节点的每一个叶子子孙节点的所有路径上包含相同数目的黑节点。（这一点是平衡的关键）</li>
<li>新插入节点默认为红色，插入后需要校验红黑树是否符合规则，不符合则需要进行操作。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmxs0cp1mpj30fx0aq439.jpg"></p>
<p>红黑树并不是一个完美平衡二叉查找树，从上图可以看到，根结点P的左子树显然比右子树高， 但左子树和右子树的黑结点的层数是相等的， 也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点。 所以我们叫红黑树这种平衡为黑色完美平衡。</p>
<p>我们把正在处理(遍历)的结点叫做当前结点，如下图中的D，它的父亲叫做父结点，它的父亲的另外一个子结点叫做兄弟结点，父亲的父亲叫做祖父结点。 </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmxs0u437oj30kh0eqwor.jpg"></p>
<p>HashMap在进行插入和删除时有可能会触发红黑树的插入平衡调整（balanceInsertion方法） 或删除平衡调整（balanceDeletion ）方法， 调整的方式主要有以下手段： </p>
<p>左旋转（rotateLeft方法）、右旋转（rotateRight方法）、颜色反转（x.red = false、x.red = true）， 进行调整的原因是为了维持红黑树的数据结构。</p>
<ul>
<li><strong>左旋</strong>：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如图3。</li>
<li><strong>右旋</strong>：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如图4。</li>
<li><strong>变色</strong>：结点的颜色由红变黑或由黑变红。</li>
</ul>
<p>我们先忽略颜色，可以看到旋转操作不会影响旋转结点的父结点，父结点以上的结构还是保持不变的。 左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树挪了。 </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmxs1tuyswj30kp073tdi.jpg"></p>
<p>右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树挪了。 </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmxs2cfiskj30kq06fn1i.jpg"></p>
<p>所以旋转操作是局部的。另外可以看出旋转能保持红黑树平衡的一些端详了：当一边子树的结点少了，那么向另外一边子树“借”一些结点；当一边子树的结点多了，那么向另外一边子树“租”一些结点。</p>
<h1 id="红黑树的遍历"><a href="#红黑树的遍历" class="headerlink" title="红黑树的遍历"></a>红黑树的遍历</h1><p>因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：</p>
<ul>
<li><p>从根结点开始查找，把根结点设置为当前结点；</p>
</li>
<li><p>若当前结点为空，返回null；</p>
</li>
<li><p>若当前结点不为空，用当前结点的key跟查找key作比较；</p>
</li>
<li><p>若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；</p>
</li>
<li><p>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；</p>
</li>
<li><p>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2； </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmxs35jvcyj30kv0fwadm.jpg"></p>
<p>正由于红黑树总保持黑色完美平衡，所以它的查找最坏时间复杂度为O(2lgN)，也即整颗树刚好红黑相隔的时候。</p>
</li>
</ul>
<h1 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h1><p>插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。查找插入的父结点很简单，跟查找操作区别不大：</p>
<ul>
<li><p>从根结点开始查找；</p>
</li>
<li><p>若根结点为空，那么插入结点作为根结点，结束。</p>
</li>
<li><p>若根结点不为空，那么把根结点作为当前结点；</p>
</li>
<li><p>若当前结点为null，返回当前结点的父结点，结束。</p>
</li>
<li><p>若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。</p>
</li>
<li><p>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；</p>
</li>
<li><p>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；</p>
</li>
</ul>
<p>  <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmxs42qhpqj30l00j5wj1.jpg"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>雪花id重复问题与解决方案</title>
    <url>/2023/07/27/%E9%9B%AA%E8%8A%B1id%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="雪花id重复问题与解决方案"><a href="#雪花id重复问题与解决方案" class="headerlink" title="雪花id重复问题与解决方案"></a>雪花id重复问题与解决方案</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>CSM项目中用线程池异步插入日志数据，产线环境会偶发（出现的概率也不算小）日志表主键id重复的异常</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20231009222605966.png" alt="image-20231009222605966"></p>
<h2 id="二、排查过程"><a href="#二、排查过程" class="headerlink" title="二、排查过程"></a>二、排查过程</h2><p>一开始怀疑是mybatis-plus的主键生成策略的问题，但是项目中采用的生成策略是雪花算法生成的id</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/%E9%9B%AA%E8%8A%B1id%E9%87%8D%E5%A4%8D%E6%8E%92%E6%9F%A501" alt="image-20230727111003701"></p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/%E9%9B%AA%E8%8A%B1id%E6%8E%92%E6%9F%A502" alt="img"></p>
<p>首先简单介绍一下雪花算法(SnowFlake算法)的设计思路：</p>
<p><strong>雪花算法</strong>是Twitter设计的根据时间戳、机器标识码和序列号生成的唯一长整型数。</p>
<p>使用一个 64 bit 的 long 型的数字作为全局唯一 id。这 64 个 bit 中，其中 1 个 bit 是不用的，然后用其中的 41 bit 作为毫秒数，用 10 bit 作为标识位，12 bit 作为序列号。</p>
<p>0 - 0000000000 0000000000 0000000000 0000000000 0 - 0000000000 - 000000000000</p>
<p>符号位           时间戳                             标识位        序列号</p>
<p>包含四个组成部分：</p>
<p>●   不使用：1bit，最高位是符号位，0 表示正，1 表示负，固定为 0</p>
<p>●   时间戳：41bit，毫秒级的时间戳（41 位的长度可以使用 69 年）</p>
<p>●   标识位：5bit 数据中心（datacenterId） ID，5bit 工作机器(workerId) ID，两个标识位组合起来最多可以支持部署 1024 个节点</p>
<p>●   序列号：12bit </p>
<p><strong>SnowFlake 算法的优点：</strong></p>
<ol>
<li><p>高性能高可用：生成时不依赖于数据库，完全在内存中生成</p>
</li>
<li><p>高吞吐：每秒钟能生成数百万的自增 ID</p>
</li>
<li><p>ID 自增：存入数据库中，索引效率高</p>
</li>
</ol>
<p><strong>SnowFlake 算法的缺点：</strong></p>
<p>依赖与系统时间的一致性，如果系统时间被回调，或者改变，可能会造成 ID 冲突或者重复。</p>
<p>递增序列号，表示节点毫秒内生成重复，通过序列号表示唯一，12bit 每毫秒可产生 4096 个 ID</p>
<p>而mybatis-plus雪花算法的具体实现为：</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/%E9%9B%AA%E8%8A%B1id%E7%AE%97%E6%B3%95%E6%BA%90%E7%A0%81" alt="image-20230727110704935"></p>
<p>源码的逻辑大体可以分为三个部分：</p>
<p>1.对项目重启可能出现的系统时钟回退的情况处理</p>
<p>2.处理并发情况下时间戳一样的场景</p>
<p>3.计算生成雪花id</p>
<p>关于雪花id重复的问题，我在网上查了，出现的场景大体以下几个条件：</p>
<p>●   业务存在一定的并发量，没有并发量无法触发重复问题</p>
<p>●   服务通过集群的方式部署，其中部分机器标识位一致</p>
<p>●   生成 ID 的时机：同一毫秒下的序列号一致</p>
<p>关于并发问题，我查了听云，出现问题的时间段系统的QPS大概是200+</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/%E8%AF%B7%E6%B1%82%E6%83%85%E5%86%B5" alt="img"></p>
<p>关于标识位的问题，我们首先看一下标识位的定义与实现。</p>
<p>首先项目中生成的id的工具类是使用的和mybatis-plus一样的默认id生成器，其中Sequence采用的是无参构造函数。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/%E9%9B%AA%E8%8A%B1id-sequence" alt="img"></p>
<p>Sequence的相关逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.datacenterId = getDatacenterId(maxDatacenterId);</span><br><span class="line">     <span class="keyword">this</span>.workerId = getMaxWorkerId(datacenterId, maxWorkerId);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数据标识id部分</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getDatacenterId</span><span class="params">(<span class="keyword">long</span> maxDatacenterId)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> id = <span class="number">0L</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       InetAddress ip = InetAddress.getLocalHost();</span><br><span class="line">       NetworkInterface network = NetworkInterface.getByInetAddress(ip);</span><br><span class="line">       <span class="keyword">if</span> (network == <span class="keyword">null</span>) &#123;</span><br><span class="line">         id = <span class="number">1L</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">byte</span>[] mac = network.getHardwareAddress();</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">null</span> != mac) &#123;</span><br><span class="line">           id = ((<span class="number">0x000000FF</span> &amp; (<span class="keyword">long</span>) mac[mac.length - <span class="number">1</span>]) | (<span class="number">0x0000FF00</span> &amp; (((<span class="keyword">long</span>) mac[mac.length - <span class="number">2</span>]) &lt;&lt; <span class="number">8</span>))) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">           id = id % (maxDatacenterId + <span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       logger.warn(<span class="string">&quot; getDatacenterId: &quot;</span> + e.getMessage());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取 maxWorkerId</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getMaxWorkerId</span><span class="params">(<span class="keyword">long</span> datacenterId, <span class="keyword">long</span> maxWorkerId)</span> </span>&#123;</span><br><span class="line">     StringBuilder mpid = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">     mpid.append(datacenterId);</span><br><span class="line">     String name = ManagementFactory.getRuntimeMXBean().getName();</span><br><span class="line">     <span class="keyword">if</span> (StringUtils.isNotBlank(name)) &#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       \* GET jvmPid</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       mpid.append(name.split(StringPool.AT)[<span class="number">0</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     \* MAC + PID 的 hashcode 获取16个低位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">return</span> (mpid.toString().hashCode() &amp; <span class="number">0xffff</span>) % (maxWorkerId + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中datacenterId的实现是与mac地址有关，workerId是与jvm进程的pid有关。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/%E5%AE%9E%E4%BE%8Bip%E6%83%85%E5%86%B5" alt="img"></p>
<p>CSM产线环境有4台实例，每个实例是部署在不同的物理节点上，他们的pid和mac地址分别为：</p>
<p>pod name                          pid   mac地址           mac地址转换后的byte数组<br> csmapi-ucprod-684f4bb5d7-kp4bg    13    86:ae:93:40:9f:aa   {-122, -82, -109, 64, -97, -86}<br> csmapi-ucprod-684f4bb5d7-m689j    13    2e:f9:0e:76:40:de   {46, -7, 14, 118, 64, -34}<br> csmapi-ucprod-684f4bb5d7-h6cvd    13    fe:37:d1:b6:18:bd    {-2, 55, -47, -74, 24, -67}<br> csmapi-ucprod-684f4bb5d7-6p8st    13    da:30:a7:11:92:36   {-38, 48, -89, 17, -110, 54}</p>
<p>根据上面结果可以看出mac地址在转成byte的数组之后，参与计算的后两位元素并不是完全相同，由此可知datacenterId是不一样的，按道理应该不会产生一样的标识位，再根据雪花算法的数据组成机构推，也不应该生成相同的id。</p>
<p>既然算法没问题，那么我们回到问题本身，看一下开始出现这个问题的时间点上：</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/%E9%97%AE%E9%A2%98%E7%8E%B0%E5%9C%BA2" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/%E5%90%AF%E5%8A%A8%E6%B6%88%E6%81%AF" alt="img"></p>
<h2 id="三、推论"><a href="#三、推论" class="headerlink" title="三、推论"></a>三、推论</h2><p>根据上述排查过程，我们可以得出两个推论：</p>
<p>1.当前产线运行的4个pod，mac地址后两位不都是一样的，所以按照雪花算法的设计，到下次服务重启之间，应该都不会出现id重复的问题。</p>
<p>2.在上个版本产线运行的pod中存在mac地址后两位一样的pod，这就导致datacenterId是一样的，所以在一定并发量的情况下，就可能会出现一样的雪花id</p>
<h2 id="四、优化方案"><a href="#四、优化方案" class="headerlink" title="四、优化方案"></a>四、优化方案</h2><p>通过上述对问题的排查与验证之后，方案也呼之欲出了，即使用Sequence的有参构造方法替代无参构造。</p>
<h2 id="方案概述"><a href="#方案概述" class="headerlink" title="方案概述"></a>方案概述</h2><p>这边提供一下借助Nacos元数据实现的方案：</p>
<ol>
<li><p>通过在nacos元数据中新增服务注册时间</p>
</li>
<li><p>服务启动之后拉取实例列表，并通过元数据中的注册时间进行排序</p>
</li>
<li><p>计算每个实例在实例列表中的位置，将计算出的workerId写入实例的元数据中</p>
</li>
</ol>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><ol>
<li><p>服务启动时，将服务注册时间写入nacos元数据中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"> <span class="meta">@Configuration</span></span><br><span class="line"> <span class="meta">@ConditionalOnNacosDiscoveryEnabled</span></span><br><span class="line"> <span class="meta">@AutoConfigureBefore(&#123;SimpleDiscoveryClientAutoConfiguration.class, CommonsClientAutoConfiguration.class&#125;)</span></span><br><span class="line"> <span class="meta">@ConditionalOnProperty(name = &quot;info.snowflake.generate.enabled&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosDiscoveryClientConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> NacosDiscoveryProperties <span class="title">nacosProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     NacosDiscoveryProperties nacosDiscoveryProperties = <span class="keyword">new</span> NacosDiscoveryProperties();</span><br><span class="line">     Map&lt;String, String&gt; metadata = nacosDiscoveryProperties.getMetadata();</span><br><span class="line">     metadata.put(<span class="string">&quot;register.time&quot;</span>, String.valueOf(System.nanoTime()));</span><br><span class="line">     <span class="keyword">return</span> nacosDiscoveryProperties;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听服务可用(可对外提供服务)事件</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> \* 监听服务可用事件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> \* <span class="doctag">@author</span> heyou</span></span><br><span class="line"><span class="comment"> \* <span class="doctag">@date</span> 2022-07-25 17:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Component</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitWorkerIdListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationReadyEvent</span>&gt; </span>&#123;</span><br><span class="line">   <span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> WorkerIdComponent workerIdComponent;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationReadyEvent readyEvent)</span> </span>&#123;</span><br><span class="line">     Long workerId = workerIdComponent.initWorkerId();</span><br><span class="line">     <span class="comment">// 获取Bean</span></span><br><span class="line">     DefaultSqlSessionFactory mybatisSqlSessionFactoryBean = SpringUtil</span><br><span class="line">         .getBean(<span class="string">&quot;mybatisSqlSessionFactoryBean&quot;</span>, DefaultSqlSessionFactory.class);</span><br><span class="line">     <span class="keyword">if</span> (Objects.nonNull(mybatisSqlSessionFactoryBean)) &#123;</span><br><span class="line">       MybatisConfiguration configuration = (MybatisConfiguration) mybatisSqlSessionFactoryBean.getConfiguration();</span><br><span class="line">       <span class="keyword">if</span> (Objects.nonNull(configuration)) &#123;</span><br><span class="line">         GlobalConfig globalConfig = configuration.getGlobalConfig();</span><br><span class="line">         globalConfig.setWorkerId(workerId);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当监听到可用事件时，说明整个服务已经完全启动成功，并可以对外提供服务了。此时服务也已注册到Nacos中，因此可以拉取到Naocs已注册的服务列表去进行排序和计算workerId</p>
<ol start="3">
<li>计算workerId</li>
</ol>
<p>考虑到存在系统时钟回退的情况，初始的workerId设置为10，1~10用来存储时钟回退的实例workerId。其中<strong>计算workerId中核心逻辑是如何找到当前实例在Nacos服务列表的具体位置</strong>。我们可以借助之前的排序，获取当前实例在排序的index,并将index作为当前实例的workerId  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Long <span class="title">workerId</span><span class="params">(List&lt;Instance&gt; instances, Instance currentInstance)</span> </span>&#123;</span><br><span class="line">     List&lt;Instance&gt; sortedInstances = sortInstance(instances);</span><br><span class="line">     <span class="comment">// 当前实例位置</span></span><br><span class="line">     <span class="keyword">int</span> currentIndex = sortedInstances.indexOf(currentInstance);</span><br><span class="line">     <span class="comment">// 存在workerId的集合</span></span><br><span class="line">     List&lt;Instance&gt; existWorkerIdInstances = instances.stream()</span><br><span class="line">         .filter(instance -&gt; Objects.nonNull(instance.getMetadata().get(WORKER_ID)))</span><br><span class="line">         .collect(Collectors.toList());</span><br><span class="line">     <span class="keyword">if</span> (CollectionUtils.isNotEmpty(existWorkerIdInstances)) &#123;</span><br><span class="line">       <span class="comment">// 获取最大workerId实例作为基准实例</span></span><br><span class="line">       <span class="keyword">int</span> maxWorkerIdIndex = existWorkerIdInstances.size() - <span class="number">1</span>;</span><br><span class="line">       Instance maxWorkerIdInstance = sortedInstances.get(maxWorkerIdIndex);</span><br><span class="line">       <span class="comment">// 偏移量</span></span><br><span class="line">       <span class="keyword">int</span> offset = currentIndex - maxWorkerIdIndex;</span><br><span class="line">       Long workerIdFormMetadata = getWorkerIdFormMetadata(maxWorkerIdInstance);</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (workerIdFormMetadata + offset &lt; START_WORKERID || existWorkerIdInstances.stream()</span><br><span class="line">             .anyMatch(d -&gt; getWorkerIdFormMetadata(d).equals(workerIdFormMetadata + offset))) &#123;</span><br><span class="line">           <span class="comment">// 说明时间回退了</span></span><br><span class="line">           <span class="keyword">return</span> caclBackWorkId(offset, existWorkerIdInstances);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> workerIdFormMetadata + offset;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (workerIdFormMetadata &lt;= START_WORKERID) &#123;</span><br><span class="line">         <span class="comment">// 极端情况 目前存在的几个都是时间回退的</span></span><br><span class="line">         <span class="keyword">return</span> START_WORKERID + <span class="number">1L</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> caclWorkId(offset, maxWorkerIdInstance, existWorkerIdInstances);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 说明不存在任何workid</span></span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">long</span>)(currentIndex + START_WORKERID);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>






























]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title>读写锁介绍与简单实用</title>
    <url>/2020/07/30/%E8%AF%BB%E5%86%99%E9%94%81/</url>
    <content><![CDATA[<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p><code>ReentrantLock</code>保证了只有一个线程可以执行临界区代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Counter &#123;</span><br><span class="line">    private final Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">    private int[] counts &#x3D; new int[10];</span><br><span class="line"></span><br><span class="line">    public void inc(int index) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            counts[index] +&#x3D; 1;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int[] get() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是有些时候，这种保护有点过头。因为我们发现，任何时刻，只允许一个线程修改，也就是调用<code>inc()</code>方法是必须获取锁，但是，<code>get()</code>方法只读取数据，不修改数据，它实际上允许多个线程同时调用。</p>
<p>实际上我们想要的是：允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">读</th>
<th align="left">写</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读</td>
<td align="left">允许</td>
<td align="left">不允许</td>
</tr>
<tr>
<td align="left">写</td>
<td align="left">不允许</td>
<td align="left">不允许</td>
</tr>
</tbody></table>
<p>使用<code>ReadWriteLock</code>可以解决这个问题，它保证：</p>
<ul>
<li>只允许一个线程写入（其他线程既不能写入也不能读取）；</li>
<li>没有写入时，多个线程允许同时读（提高性能）。</li>
</ul>
<p>用<code>ReadWriteLock</code>实现这个功能十分容易。我们需要创建一个<code>ReadWriteLock</code>实例，然后分别获取读锁和写锁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Counter &#123;</span><br><span class="line">    private final ReadWriteLock rwlock &#x3D; new ReentrantReadWriteLock();</span><br><span class="line">    private final Lock rlock &#x3D; rwlock.readLock();</span><br><span class="line">    private final Lock wlock &#x3D; rwlock.writeLock();</span><br><span class="line">    private int[] counts &#x3D; new int[10];</span><br><span class="line"></span><br><span class="line">    public void inc(int index) &#123;</span><br><span class="line">        wlock.lock(); &#x2F;&#x2F; 加写锁</span><br><span class="line">        try &#123;</span><br><span class="line">            counts[index] +&#x3D; 1;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            wlock.unlock(); &#x2F;&#x2F; 释放写锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int[] get() &#123;</span><br><span class="line">        rlock.lock(); &#x2F;&#x2F; 加读锁</span><br><span class="line">        try &#123;</span><br><span class="line">            return Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            rlock.unlock(); &#x2F;&#x2F; 释放读锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把读写操作分别用读锁和写锁来加锁，在读取时，多个线程可以同时获得读锁，这样就大大提高了并发读的执行效率。</p>
<p>使用<code>ReadWriteLock</code>时，适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。</p>
<p>例如，一个论坛的帖子，回复可以看做写入操作，它是不频繁的，但是，浏览可以看做读取操作，是非常频繁的，这种情况就可以使用<code>ReadWriteLock</code>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>使用<code>ReadWriteLock</code>可以提高读取效率：</p>
<ul>
<li><code>ReadWriteLock</code>只允许一个线程写入；</li>
<li><code>ReadWriteLock</code>允许多个线程在没有写入时同时读取；</li>
<li><code>ReadWriteLock</code>适合读多写少的场景。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-运行时数据区与内存溢出异常</title>
    <url>/2021/05/22/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h1><h2 id="区域划分"><a href="#区域划分" class="headerlink" title="区域划分"></a>区域划分</h2><p>JVM 在执行 Java 程序的过程中会把 JVM 中的内存划分为若干不同的数据区域，这些区域由以下几个运行时数据区组成：</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230925092533865.png" alt="image-20230925092533865"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器在整个 JVM 中只占一块较小的内存区域，是<code>当前线程</code>执行的字节码的行号指示器，其作用是在字节码文件执行的时候通过<code>改变计数器的值</code>选取要执行的字节码指令，例如分支、循环、跳转、异常处理等指令都是由依赖程序计数器完成的。</p>
<p>JVM的多线程是通过线程的轮流切换、分配处理器执行时间的方式实现的，在多核处理器环境中，每个线程都拥有自己的程序计数器，不同线程的计数器之间相互不影响，独立存储，即<strong>程序计数器是线程私有的</strong>。</p>
<blockquote>
<p>如果线程正在执行的是一个 Java 方法，则这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果线程正在执行的是naive方法，则该线程的程序计数器值应为空。</p>
</blockquote>
<h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>Java 虚拟机栈也被称为 Java栈，也是线程私有的。其作用是用来描述 Java 方法执行的线程内存模型：每个方法在执行的时候，虚拟机都会同步创建一个<code>栈帧</code>用于存放局部变量表、操作数栈、动态连接、方法出口（返回地址）等信息。</p>
<p><strong>方法从调用到执行完毕的过程其实就是栈帧在Java虚拟机栈中入栈到出栈的过程。</strong></p>
<p><strong>栈帧（Stack Frame）</strong>是用于支持虚拟机进行方法调用和方法执行的数据结构。它是虚拟机运行时数据区中的java虚拟机栈的栈元素，其中：</p>
<ol>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态连接</li>
<li>方法出口</li>
</ol>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与 Java 虚拟机栈作用类似，Java 栈是用来执行 Java 方法的，本地方法栈是服务与本地（Native）方法的，在 HotSpot虚拟机中之间将 Java 栈和本地方法栈合二为一。本地方法栈在栈深度溢出或栈扩展失败时抛出 StackOverflowError 和 OutOfMemoryError异常。</p>
<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><p>Java堆是 JVM内存中最大的一块，由虚拟机在启动时创建。是被所有线程共享的的一块区域，存放的是对象的实例，几乎所有的对象实例和数组都是在堆中完成分配的。</p>
<p>Java 堆又被称为 GC 堆，是 垃圾收集器管理的内存区域，现在的垃圾收集器大部分都是基于分代收集理论设计的，所以 Java 堆中存在不同的分代空间（新生代、老年代、永久代、Eden区、Survivor 区等）这样对 Java 堆的细分目的都是为了更好的进行内存的回收已经更快的内存分配。</p>
<blockquote>
<p>并不是所有的对象都是在 Java 堆上创建的</p>
</blockquote>
<p>Java 堆的大小可以是固定的也可以是扩展的（通过参数-Xmx 和-Xms 设定），如果在 Java 堆中没有内存完成实例的分配，并且堆也无法扩展时，Java 虚拟机就会抛出 OOM 异常。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区是 JVM 用于存储已经被虚拟机加载的类型信息、常量、静态变量、即时编译后的代码缓存等数据。方法区与 Java 堆一样是所有线程共享的内存区域。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分，所以也是所有线程共享的内存区域。Class 文件中除了有类的版本、字段、方法、接口等描述信息外、还有就是常量池表，是用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<blockquote>
<p>运行时常量池相比于Class 文件常量池的另一个重要特点就是具备动态性，Java 语言并不要求常量一定只有在编译器才能产生，也就是说，并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，用的比较多的就是 String类的 intern()方法</p>
</blockquote>
<p>运行时常量池和方法区一样，当方法区/常量池无法再申请到内存时会抛出 OOM 异常。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>高效的读写队列：ConcurrentLinkedQueue 类</title>
    <url>/2020/08/24/%E9%AB%98%E6%95%88%E7%9A%84%E8%AF%BB%E5%86%99%E9%98%9F%E5%88%97%EF%BC%9AConcurrentLinkedQueue%20%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="高效的读写队列：ConcurrentLinkedQueue-类"><a href="#高效的读写队列：ConcurrentLinkedQueue-类" class="headerlink" title="高效的读写队列：ConcurrentLinkedQueue 类"></a>高效的读写队列：ConcurrentLinkedQueue 类</h3><h4 id="一、核心节点Node"><a href="#一、核心节点Node" class="headerlink" title="一、核心节点Node"></a>一、核心节点Node</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> E item;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>item 指的是目标元素，即存入列表的元素</li>
<li>next指的是当前节点 Node 的下一个元素</li>
</ul>
<p>在对 Node 节点进行操作时，使用的是 CAS即比对赋值，这种操作是具有原子性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span></span>&#123;</span><br><span class="line">    UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>casItem()：表示设置当前 Node 的 item 的值，需要两个参数：</p>
<ul>
<li>cmp：期望值</li>
<li>val:目标值</li>
</ul>
<p>当当前值等于cmp期望值时，会将当前值设置为目标值。</p>
</li>
<li><p>casNext：原理同上，只不过作用的对象是 next 字段。</p>
</li>
</ul>
<h4 id="二、重要的字段head-头部-和-tail（尾部）"><a href="#二、重要的字段head-头部-和-tail（尾部）" class="headerlink" title="二、重要的字段head(头部) 和 tail（尾部）"></a>二、重要的字段head(头部) 和 tail（尾部）</h4><ul>
<li>对于 head 来说，它<strong>永远不会为 null</strong>,并且通过 head 及 succ()后继方法一定能完整遍历整个链表。</li>
<li>对于 tail ,它并不总是位于链表的尾部，因为tail 位置的更新不是及时的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Inserts the specified element at the tail of this queue.</span></span><br><span class="line"><span class="comment">    * As the queue is unbounded, this method will never return &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Queue#offer&#125;)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       checkNotNull(e);</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">           Node&lt;E&gt; q = p.next;</span><br><span class="line">           <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// p is last node</span></span><br><span class="line">               <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                   <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                   <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">                   <span class="comment">// and for newNode to become &quot;live&quot;.</span></span><br><span class="line">                   <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                       casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">               <span class="comment">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class="line">               <span class="comment">// will also be off-list, in which case we need to</span></span><br><span class="line">               <span class="comment">// jump to head, from which all live nodes are always</span></span><br><span class="line">               <span class="comment">// reachable.  Else the new tail is a better bet.</span></span><br><span class="line">               p = (t != (t = tail)) ? t : head;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="comment">// Check for tail updates after two hops.</span></span><br><span class="line">               p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>这个方法是没有进行锁操作的。线程的安全性完全由 CAS 操作和队列算法进行保障。</li>
<li>方法的核心是 for 循环，这个循环没有出口，只能在尝试成功后才能进行返回。</li>
</ul>
<p>当第一次加入元素时，由于队列为空，p.next为 null。此时将 p 的 next 节点赋值为 newNode,即完成入队操作。此时 p==t 为 true,所以不会进行更新 tail 操作，而是一直在 for 循环内部操作，直到成功。在此过程中，tail 都不会更新位置的</p>
<p>当试图对第二个元素进行入队操作时，由于 t 在 head的位置上，因此 p.next 指向时间的第一个元素，因此 q!=null 表示 q 不是最好的节点。而入队需要得到最后一个元素的位置，因此开始循环查找最后一个元素：</p>
<p><code>p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</code></p>
<p>此时 p 实际上指向链表的第一个元素，而它的 next 为 null,故在第二个循环时，p 更新自己的 next，让它指向新加入的元素节点，如果成功在会更新 t 的所在位置，将 t 移动到链表的最后。</p>
<p><strong>哨兵(sentinel)节点</strong>：p==q的情况。所谓哨兵节点即 next 指向自己的节点。当遇到哨兵节点，由于无法通过 next 获得后续的节点，因此很能返回 head 重新遍历。进一步找到链表的末尾。如果在执行的过程中 tail 发生改变，会尝试将 tail 作为链表的尾部避免重新查找 tail。</p>
<p>对于<code> p = (t != (t = tail)) ? t : head;</code></p>
<p>注：</p>
<ul>
<li>!=并不是原子操作</li>
<li>在并发环境下 t!=t 是可能会成立的，如果两个 t 不相同表示 tail 被修改了，这时可以将新的 tail 作为链表的尾部，反之则返回 head,即从头部开始重新查找尾部。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis持久化与主从与哨兵架构</title>
    <url>/2021/03/13/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%8E%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>redis是一个内存数据库，数据保存在内存中，用内存的存储的优点就是读写效率高，也容易发生丢失（比如 断电）。而 redis持久化机制的就是为了在异常情况下保存和恢复数据。</p>
<h2 id="RDB-Redis-DataBase-快照"><a href="#RDB-Redis-DataBase-快照" class="headerlink" title="RDB(Redis DataBase) 快照"></a>RDB(Redis DataBase) 快照</h2><p>RDB 快是 Redis 采用的默认持久化方式，该方式会将 redis 数据库快照保存在名为 dump.rdb 的二进制文件中。</p>
<h3 id="save-命令"><a href="#save-命令" class="headerlink" title="save 命令"></a>save 命令</h3><p>在 redis.conf文件中，可以对 RDB 持久化的触发条件进行设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>比如：<code>save 60 10000</code>该设置会让 redis 满足<code>60s 内至少有 1000 个 键被改动</code>这个条件时，redis 会自动保存此时间节点之前所有的数据，并存储在 dump.rdb 文件中。</p>
<p>当然，也可以手动输入 save 命令进行持久化，但是会阻塞其他 redis 命令。每次命令执行都会将所有redis内存快照到一个新的rdb文件里，并覆盖原有rdb快照文件。</p>
<h3 id="bgsave-命令"><a href="#bgsave-命令" class="headerlink" title="bgsave 命令"></a>bgsave 命令</h3><p>与 save 命令类似，该命令的作用也是对 redis 进行一次 RDB持久化。不过与 save 命令不同的是 Redis 借助了操作系统提供的<code>写时复制技术(Copy-On-Write)</code>,在执行 bgsave 命令时，bgsave 会从主线程 fork 一个子进程，并可以共享主线程中的所有内存数据，bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。</p>
<p>此时，如果主线程对这些数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文 件，而在这个过程中，主线程仍然可以直接修改原来的数据。</p>
<h3 id="save-与-bgsave-的比对"><a href="#save-与-bgsave-的比对" class="headerlink" title="save 与 bgsave 的比对"></a>save 与 bgsave 的比对</h3><table>
<thead>
<tr>
<th>命令</th>
<th>save</th>
<th>bgsave</th>
</tr>
</thead>
<tbody><tr>
<td>IO 类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>是否阻塞其他 redis命令</td>
<td>是</td>
<td>否(生成子进程会有短暂阻塞)</td>
</tr>
<tr>
<td>复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>不会消耗额外内存</td>
<td>不阻塞客户端命令</td>
</tr>
<tr>
<td>确定</td>
<td>不阻塞客户端命令</td>
<td>需要 fork 子进程，有额外的内存开销</td>
</tr>
</tbody></table>
<p>注：配置自动生成的 rdb文件使用的命令是 bgsave。</p>
<h2 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h2><p>RDB快照功能并不是非常耐久(durable): 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。于是， Redis 增加了一种完全耐久的持久化方 式: <code>AOF 持久化</code>，将修改的每一条指令记录进文件appendonly.aof中(先写入os cache，每隔一段时间 fsync到磁盘)</p>
<h3 id="AOF介绍"><a href="#AOF介绍" class="headerlink" title="AOF介绍"></a>AOF介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*2</span><br><span class="line">$6</span><br><span class="line">SELECT</span><br><span class="line">$1</span><br><span class="line">0</span><br><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">set</span><br><span class="line">$5</span><br><span class="line">hello</span><br><span class="line">$5</span><br><span class="line">redis</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是一种resp协议格式数据，星号后面的数字代表命令有多少个参数，$号后面的数字代表这个参数有几 个字符 注意，如果执行带过期时间的set命令，aof文件里记录的是并不是执行的原始命令，而是记录key过期的 时间戳</p>
<p>比如执行“set helloworld redis ex 1000”，对应aof文件里记录如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$3</span><br><span class="line">set</span><br><span class="line">$10</span><br><span class="line">helloworld</span><br><span class="line">$5</span><br><span class="line">redis</span><br><span class="line">*3</span><br><span class="line">$9</span><br><span class="line">PEXPIREAT</span><br><span class="line">$10</span><br><span class="line">helloworld</span><br><span class="line">$13</span><br><span class="line">1615705330391</span><br></pre></td></tr></table></figure>

<p>AOF 的方式进行持久化，每次执行命令都会将持久化信息追加到 AOF 文件中，当然也可以在 redis.conf 文件中配置 AOF 持久化的周期策略。</p>
<ul>
<li>appendfsync always:每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全。 </li>
<li> appendfsync everysec:每秒 fsync 一次，足够快，并且在故障时只会丢失 1 秒钟的数据。</li>
<li>appendfsync no:从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。</li>
</ul>
<h3 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h3><p>AOF文件里可能有太多没用指令，所以AOF会定期根据内存的最新数据生成aof文件，AOF 重写会减少无用命令写入 aof文件中。</p>
<p>可以通过以下两个配置控制 AOF 自动重写的频率：</p>
<ul>
<li>auto‐aof‐rewrite‐min‐size 64mb 该命令的作用是：aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大</li>
<li>auto‐aof‐rewrite‐percentage 100 该命令的作用是：aof文件自上一次重写后文件大小增长了100%则再次触发重写</li>
</ul>
<p>当然AOF还可以手动重写，进入redis客户端执行命令bgrewriteaof重写AOF 。</p>
<p>注意，AOF重写redis会fork出一个子进程去做(与bgsave命令类似)，不会对redis正常命令处理有太多影响。</p>
<h3 id="RDB-与-AOF-的比对"><a href="#RDB-与-AOF-的比对" class="headerlink" title="RDB 与 AOF 的比对"></a>RDB 与 AOF 的比对</h3><table>
<thead>
<tr>
<th>持久化类型</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>块</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>容易丢失数据</td>
<td>由配置的策略决定</td>
</tr>
</tbody></table>
<p>注：redis启动时如果既有rdb文件又有aof文件则优先选择aof文件恢复数据，因为aof 一般来说数据更全一点。</p>
<h2 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h2><p>重启 Redis 时，我们很少使用 RDB来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重 放，但是重放 AOF 日志性能相对 RDB来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很 长的时间。 所谓混合持久化就是结合 RDB 和 AOF 进行持久化数据。</p>
<p>使用混合持久化方式的前提是开启 AOF<code>aof‐use‐rdb‐preamble yes</code></p>
<p>如果开启了混合持久化，AOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将 <strong>重写这一刻之前的内存做RDB快照</strong>处理，并且将RDB快照内容和增量的AOF修改内存数据的命令存在一 起，<strong>都写入新的AOF文件</strong>，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换。</p>
<p>于是在 Redis 重启的时候，可以先加载 RDB 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，因此重启效率大幅得到提升。</p>
<h1 id="主从与哨兵架构"><a href="#主从与哨兵架构" class="headerlink" title="主从与哨兵架构"></a>主从与哨兵架构</h1><h2 id="Redis-主从架构"><a href="#Redis-主从架构" class="headerlink" title="Redis 主从架构"></a>Redis 主从架构</h2><p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230906222419274.png" alt="image-20230906222419274"></p>
<h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、复制一份redis.conf文件</span><br><span class="line">2、将相关配置修改为如下值:</span><br><span class="line">port6380</span><br><span class="line"># 把pid进程号写入pidfile配置的文件</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6380.pid </span><br><span class="line">logfile&quot;6380.log&quot;</span><br><span class="line"># 指定数据存放目录</span><br><span class="line">dir &#x2F;usr&#x2F;local&#x2F;redis‐5.0.3&#x2F;data&#x2F;6380  </span><br><span class="line"># 需要注释掉bind</span><br><span class="line">#bind127.0.0.1(bind绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip，代表允许客户端通 过机器的哪些网卡ip去访问，内网一般可以不配置bind，注释掉即可)</span><br><span class="line"></span><br><span class="line">3、配置主从复制</span><br><span class="line">#从本机6379的redis实例复制数据，Redis5.0之前使用 slaveof</span><br><span class="line">replicaof 127.0.0.1 6379</span><br><span class="line"># 配置从节点只读</span><br><span class="line">replica‐read‐only yes </span><br><span class="line"></span><br><span class="line">4、启动从节点</span><br><span class="line">redis‐serverredis.conf</span><br><span class="line"></span><br><span class="line">5、连接从节点</span><br><span class="line">redis‐cli ‐p 6380</span><br><span class="line">6、测试在6379实例上写数据，6380实例是否能及时同步新修改数据</span><br><span class="line">7、可以自己再配置一个6381的从节点</span><br></pre></td></tr></table></figure>

<h2 id="主从架构原理"><a href="#主从架构原理" class="headerlink" title="主从架构原理"></a>主从架构原理</h2><p>当为master配置了一个slave，不管这个slave是否是第一次连接上Master，它都会发送一个PSYNC命令给master请求复制数据。</p>
<p>master收到PSYNC命令后，会在后台进行数据持久化通过bgsave生成最新的rdb快照文件。</p>
<p>持久化期间，master会继续接收客户端的请求，它会把这些可能修改数据集的请求缓存在内存中。</p>
<p>当持久化进行完毕以后，master会把这份rdb文件数据集发送给slave，slave会把接收到的数据进行持久化生成rdb，然后 再加载到内存中。</p>
<p>然后，master再将之前缓存在内存中的命令发送给slave。 当master与slave之间的连接由于某些原因而断开时，slave能够自动重连Master，如果master收到了多 个slave并发连接请求，它只会进行一次持久化，而不是一个连接一次，然后再把这一份持久化的数据发送 给多个并发连接的slave。</p>
<p><strong>主从(全量)复制流程</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gojjfkowa7j216l0u0n1d.jpg"></p>
<p><strong>数据部分复制</strong></p>
<p>当master和slave断开重连后，一般都会对整份数据进行复制。但从redis2.8版本开始，redis改用可以<strong>支持部分数据复制的命令PSYNC去master同步数据</strong>，slave与master能够在网络连接断开重连后只进行<code>部分数据复制(断点续传)</code>。</p>
<p>master会在其内存中创建一个用于复制数据的缓存队列，缓存最近一段时间的数据，master和它所有的 slave都维护了复制的<code>数据下标offse</code>t和<code>master的进程id</code>.</p>
<p>因此，当网络连接断开后，slave会请求master 继续进行未完成的复制，从所记录的数据下标开始。如果master进程id变化了，或者从节点数据下标 offset太旧，已经不在master的缓存队列里了，那么将会进行一次全量数据的复制。</p>
<p><strong>主从复制(部分复制，断电续传)</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gojko99ri2j213i0u0q6c.jpg"></p>
<p>如果有很多从节点，为了缓解<code>主从复制风暴</code>(多个从节点同时复制主节点导致主节点压力过大)，可以做如 下架构，让部分从节点与从节点(与主节点同步)同步数据。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gojkqnhrljj20re0lm0u2.jpg"></p>
<h2 id="Redis哨兵高可用架构"><a href="#Redis哨兵高可用架构" class="headerlink" title="Redis哨兵高可用架构"></a>Redis哨兵高可用架构</h2><p>与主从架构不同的是，哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过 sentinel代理访问redis的主节点，当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis 主节点通知给client端(这里面redis的client端一般都实现了订阅功能，订阅sentinel发布的节点变动消息)</p>
<p>注：sentinel哨兵是特殊的redis服务，不提供读写服务，主要用来监控redis实例节点。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1goju9j735fj21ic0tsgox.jpg"></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>与哨兵架构相关的配置是在sentinel.conf 文件中。</p>
<p><strong>redis哨兵架构搭建步骤</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、复制一份sentinel.conf文件</span><br><span class="line">cp sentinel.conf sentinel-26379.conf</span><br><span class="line"></span><br><span class="line">2、将相关配置修改为如下值：</span><br><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile &quot;&#x2F;var&#x2F;run&#x2F;redis-sentinel-26379.pid&quot;</span><br><span class="line">logfile &quot;26379.log&quot;</span><br><span class="line">dir &quot;&#x2F;usr&#x2F;local&#x2F;redis-5.0.3&#x2F;data&quot;</span><br><span class="line"># sentinel monitor &lt;master-redis-name&gt; &lt;master-redis-ip&gt; &lt;master-redis-port&gt; &lt;quorum&gt;</span><br><span class="line"># quorum是一个数字，指明当有多少个sentinel认为一个master失效时(值一般为：sentinel总数&#x2F;2 + 1)，master才算真正失效</span><br><span class="line"># mymaster这个名字随便取，客户端访问时会用到</span><br><span class="line">sentinel monitor redis_master 127.0.0.1 6379 2   # quorum&#x3D;2</span><br><span class="line"></span><br><span class="line">3、启动sentinel哨兵实例</span><br><span class="line">src&#x2F;redis-sentinel sentinel-26379.conf</span><br><span class="line"></span><br><span class="line">4、查看sentinel的info信息</span><br><span class="line">src&#x2F;redis-cli -p 26379</span><br><span class="line">127.0.0.1:26379&gt;info</span><br><span class="line">可以看到Sentinel的info里已经识别出了redis的主从</span><br></pre></td></tr></table></figure>

<p>当哨兵集群启动完毕后，会将哨兵集群的元数据信息通过追加的方式写入到所有的 sentinel 的配置文件中（文件的最下方）。</p>
<p>当 redis 主节点宕机，哨兵集群就会重新选举新的 redis 节点成为主节点，同时修改所有 sentinel 节点配置文件的集群元数据信息。同时也会修改之前配置的 master 节点的端口，修改成当前选举出来的 master 节点的端口。</p>
<p>如果之前挂掉的 master 节点再次启动时，哨兵集群根据集群元数据信息将此节点作为 salve 节点加入到集群中。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发编程（八）AQS（队列同步器）</title>
    <url>/2021/01/08/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89AQS%EF%BC%88%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%EF%BC%89/</url>
    <content><![CDATA[<h1 id="AQS理解"><a href="#AQS理解" class="headerlink" title="AQS理解"></a>AQS理解</h1><h2 id="管程——Java同步的设计思想"><a href="#管程——Java同步的设计思想" class="headerlink" title="管程——Java同步的设计思想"></a>管程——Java同步的设计思想</h2><ul>
<li>管程:指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。</li>
<li>互斥:同一时刻只允许一个线程访问共享资源;</li>
<li>同步:线程之间如何通信、协作。</li>
</ul>
<h2 id="MESA管程模型"><a href="#MESA管程模型" class="headerlink" title="MESA管程模型"></a>MESA管程模型</h2><p>在管程的发展史上，先后出现过三种不同的管程模型，分别是Hasen模型、Hoare模型和MESA模 型。现在正在广泛使用的是<strong>MESA模型</strong>。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230905141220830.png" alt="image-20230905141220830"></p>
<p>管程中引入了条件变量的概念，而且每个条件变量都对应有一个等待队列。条件变量和等待队列的<br>作用是解决线程之间的同步问题。</p>
<h2 id="AQS原理分析"><a href="#AQS原理分析" class="headerlink" title="AQS原理分析"></a>AQS原理分析</h2><h3 id="AQS的定义"><a href="#AQS的定义" class="headerlink" title="AQS的定义"></a>AQS的定义</h3><p>AQS即AbstractQueuedSynchronizer的简称，是J.U.C包中大多数同步器的实现基础。AQS是一个抽象同步框架，可以用来实现一个依赖状态的同步器。</p>
<p>一般是通过一个内部类Sync继承 AQS 将同步器所有调用都映射到Sync对应的方法</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230905141738851.png" alt="image-20230905141738851"></p>
<h3 id="主要方法源码"><a href="#主要方法源码" class="headerlink" title="主要方法源码"></a>主要方法源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子操作（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它使用一个 int变量表示同步状态，通过内置的 FIFO 队列来完成资源获取线程的排队工作，并且使用 CAS 操作进行状态的修改（即 protected 修饰的 getState()/setState()/compareAndSetState()）</p>
<h3 id="AQS的核心结构"><a href="#AQS的核心结构" class="headerlink" title="AQS的核心结构"></a>AQS的核心结构</h3><p>其实AQS的核心结构大体就是MESA模型包含的属性：AQS内部维护属性<code>volatile int state state</code>表示资源的可用状态：State三种访问方式: getState()/setState()，compareAndSetState() </p>
<p>定义了两种资源访问方式:</p>
<ul>
<li><p>Exclusive-独占，只有一个线程能执行，如ReentrantLock</p>
</li>
<li><p>Share-共享，多个线程可以同时执行，如Semaphore/CountDownLatch</p>
</li>
</ul>
<p>AQS实现时主要实现以下几种方法:</p>
<ul>
<li>isHeldExclusively():该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li> tryAcquire(int):独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li> tryRelease(int):独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>
<li> tryAcquireShared(int):共享方式。尝试获取资源。负数表示失败;0表示成功，但没有剩余可用资源;正数表 示成功，且有剩余资源。 </li>
<li>tryReleaseShared(int):共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回 false。</li>
</ul>
<h2 id="AQS的实现分析"><a href="#AQS的实现分析" class="headerlink" title="AQS的实现分析"></a>AQS的实现分析</h2><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>AQS 依赖内部的同步队列（基于 CLH队列锁实现的双向队列）来完成同步状态的管理，当线程获取同步状态失败时，同步器会构建一个 Node 节点对象加入到队列中，并阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态</p>
<h3 id="节点组成"><a href="#节点组成" class="headerlink" title="节点组成"></a>节点组成</h3><p>节点对象包含：</p>
<ul>
<li>获取同步状态失败的线程引用</li>
<li>等待状态</li>
<li>前驱节点和后继节点</li>
<li>节点的属性（名称和描述）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">         * unconditionally propagate</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Status field, taking on only the values:</span></span><br><span class="line"><span class="comment">         *   SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment">         *               blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment">         *               unpark its successor when it releases or</span></span><br><span class="line"><span class="comment">         *               cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment">         *               first indicate they need a signal,</span></span><br><span class="line"><span class="comment">         *               then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment">         *               on failure, block.</span></span><br><span class="line"><span class="comment">         *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span><br><span class="line"><span class="comment">         *               Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment">         *               a thread with cancelled node never again blocks.</span></span><br><span class="line"><span class="comment">         *   CONDITION:  This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment">         *               It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment">         *               until transferred, at which time the status</span></span><br><span class="line"><span class="comment">         *               will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment">         *               nothing to do with the other uses of the</span></span><br><span class="line"><span class="comment">         *               field, but simplifies mechanics.)</span></span><br><span class="line"><span class="comment">         *   PROPAGATE:  A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment">         *               nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment">         *               doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment">         *               continues, even if other operations have</span></span><br><span class="line"><span class="comment">         *               since intervened.</span></span><br><span class="line"><span class="comment">         *   0:          None of the above</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment">         * Non-negative values mean that a node doesn&#x27;t need to</span></span><br><span class="line"><span class="comment">         * signal. So, most code doesn&#x27;t need to check for particular</span></span><br><span class="line"><span class="comment">         * values, just for sign.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The field is initialized to 0 for normal sync nodes, and</span></span><br><span class="line"><span class="comment">         * CONDITION for condition nodes.  It is modified using CAS</span></span><br><span class="line"><span class="comment">         * (or when possible, unconditional volatile writes).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h3><table>
<thead>
<tr>
<th>waitStatus</th>
<th>状态描述</th>
</tr>
</thead>
<tbody><tr>
<td>CANCELLED</td>
<td>值为 1，由于在同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待，节点进入该状态将不会变化</td>
</tr>
<tr>
<td>SIGNAL</td>
<td>值为-1，后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或被取消，将会通知后继节点，使后继节点的线程得以运行</td>
</tr>
<tr>
<td>CONDITION</td>
<td>值为-2，节点在等待队列中，节点线程等待在 Condition 上，当其他线程对 Condition 调用了 signal()方法后，该节点将会从等待队列中转移到同步队列中，加入到对同步状态的获取中</td>
</tr>
<tr>
<td>PROPAGATE</td>
<td>值为-3，表示下一次共享式同步状态的获取将会无条件的被传播下去</td>
</tr>
</tbody></table>
<h3 id="队列的基本数据结构"><a href="#队列的基本数据结构" class="headerlink" title="队列的基本数据结构"></a>队列的基本数据结构</h3><p>Node节点是构建 AQS 的基础,同步器拥有首节点（head）和尾结点（tail），没有成功获取到同步状态的线程将会成为节点加入到队列的尾部，同步队列的基本结构如下图：</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230905144218439.png" alt="image-20230905144218439"></p>
<p>如上图所示，同步器中的每个节点包含两个节点引用（前驱节点和后继节点）。</p>
<h3 id="入队与出队"><a href="#入队与出队" class="headerlink" title="入队与出队"></a>入队与出队</h3><ul>
<li>入队：当一个线程获得同步状态，其他线程将无法获取到同步状态，转而被构造成一个节点并加入到同步队列中，而这个<strong>加入队列的过程必须保证线程安全</strong>，因此 AQS 提供了一个设置尾结点的方法：compareAndSetTail(Node expect, Node update)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS tail field. Used only by enq.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果参数 expect 就是当前队列的尾结点，则将新的 update 节点更新到旧尾结点之后，从而代替成为新的队列尾结点。</p>
<ul>
<li>出队：AQS队列遵循 FIFO 原则，当首节点所在的线程是否同步状态时，将会唤醒后继节点，而当后继节点成功获得同步状态时将自己设置成首节点，后继节点成功首节点的过程不需要保证线程安全，因为只有一个线程可以获得同步状态，只需要将首节点设置为原首节点的后继节点，并断开原首节点的 next 引用即可完成原首节点的出队与新首节点的更新。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS head field. Used only by enq.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetHead</span><span class="params">(Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, headOffset, <span class="keyword">null</span>, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="独占式同步状态的获取与释放"><a href="#独占式同步状态的获取与释放" class="headerlink" title="独占式同步状态的获取与释放"></a>独占式同步状态的获取与释放</h1><h2 id="独占式的定义"><a href="#独占式的定义" class="headerlink" title="独占式的定义"></a>独占式的定义</h2><p>所谓独占式即在同一个时刻只能有一个线程能成功获取到同步状态。当某一线程成功（独占式）获得同步状态时，该线程会阻塞其他线程对临界区资源的访问。</p>
<h2 id="获取和释放的过程"><a href="#获取和释放的过程" class="headerlink" title="获取和释放的过程"></a>获取和释放的过程</h2><h3 id="获取过程"><a href="#获取过程" class="headerlink" title="获取过程"></a>获取过程</h3><p>从上文Node 节点的源码中可以看到:提供了一个 final 常量来表示当前线程获得同步状态的方式，其中EXCLUSIVE表示以独占式获取同步状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>首先 AQS 提供了一个获得同步状态的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment">     * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment">     * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以独占模式获取，忽略中断。通过至少调用一次{@link #tryAcquire}实现，成功时返回。否则，线程将进入队列，可能会反复阻塞和解除阻塞，调用{@link #tryAcquire}直到成功。这个方法可以用来实现方法{@link Lock# Lock}。</p>
<p>如果获取同步状态失败，则构建独占式同步节点，并通过 addWaiter(Node node)方法将该节点加入到同步队列的尾部，最后调用 acquireQueued(Node node, int arg)方法，使得该节点以死循环的方式获得同步状态。</p>
<p>如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 enq(final Node node)方法中，同步器通过“死循环”来保证节点的正确添加，在“死循环”中只有通过 CAS将节点设置成为尾结点之后，当前线程才能从方法中返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Node t = tail;</span><br><span class="line">           <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                   tail = head;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               node.prev = t;</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                   t.next = node;</span><br><span class="line">                   <span class="keyword">return</span> t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>节点进入同步队列之后会进入自旋，每个节点都是自省地观察，当条件满足，获取到同步状态，就从自旋中退出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment">    * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                   setHead(node);</span><br><span class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                   failed = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">return</span> interrupted;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在上述方法中，当前线程在“死循环”中尝试获取同步状态，而只有前驱节点是头结点才能尝试获取同步状态，原因有以下两点：</p>
<ul>
<li>头结点是成功获取同步状态的节点，而头结点的线程释放同步状态之后，将会唤醒后继节点，后继节点的线程被唤醒后需要坚持自己的前驱节点是否是头结点。</li>
<li>维护同步队列的 FIFIO 原则。</li>
</ul>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230905145605750.png" alt="image-20230905145605750"></p>
<h3 id="释放过程"><a href="#释放过程" class="headerlink" title="释放过程"></a>释放过程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment"> * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment"> * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法执行时会唤醒头结点的后继节点线程，通过unparkSuccessor方法来唤醒等待状态的线程。</p>
<h1 id="共享式同步状态的获取与释放"><a href="#共享式同步状态的获取与释放" class="headerlink" title="共享式同步状态的获取与释放"></a>共享式同步状态的获取与释放</h1><h2 id="共享式的定义"><a href="#共享式的定义" class="headerlink" title="共享式的定义"></a>共享式的定义</h2><p>与独占式最大的不同就是：共享式在同一时刻能支持度过线程同时获得同步状态。比如说在文件的读写中，如果一个程序或者线程对文件进行读操作，那么这一时刻对于文件的写操作均被阻塞，而读操作可以多个线程同时进行，即写操作为独占式，读操作为共享式。</p>
<h2 id="获取与释放的过程"><a href="#获取与释放的过程" class="headerlink" title="获取与释放的过程"></a>获取与释放的过程</h2><h3 id="获取过程-1"><a href="#获取过程-1" class="headerlink" title="获取过程"></a>获取过程</h3><p>通过调用同步器的 acquireShared(int arg)方法可以共享式地获取同步状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared mode, ignoring interrupts.  Implemented by</span></span><br><span class="line"><span class="comment"> * first invoking at least once &#123;<span class="doctag">@link</span> #tryAcquireShared&#125;,</span></span><br><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquireShared&#125; until success.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment"> *        and can represent anything you like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 acquireShared(int arg)方法中，同步器调用 tryAcquireShared(int arg)方法尝试获取同步状态，tryAcquireShared(int arg)方法返回值为 int 类型，当返回值大于等于 0时，表示能够获取到同步状态。因此在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是：<strong>tryAcquireShared(int arg)方法返回值大于等于 0</strong>。</p>
<p>在 doAcquireShared(int arg)方法的自旋过程中，如果当前节点的前驱为头结点时，尝试获取同步状态，如果返回值大于等于 0，表示该次获取同步状态成功并从自旋中退出。</p>
<h3 id="释放过程-1"><a href="#释放过程-1" class="headerlink" title="释放过程"></a>释放过程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases in shared mode.  Implemented by unblocking one or more</span></span><br><span class="line"><span class="comment"> * threads if &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; returns true.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment"> *        and can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryReleaseShared&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与独占式相同，共享式也需要释放同步状态，通过调用方法releaseShared(int arg)进行同步状态的释放。该方法释放同步状态之后，将会唤醒后续处于等待状态的节点。它和独占式主要的区别在于tryReleaseShared方法必须确保同步状态线程安全释放，因为释放同步状态的操作会来自多个线程，一般通过循环和 CAS 来保证。</p>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发编程（九）锁</title>
    <url>/2021/01/15/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AB%EF%BC%89%E9%94%81/</url>
    <content><![CDATA[<h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a><a href="https://he-you.github.io/2020/12/21/synchronized%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">Synchronized</a></h1><h2 id="偏向锁（可重入）"><a href="#偏向锁（可重入）" class="headerlink" title="偏向锁（可重入）"></a>偏向锁（可重入）</h2><p>当线程访问同步块并获得锁时，会在<strong>对象头</strong>和<strong>栈帧</strong>中的锁记录里面存储<strong>锁偏向的线程 ID</strong>,以后该线程在进入和退出同步块时不需要进行 CAS操作来加锁和解锁，只需要简单的测试一下对象头中的 Mark Word里是否存储着指向当前线程的偏向锁。如果成功则表示已经获得锁，如果失败了，则需要再测试对象头中 Mark Word 中偏向锁的标识是否设置成 1，如果没有则需要进行 CAS 操作竞争锁，如果设置了，则尝试使用 CAS将对象头的偏向锁指向当前线程。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm0ijhfg49j315m0u0mzq.jpg"></p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>线程在执行同步块之前，JVM 会在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称之为 <strong>Displaced Mark Word</strong>，然后线程尝试使用 CAS 将对象头中的 Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败则表示其他线程竞争锁，当前线程会尝试使用自旋来获得锁。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmpli30nr2j30rg150aco.jpg"></p>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>轻量级锁解锁时，<strong>使用 CAS 操作将 Displaced Mark Word 替换回到对象头</strong>，如果成功则表示没有出现竞争，如果失败表示当前锁存在竞争，此时锁就会膨胀成重量级锁。</p>
<p>一<strong>旦锁升级到重量级锁，此时锁就无法恢复到轻量级锁状态</strong>，处于这个状态（重量级锁）不会出现自旋，其他线程尝试获得锁时都会被阻塞，知道当前持有重量级锁的线程释放锁之后再去唤醒这些锁，继续进行锁的竞争。</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁与解锁不需要额外的消耗，执行效率高</td>
<td>线程之间存在竞争时，会带来撤销锁的消耗</td>
<td>只适用于一个线程访问同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高程序的响应时间</td>
<td>存在一直自旋消耗 CPU的情况</td>
<td>追求响应时间</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不会出现自旋情况</td>
<td>线程阻塞，响应时间慢</td>
<td>追求吞吐量，同步块执行速度快</td>
</tr>
</tbody></table>
<h1 id="监视器锁"><a href="#监视器锁" class="headerlink" title="监视器锁"></a>监视器锁</h1><p>Monitor监视器锁是依赖于底层的操作系统的Mutex Lock来实现的。</p>
<p>重量级锁，也就是通常所说的synchronized对象锁，<strong>锁标识为10</strong>，其中指针指向monitor对象（也称之为管程或者监视器锁）的起始地址。每个对象都存在一个monitor与之关联，对象与其monitor之间也存在着多种实现方式，如monitor可以与对象一起创建或者销毁或当前线程试图获取锁时自动生成，但当一个monitor被某线程持有后，它便处于锁定状态。在Java虚拟机（HotSpot）中，monitor是有ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>;        <span class="comment">// 记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;    <span class="comment">// 记录当前持有锁的线程ID</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>;    <span class="comment">// 等待池：处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ;    <span class="comment">// 锁池：处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ObjectMonitor 中有两个队列，<code>_WaitSet</code>和<code> _EntryList</code> ,用来保存ObjectWaiter 对象列表，每个等待锁的线程都会被封装成ObjectWaiter 对象，<code>_owner</code> 指向持有ObjectMonitor 对象的线程，当多个线程同时访问同一同步代码块或者同步方法时，首先会进入<code> _EntryList</code> 队列，当线程获取到monitor 后进入<code>_Owner</code> 区域并把 monitor中的 <code>_Owner</code> 变量设置为当前线程，同时monitor 中的计数器count 加1，若线程调用wait() 方法，将释放当前持有的monitor，<code>_owner</code>变量恢复为null，count 自减 1 ，同时该线程进入<code>_WaitSet</code> 集合中等待被唤醒。若当前线程执行完毕也将释放monitor（锁）并复位变量的值，以便其他线程进入获取monitor（锁）。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmplvc07vhj30gh0a0myq.jpg"></p>
<p>Monitor对象包含以下三个字段：</p>
<ul>
<li>_<strong>owner</strong> 记录当前持有锁的线程ID</li>
<li>_<strong>EntryList</strong> 是一个队列，记录所有阻塞等待锁的线程（阻塞队列，锁池）</li>
<li>_<strong>WaitSet</strong> 也是一个队列，记录调用 wait() 方法并还未被通知的线程（等待池）</li>
</ul>
<p>当线程持有锁的时候，线程id等信息会拷贝进owner字段，其余线程会进入阻塞队列entrylist，当持有锁的线程执行wait方法，会立即释放锁进入waitset，当线程释放锁的时候，owner会被置空，公平锁条件下，entrylist中的线程会竞争锁，竞争成功的线程id会写入owner，其余线程继续在entrylist中等待。</p>
<p>采用Synchronized给对象加锁(重量级锁)会使线程阻塞，因而会造成线程状态的切换，而线程状态的切换必须要操作系统来执行，因此需要将用户态切换为内核态，这个切换的过程是十分耗时的都需要操作系统来帮忙，有可能比用户执行代码的时间还要长。</p>
<p>所以，monitor对象存在于每一个java对象的对象头（存储指针的指向），synchronized锁便是通过这种方式获取的，也是为什么java中任何对象都可以作为锁的原因，同时也是 notify/notifyAll/wait 方法等存在于顶级对象Object中的原因。</p>
<h1 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h1><p>Lock接口提供的Synchronized 关键字不具备的主要特性</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>尝试非阻塞地获取锁</td>
<td>当前线程尝试获取锁，如果这一时刻没有被其他线程获取到，则成功获取并持有锁</td>
</tr>
<tr>
<td>能被中断地获取锁</td>
<td>获取到锁的线程能够响应中断，当获取待锁的线程被中断时，中断异常将会抛出，同时锁会被释放</td>
</tr>
<tr>
<td>超时获取锁</td>
<td>在指定的截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回</td>
</tr>
</tbody></table>
<p>Lock提供的主要API</p>
<ul>
<li>void lock(); 获取锁，当锁获得后从该方法返回</li>
<li>void lockInterruptibly() throws InterruptedException; 可中断地获取锁，和 lock()方法的不同在于该方法或响应中断，即在锁的获取中可以中断当前线程</li>
<li>boolean tryLock();尝试非阻塞的获取锁，调用该方法后立即返回，如果能够获取则返回 true，否则返回 false</li>
<li>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;超时的获取锁，当线程在以下 3 种情况会返回：<ol>
<li>当前线程在超时时间内获得锁</li>
<li>当前线程在超时时间内被中断</li>
<li>超时时间结束，返回 false</li>
</ol>
</li>
<li> void unlock();释放锁</li>
<li>Condition newCondition();获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的 wait()方法，而调用后，当前线程将释放锁。</li>
</ul>
<h2 id="重入锁-ReentrantLock"><a href="#重入锁-ReentrantLock" class="headerlink" title="重入锁(ReentrantLock)"></a>重入锁(ReentrantLock)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>顾名思义就是支持重进入的锁，表示该锁能够支持一个线程对资源的重复加锁。此外，该锁还支持获取锁时的公平与非公平性选择。所谓重进入是指任意线程在获取到锁之后能够再次获取该锁而不被锁阻塞。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现可重新进入锁的特性需要解决两个问题：<code>线程再次获取锁</code>和<code>锁的最终释放</code></p>
<p>ReentrantLock 是通过组合自定义同步器来实现锁的获取与释放，以非公平锁为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment">  * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">     <span class="keyword">int</span> c = getState();</span><br><span class="line">     <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">             setExclusiveOwnerThread(current);</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">         <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">         <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">         setState(nextc);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>该方法增加了再次获取同步状态的逻辑：</p>
<p>通过判断当前线程是否为获取锁的线程来觉得获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回 true,表示获取同步状态成功。成功获取锁的线程再次获取锁，只是增加了同步状态值。与之对应在释放锁的时候也需要减少同步状态值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果该锁被获取了 n 次，那么 n-1次 tryRelease()方法必须返回 false,只有同步状态完全释放了才能返回 true。即 state最终值为 0 时将占有的线程设置为 null,并返回 true,表示锁释放成功。</p>
<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>在大多数应用场景中，锁的申请都是非公平的，也就是说在默认情况下系统只会在锁的等待队列中随机挑选一个线程，因此不能保证公平性。在 ReentrantLock中，提供了实现公平锁的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment"> * given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当参数 fair 为 true 时，表示锁是公平的。</p>
<h4 id="公平锁和非公平锁的对比"><a href="#公平锁和非公平锁的对比" class="headerlink" title="公平锁和非公平锁的对比"></a>公平锁和非公平锁的对比</h4><ul>
<li>公平锁的一大特点就是不会产生饥饿现象，每个等待的线程获取锁的机会都是相同的。而非公平锁则是随机在等待的线程中挑选一个线程，而且根据系统调度一个线程会倾向于再次获取已经持有的锁。</li>
<li>公平锁为了达到公平性，会额外维护一个有序的队列，因此公平锁的实现成本更高且性能低下；而非公平锁的性能要好于非公平锁，同时极少的线程切换保证了更大的吞吐量。</li>
</ul>
<h1 id="读写锁-ReadWriteLock"><a href="#读写锁-ReadWriteLock" class="headerlink" title="读写锁(ReadWriteLock)"></a>读写锁(ReadWriteLock)</h1><p>读写锁与ReentrantLock(独占锁)不同，支持同一时刻多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁：读锁和写锁。通过分离读锁和写锁，使得并发性相比排他锁游离很大的提升。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 ReentrantReadWriteLock 是JUC 对读写锁的一种实现。有如下特性：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>公平性</td>
<td>支持非公平（默认）和公平性的获取锁方式，非公平性的吞吐量优于公平性</td>
</tr>
<tr>
<td>重进入</td>
<td>支持重进入，以读锁为例：读线程在获取了读锁之后，能够再次获取读锁。而写线程在获取写锁之后能够再次获取写锁，同时也可以获取读锁</td>
</tr>
<tr>
<td>锁降级</td>
<td>遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁</td>
</tr>
</tbody></table>
<p>其中展示内部工作状态的方法有：</p>
<ul>
<li>int getReadLockCount():返回当前<strong>读锁被获取的次数</strong>，而不是线程数。</li>
<li>int getReadHoldCount():返回当前<strong>线程获取读锁的次数</strong>，使用的是 ThreadLocal 保存当前线程的次数。</li>
<li>Boolean isWriteLocked():判断写锁是否被获取</li>
<li>is getWriteHoldCount():返回当前写锁被获取的测试</li>
</ul>
<h2 id="读锁写锁的实现分析"><a href="#读锁写锁的实现分析" class="headerlink" title="读锁写锁的实现分析"></a>读锁写锁的实现分析</h2><h3 id="读写状态的设计"><a href="#读写状态的设计" class="headerlink" title="读写状态的设计"></a>读写状态的设计</h3><ul>
<li>在AQS中，通过<code>int类型</code>的全局变量state来表示同步状态，即用state来表示锁。ReentrantReadWriteLock作为一种 AQS 的实现也是用 AQS 的 state 表示同步状态的，但是ReentrantReadWriteLock有两把锁：读锁和写锁，它们保护的都是同一个资源，那么如何用一个共享变量来区分锁是写锁还是读锁呢？答案就是<code>按位拆分</code>。</li>
<li>由于state是int类型的变量，在内存中<code>占用4个字节，也就是32位</code>。将其拆分为两部分：高16位和低16位，其中<code>高16位用来表示读锁状态，低16位用来表示写锁状态</code>。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmqsivm5owj31ew0pkmz5.jpg"></p>
<p>如上图所示：</p>
<ul>
<li>当设置读锁成功时，就将高16位加1；释放读锁时，将高16位减1</li>
<li>当设置写锁成功时，就将低16位加1，释放写锁时，将第16位减1</li>
</ul>
<p>如何判断当前的 state 的读锁的状态还是写锁的状态？答案就是通过位运算确定。</p>
<ul>
<li>假设锁当前的状态值为S，将S和<strong>16进制</strong>数<code>0x0000FFFF</code>进行<code>与运算</code>，即S&amp;0x0000FFFF，运算时会将高<code>16位全置为0</code>(忽略读锁的状态)，将运算结果记为c，那么c表示的就是写锁的数量。如果c等于0就表示还没有线程获取锁；如果c不等于0，就表示有线程获取到了锁，c等于几就代表写锁重入了几次。</li>
<li>将S<code>无符号右移16位</code>（S&gt;&gt;&gt;16），得到的结果就是<code>读锁的数量</code>。当S&gt;&gt;&gt;16得到的结果不等于0，且c也不等于0时，就表示当前线程既持有了写锁，也持有了读锁。</li>
<li>当成功获取到读锁时，如何对读锁进行加1呢？S +（1&lt;&lt;16）得到的结果，就是将对锁加1。释放读锁是，就进行S - (1&lt;&lt;16)运算。</li>
<li>当成功获取到写锁时，令S+1即表示写锁状态+1；释放写锁时，就进行S-1运算。</li>
<li>由于读锁和写锁的状态值都只占用16位，所以读锁的最大数量为 2<sup>16</sup>-1，写锁可被重入的最大次数为 2<sup>16</sup>-1</li>
</ul>
<p>注：移位运算时，从符号位开始操作。左移&lt;&lt;一位相当于乘以2，右移&gt;&gt;一位相当于除以 2</p>
<h3 id="写锁的获取与释放"><a href="#写锁的获取与释放" class="headerlink" title="写锁的获取与释放"></a>写锁的获取与释放</h3><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walkthrough:</span></span><br><span class="line"><span class="comment">     * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">     *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">     * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">     *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">     * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">     *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">     *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">     *    and set owner.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span></span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法增加了一个读锁是否存在的判断：如果存在读锁，则写锁不能被获取，因为读写锁要确保写锁的操作对读锁可见，确保所有的读线程内存可见性，不会出现脏读的情况。因此只有当其他读线程都释放了读锁，写锁才能被当前线程获取，而一旦写锁被获取，则其他读写线程的后续访问均被阻塞。</p>
<h4 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h4><p>写锁的释放与 ReentrantLock 的释放过程基本类似，每次释放均减少写状态，当写状态为 0 时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。</p>
<h3 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h3><p>读锁是个支持冲进入的共享锁，能够被多个线程同时获取，当没有写线程访问或者写状态为 0 时，读锁总是能被成功的获取（线程安全的增加读状态的值）。</p>
<ul>
<li>如果当前线程已经获取了读锁，增加读状态。</li>
<li>如果当前线程获取读锁时，写锁已经被其他线程获取则当前线程阻塞等待</li>
</ul>
<p>读锁中的读状态是指<code>所有线程</code>读取<code>读锁次数</code>的<code>总和</code>,而各自线程读取读锁的次数只能保存在 ThreadLocal 中，有各自线程维护。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walkthrough:</span></span><br><span class="line"><span class="comment">     * 1. If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">     * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">     *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">     *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">     *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">     *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">     *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">     *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">     *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">     * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">     *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">     *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果其他线程已经获取写锁，则当前线程获取读锁失败，进入等待状态</p>
</li>
<li><p>如果当前线程获取了写锁或者写锁未被获取，则当前线程（通过CAS）增加读状态。</p>
</li>
<li><p>读锁的每次释放均（线程安全的）减少读状态，减少的值是 1&lt;&lt;16。</p>
</li>
</ul>
<h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h3><p>锁降级指的是写锁降级成为读锁。如果是分阶段的完成则不是锁降级，例如：线程先获取写锁，然后释放，在获取读锁。完整的锁降级过程应该是：当前线程持有写锁，然后读取到读锁，随后释放持有的写锁。</p>
<p>锁降级的目的是为了保证数据的可见性，避免在释放写锁和获取读锁之间被其他线程获取写锁更新数据，导致后来的读线程出现脏读的情况。</p>
<p>ReentranReadWriteLock 不支持锁升级，同样是为了数据的可见性。</p>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程（十）ConcurrentHashMap</title>
    <url>/2021/01/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B9%9D%EF%BC%89ConcurrentHashMap/</url>
    <content><![CDATA[<h1 id="ConcurrentHashMap-简介"><a href="#ConcurrentHashMap-简介" class="headerlink" title="ConcurrentHashMap 简介"></a>ConcurrentHashMap 简介</h1><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn6yjawezej31fi0s0q4r.jpg"></p>
<p>JDK1.8之前ConcurrentHashMap数据结构：<strong>Segment 数组 + HashEntry 数组 + 链表</strong>，其中 Segment 是实现线程安全的关键。Segment 是一种可重入锁，也是由 Segment 保证 ConcurrentHashMap 的线程安全。当 HashEntry数据发生变化时，必须先获取与它对应的 Segment 锁。Segment 的个数一旦<strong>初始化就不能改变</strong>，默认 Segment 的个数是 16 个，你也可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发。</p>
<h2 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn6zn5kjovj31fx0u0ju9.jpg"></p>
<p>JDK1.8之前ConcurrentHashMap数据结构：<strong>Node 数组 + 链表/红黑树</strong>,与 HashMap 一样，当Node 数组长度大于 64，且 Hash 冲突链表的节点数量大于 8，链表转为红黑树，但是与 HashMap 不同的是，ConcurrentHashMap 是线程安全容器，线程安全由 CAS 保证。</p>
<h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><h2 id="JDK1-8之前-1"><a href="#JDK1-8之前-1" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>无参构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, empty map with a default initial capacity (16),</span></span><br><span class="line"><span class="comment"> * load factor (0.75) and concurrencyLevel (16).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认初始化容量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认负载因子</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认并发级别（最多支持的线程数）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>有参构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,<span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536</span></span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="comment">// 2的多少次方</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录段偏移量</span></span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="comment">// 记录段掩码</span></span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量</span></span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="comment">//Segment 中的类似于 HashMap 的容量至少是2或者2的倍数</span></span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// create segments and segments[0]</span></span><br><span class="line">    <span class="comment">// 创建 Segment 数组，设置 segments[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 = <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中的 cap 就是 segment 里的 HashEntry 数组的长度，等于 initialCapacity 除以 ssize 的倍数 c,如果 c 大于 1，就会去大于等于 c 的 2 的 N次方，所以 <strong>cap 不是 1 就是 2 的 N次方</strong>。</p>
<p>默认情况下：initialCapacity=16，ssize=16，loadfactor=0.75，通过运算 threshold=(int)cap*loadFactor。</p>
<p>Java 8 之前的 ConcurrnetHashMap 初始化逻辑：</p>
<ol>
<li>必要参数校验。</li>
<li>segments 数组的长度 ssize 是通过concurrencyLevel计算得出的。</li>
<li>校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值。无参构造<strong>默认值并发级别是 16.</strong></li>
<li>寻找并发级别 concurrencyLevel 之上最近的 <strong>2 的幂次方</strong>值，目的是可以通过按位与的散列算法来定位 segments 数组的索引，作为初始化容量大小，<strong>默认是 16</strong>,最大值是1&lt;&lt;16。</li>
<li>记录 segmentShift 偏移量，这个值为【容量 = 2 的N次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>.</li>
<li>记录 segmentMask（散列运算的掩码，掩码的二进制各个位的值都是 1），默认是 ssize - 1 = 16 -1 = 15，最大值是 66535。</li>
<li><strong>初始化 segments[0]**，</strong>默认大小为 2<strong>，</strong>负载因子 0.75<strong>，</strong>扩容阀值是 2*0.75=1.5**，插入第二个值时才会进行扩容。</li>
</ol>
<h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maps the specified key to the specified value in this table.</span></span><br><span class="line"><span class="comment"> * Neither the key nor the value can be null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method</span></span><br><span class="line"><span class="comment"> * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span></span><br><span class="line">    <span class="comment">// 其实也就是把高4位与segmentMask（1111）做与运算</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        <span class="comment">// 如果查找到的 Segment 为空，初始化</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the segment for the given index, creating it and</span></span><br><span class="line"><span class="comment"> * recording in segment table (via CAS) if not already present.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k the index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the segment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="comment">// 判断 u 位置的 Segment 是否为null</span></span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="comment">// 获取0号 segment 里的 HashEntry&lt;K,V&gt; 初始化长度</span></span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="comment">// 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span></span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="comment">// 计算扩容阀值</span></span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">        <span class="comment">// 创建一个 cap 容量的 HashEntry 数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">            <span class="comment">// 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">// 自旋检查 u 位置的 Segment 是否为null</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 使用CAS 赋值，只会成功一次</span></span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Segment 的 put 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 计算要put的数据位置</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// CAS 获取 index 坐标的值</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 容量大于扩容阀值，小于最大容量，进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体的流程：</p>
<p>定位 Segment，然后在 Segment 里面进行插入操作：</p>
<ul>
<li>判断是否需要对 Segment 里面的 HashEntry进行扩容</li>
<li>定位添加元素的位置，然后将其放在 HashEntry 数组里。</li>
</ul>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><ol>
<li>计算得到 key 的存放位置。</li>
<li>遍历指定位置查找相同 key 的 value 值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 计算得到 key 的存放位置</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="comment">// 如果是链表，遍历查找到相同 key 的 value。</span></span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容方法rehash"><a href="#扩容方法rehash" class="headerlink" title="扩容方法rehash"></a>扩容方法rehash</h3><p>ConcurrentHashMap 的扩容<strong>只会扩容到原来的两倍</strong>。老数组里的数据移动到新的数组时，<strong>位置要么不变，要么变为 index+ oldSize</strong>，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="comment">// 老容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 新容量，扩大两倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 新的扩容阀值 </span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新的数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">// 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历老数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。</span></span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                <span class="comment">// 如果当前位置还不是链表，只是一个元素，直接赋值</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// 如果是链表了</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="comment">// 新的位置只可能是不便或者是老的位置+老的容量。</span></span><br><span class="line">                <span class="comment">// 遍历结束后，lastRun 后面的元素位置都是相同的</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="keyword">null</span>; last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    <span class="comment">// 遍历剩余元素，头插法到指定 k 位置。</span></span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头插法插入新的节点</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中最后的两个 for 循环的作用：</p>
<ul>
<li><p>这里第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的。然后把这个作为一个链表赋值到新位置。</p>
</li>
<li><p>第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。</p>
</li>
</ul>
<p>注：在插入元素前会判断 Segment 里的 HashEntry 数组是否超过容量（threshold）,如果超过阈值，则进行数组的扩容，相比于 HashMap 插入元素后扩容，ConcurrentHashMap 可以避免无效的扩容（扩容后没有新元素插入）。</p>
<h2 id="JDK1-8之后-1"><a href="#JDK1-8之后-1" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h2><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        ／／　如果 sizeCtl &lt; <span class="number">0</span> ,说明另外的线程执行CAS 成功，正在进行初始化。</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 让出 CPU 使用权</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> ConcurrentHashMap 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态。</p>
<ol>
<li>-1 说明正在初始化</li>
<li>-N 说明有N-1个线程正在进行扩容</li>
<li>表示 table 初始化大小，如果 table 没有初始化</li>
<li>表示 table 容量，如果 table　已经初始化。</li>
</ol>
<h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//  计算hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 用于记录相应链表的长度</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 判断是否需要初始化数组：如果数组&quot;空&quot;，进行数组初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 初始化数组，后面会详细介绍</span></span><br><span class="line">            tab = initTable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找该 hash 值对应的数组下标，得到第一个节点 f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果数组该位置为空，</span></span><br><span class="line">            <span class="comment">//    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了</span></span><br><span class="line">            <span class="comment">//          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// 到这里就是说，f 是该位置的头结点，而且不为空</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 获取数组该位置的头结点的监视器锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 头结点的 hash 值大于 0，说明是链表</span></span><br><span class="line">                        <span class="comment">// 用于累加，记录链表的长度</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 到了链表的最末端，将这个新值放到链表的最后面</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 调用红黑树的插值方法插入新节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// binCount != 0 说明上面在做链表操作</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span></span><br><span class="line">                    <span class="comment">// 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span></span><br><span class="line">                    <span class="comment">//    具体源码我们就不看了，扩容部分后面说</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="get方法-1"><a href="#get方法-1" class="headerlink" title="get方法"></a>get方法</h3><p>get 方法执行的逻辑是：</p>
<p>1、计算 hash 值<br>2、根据 hash 值找到数组对应位置: (n - 1) &amp; h<br>3、根据该位置处结点性质进行相应查找:</p>
<ul>
<li>如果该位置为 null，那么直接返回 null 就可以了</li>
<li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li>
<li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</li>
<li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断头结点是否就是我们需要的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容方法tryPresize"><a href="#扩容方法tryPresize" class="headerlink" title="扩容方法tryPresize"></a>扩容方法tryPresize</h3><p>ConcurrentHashMap 的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span></span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">// 0.75 * n</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="comment">// 我没看懂 rs 的真正含义是什么，不过也关系不大</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span></span><br><span class="line">                <span class="comment">//    此时 nextTab 不为 null</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></span><br><span class="line">            <span class="comment">//     我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数</span></span><br><span class="line">            <span class="comment">//  调用 transfer 方法，此时 nextTab 参数为 null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。</p>
<p>所以，可能的操作就是执行 <code>1 次 transfer(tab, null) + 多次 transfer(tab, nt)</code>。</p>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>并发容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器--HashMap（一）</title>
    <url>/2021/01/19/Java%E5%AE%B9%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89HashMap/</url>
    <content><![CDATA[<h1 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h1><p>在JDK1.8 之前 HashMap 由 <code>数组+链表</code> 组成的，数组Entry是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</p>
<p>在JDK1.8 以后的版本中当链表长度大于阈值（默认为 8）时，将链表转化为<code>红黑树</code>（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），在解决 Hash 冲突的同时，以减少搜索时间。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="JDK1-8之前的数据结构"><a href="#JDK1-8之前的数据结构" class="headerlink" title="JDK1.8之前的数据结构"></a>JDK1.8之前的数据结构</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmvruqad33j31f20rwabj.jpg"></p>
<p><strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖并返回旧值，不相同就通过拉链法解决哈希冲突。</strong>这样做的目的是使元素能够相对均匀的存储在 HashMap 中,使容器的空间利用率更高。</p>
<p>所谓<code>哈希冲突</code>就是多个元素经过 HashMap 的 哈希算法计算得到的数组索引相同。</p>
<p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong>这里的 hash 方法不是 hashcode 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p>JDK1.8之后的 hash 方法有所改变：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">     <span class="comment">// ^ ：按位异或(相同为 0，不相同为 1)</span></span><br><span class="line">     <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDK1-8之后的数据结构"><a href="#JDK1-8之后的数据结构" class="headerlink" title="JDK1.8之后的数据结构"></a>JDK1.8之后的数据结构</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmxnh63c6nj31c10u0jul.jpg"></p>
<h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;    </span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;   </span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; </span><br><span class="line">    <span class="comment">// 默认的加载因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; </span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table; </span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;   </span><br><span class="line">    <span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>loadFactor加载因子</strong></p>
<p>loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>
<p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。</strong></p>
<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
</li>
<li><p><strong>threshold阈值（临界值）</strong></p>
<p><strong>threshold = capacity * loadFactor</strong>，<strong>当Size&gt;=threshold</strong>的时候，那么就要考虑对数组的扩容了，也就是说，**threshold ** 变量时判断数组是否需要扩容的一个条件。</p>
</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>HashMap 中有四个构造方法，它们分别如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">     <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">     <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>putMapEntries方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.putAll and Map constructor</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict false when initially constructing this map, else</span></span><br><span class="line"><span class="comment">     * true (relayed to method afterNodeInsertion).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 容器 m 中的元素个数</span></span><br><span class="line">        <span class="keyword">int</span> s = m.size();</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 判断 table 是否已经完成初始化</span></span><br><span class="line">            <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">                <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">                <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">                <span class="comment">// 如果计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">                <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 table 已初始化，并且m中元素个数s大于阈值，进行扩容处理</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">                resize();</span><br><span class="line">            <span class="comment">// 通过遍历将m中的所有元素添加至HashMap中</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">                K key = e.getKey();</span><br><span class="line">                V value = e.getValue();</span><br><span class="line">                putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><p>put 方法的实现在 JDK1.8 前后有一些不同。</p>
<h3 id="JDK1-8之前的-put-方法"><a href="#JDK1-8之前的-put-方法" class="headerlink" title="JDK1.8之前的 put 方法"></a>JDK1.8之前的 put 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">  * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">  * value is replaced.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">  *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">  *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">  *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">  *         put时有返回值，如果重复返回老值，如果不重复返回null.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">     <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">     <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">     <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">         Object k;</span><br><span class="line">         <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             e.value = value;</span><br><span class="line">             e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     modCount++;</span><br><span class="line">     addEntry(hash, key, value, i);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>根据 HashMap 的 put 方法可知,一个元素放入 HashMap 经过以下几个步骤：</p>
<ul>
<li>计算 key 的 hash 值</li>
<li>计算元素在数组中对应的 index</li>
<li>判断index 位置上是否已经存在元素，如果已经存在则（通过<code>头插法</code>）放入（单向链表）</li>
<li>更新链表的头结点：替换Entry数组中元素的地址，指向链表头结点元素的地址</li>
</ul>
<p>具体的流程图如下:</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmxrdkwanfj30u00x3dk1.jpg"></p>
<h3 id="JDK1-8之后的-put-方法"><a href="#JDK1-8之后的-put-方法" class="headerlink" title="JDK1.8之后的 put 方法"></a>JDK1.8之后的 put 方法</h3><p>与 JDK1.8之前的 put 方法不同，JDK1.8新增了 Node 和 TreeNode节点类，以支持链表转化成红黑树</p>
<ul>
<li>Node 类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承自 Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class="line">       <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">       V value;<span class="comment">//值</span></span><br><span class="line">       <span class="comment">// 指向下一个节点</span></span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line">        <span class="comment">// 重写hashCode()方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重写 equals() 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>TreeNode 类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;    <span class="comment">// 左</span></span><br><span class="line">    TreeNode&lt;K,V&gt; right;   <span class="comment">// 右</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;           <span class="comment">// 判断颜色</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            r = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>put 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值，转化为红黑树（这个是其中一个条件）</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>转<a href="https://he-you.github.io/2021/01/23/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AD%A6%E4%B9%A0/">红黑树</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">     <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">         resize();</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line">             TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">             <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                 hd = p;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 p.prev = tl;</span><br><span class="line">                 tl.next = p;</span><br><span class="line">             &#125;</span><br><span class="line">             tl = p;</span><br><span class="line">         &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">         <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">             hd.treeify(tab);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>由上述代码可知：HashMap 链表转红黑树的<strong>前提条件有两个</strong></p>
<ul>
<li>链表长度大于 TREEIFY_THRESHOLD（8）</li>
<li>数组的长度大于MIN_TREEIFY_CAPACITY（64）</li>
</ul>
<p>注：为什么是转红黑树的阈值是 8？</p>
<p>当负载因子是 0.75 时，基于<strong>泊松分布</strong>计算的，HashMap链表长度大于 8 的概率很低。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn1i7ah8fpj30u016cdjo.jpg"></p>
<h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><p>Hash 算法具有幂等性，所以 HashMap可以通过 get（key）的方式找到 key 对应的 value</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 数组元素相等</span><br><span class="line">        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        &#x2F;&#x2F; 桶中不止一个节点</span><br><span class="line">        if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 在树中get</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            &#x2F;&#x2F; 在链表中get</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩容-resize-方法"><a href="#扩容-resize-方法" class="headerlink" title="扩容 resize 方法"></a>扩容 resize 方法</h2><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外：在高并发环境下 HashMap 会出现扩容死锁（链表成环）使得 CPU 资源达到 100%和数据丢失的问题，所以 HashMap 是线程不安全的容器。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK1.7 中的HashMap源码</title>
    <url>/2021/01/21/JDK1.7-%E4%B8%AD%E7%9A%84HashMap%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>以下是 JDK1.7中 HashMap 的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.</span></span><br><span class="line"><span class="comment"> * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hash table based implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface.  This</span></span><br><span class="line"><span class="comment"> * implementation provides all of the optional map operations, and permits</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; key.  (The &lt;tt&gt;HashMap&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * class is roughly equivalent to &lt;tt&gt;Hashtable&lt;/tt&gt;, except that it is</span></span><br><span class="line"><span class="comment"> * unsynchronized and permits nulls.)  This class makes no guarantees as to</span></span><br><span class="line"><span class="comment"> * the order of the map; in particular, it does not guarantee that the order</span></span><br><span class="line"><span class="comment"> * will remain constant over time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation provides constant-time performance for the basic</span></span><br><span class="line"><span class="comment"> * operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming the hash function</span></span><br><span class="line"><span class="comment"> * disperses the elements properly among the buckets.  Iteration over</span></span><br><span class="line"><span class="comment"> * collection views requires time proportional to the &quot;capacity&quot; of the</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of buckets) plus its size (the number</span></span><br><span class="line"><span class="comment"> * of key-value mappings).  Thus, it&#x27;s very important not to set the initial</span></span><br><span class="line"><span class="comment"> * capacity too high (or the load factor too low) if iteration performance is</span></span><br><span class="line"><span class="comment"> * important.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;An instance of &lt;tt&gt;HashMap&lt;/tt&gt; has two parameters that affect its</span></span><br><span class="line"><span class="comment"> * performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  The</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;capacity&lt;/i&gt; is the number of buckets in the hash table, and the initial</span></span><br><span class="line"><span class="comment"> * capacity is simply the capacity at the time the hash table is created.  The</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash table is allowed to</span></span><br><span class="line"><span class="comment"> * get before its capacity is automatically increased.  When the number of</span></span><br><span class="line"><span class="comment"> * entries in the hash table exceeds the product of the load factor and the</span></span><br><span class="line"><span class="comment"> * current capacity, the hash table is &lt;i&gt;rehashed&lt;/i&gt; (that is, internal data</span></span><br><span class="line"><span class="comment"> * structures are rebuilt) so that the hash table has approximately twice the</span></span><br><span class="line"><span class="comment"> * number of buckets.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;As a general rule, the default load factor (.75) offers a good tradeoff</span></span><br><span class="line"><span class="comment"> * between time and space costs.  Higher values decrease the space overhead</span></span><br><span class="line"><span class="comment"> * but increase the lookup cost (reflected in most of the operations of the</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;HashMap&lt;/tt&gt; class, including &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;).  The</span></span><br><span class="line"><span class="comment"> * expected number of entries in the map and its load factor should be taken</span></span><br><span class="line"><span class="comment"> * into account when setting its initial capacity, so as to minimize the</span></span><br><span class="line"><span class="comment"> * number of rehash operations.  If the initial capacity is greater</span></span><br><span class="line"><span class="comment"> * than the maximum number of entries divided by the load factor, no</span></span><br><span class="line"><span class="comment"> * rehash operations will ever occur.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If many mappings are to be stored in a &lt;tt&gt;HashMap&lt;/tt&gt; instance,</span></span><br><span class="line"><span class="comment"> * creating it with a sufficiently large capacity will allow the mappings to</span></span><br><span class="line"><span class="comment"> * be stored more efficiently than letting it perform automatic rehashing as</span></span><br><span class="line"><span class="comment"> * needed to grow the table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;</span></span><br><span class="line"><span class="comment"> * If multiple threads access a hash map concurrently, and at least one of</span></span><br><span class="line"><span class="comment"> * the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt; be</span></span><br><span class="line"><span class="comment"> * synchronized externally.  (A structural modification is any operation</span></span><br><span class="line"><span class="comment"> * that adds or deletes one or more mappings; merely changing the value</span></span><br><span class="line"><span class="comment"> * associated with a key that an instance already contains is not a</span></span><br><span class="line"><span class="comment"> * structural modification.)  This is typically accomplished by</span></span><br><span class="line"><span class="comment"> * synchronizing on some object that naturally encapsulates the map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If no such object exists, the map should be &quot;wrapped&quot; using the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Collections#synchronizedMap Collections.synchronizedMap&#125;</span></span><br><span class="line"><span class="comment"> * method.  This is best done at creation time, to prevent accidental</span></span><br><span class="line"><span class="comment"> * unsynchronized access to the map:&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *   Map m = Collections.synchronizedMap(new HashMap(...));&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The iterators returned by all of this class&#x27;s &quot;collection view methods&quot;</span></span><br><span class="line"><span class="comment"> * are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after</span></span><br><span class="line"><span class="comment"> * the iterator is created, in any way except through the iterator&#x27;s own</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will throw a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConcurrentModificationException&#125;.  Thus, in the face of concurrent</span></span><br><span class="line"><span class="comment"> * modification, the iterator fails quickly and cleanly, rather than risking</span></span><br><span class="line"><span class="comment"> * arbitrary, non-deterministic behavior at an undetermined time in the</span></span><br><span class="line"><span class="comment"> * future.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed</span></span><br><span class="line"><span class="comment"> * as it is, generally speaking, impossible to make any hard guarantees in the</span></span><br><span class="line"><span class="comment"> * presence of unsynchronized concurrent modification.  Fail-fast iterators</span></span><br><span class="line"><span class="comment"> * throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.</span></span><br><span class="line"><span class="comment"> * Therefore, it would be wrong to write a program that depended on this</span></span><br><span class="line"><span class="comment"> * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators</span></span><br><span class="line"><span class="comment"> * should be used only to detect bugs.&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class is a member of the</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/../technotes/guides/collections/index.html&quot;&gt;</span></span><br><span class="line"><span class="comment"> * Java Collections Framework&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; the type of keys maintained by this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the type of mapped values</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Doug Lea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Josh Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Arthur van Hoff</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Neal Gafter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Object#hashCode()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     TreeMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Hashtable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">     * 初始化容量，16起，每次扩容都是16*2的N次方</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">     * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">     * 最大的容量，2的30次方</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">     * 加载因子系数，3/4的时候扩容。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The table, resized as necessary. Length MUST Always be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     * 扩容变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">     * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">     * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">     * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">     * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">     * 修改标记次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default threshold of map capacity above which alternative hashing is</span></span><br><span class="line"><span class="comment">     * used for String keys. Alternative hashing reduces the incidence of</span></span><br><span class="line"><span class="comment">     * collisions due to weak hash code calculation for String keys.</span></span><br><span class="line"><span class="comment">     * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">     * This value may be overridden by defining the system property</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> jdk.map.althashing.threshold&#125;. A property value of &#123;<span class="doctag">@code</span> 1&#125;</span></span><br><span class="line"><span class="comment">     * forces alternative hashing to be used at all times whereas</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> -1&#125; value ensures that alternative hashing is never used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * holds values which can&#x27;t be initialized until after VM is booted.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unsafe mechanics</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Unsafe utilities</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Offset of &quot;final&quot; hashSeed field we must set in readObject() method.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> HASHSEED_OFFSET;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Table capacity above which to switch to use alternative hashing.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            String altThreshold = java.security.AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> sun.security.action.GetPropertyAction(</span><br><span class="line">                            <span class="string">&quot;jdk.map.althashing.threshold&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> threshold;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                threshold = (<span class="keyword">null</span> != altThreshold)</span><br><span class="line">                        ? Integer.parseInt(altThreshold)</span><br><span class="line">                        : ALTERNATIVE_HASHING_THRESHOLD_DEFAULT;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// disable alternative hashing if -1</span></span><br><span class="line">                <span class="keyword">if</span> (threshold == -<span class="number">1</span>) &#123;</span><br><span class="line">                    threshold = Integer.MAX_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (threshold &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;value must be positive integer.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(IllegalArgumentException failed) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Illegal value for &#x27;jdk.map.althashing.threshold&#x27;&quot;</span>, failed);</span><br><span class="line">            &#125;</span><br><span class="line">            ALTERNATIVE_HASHING_THRESHOLD = threshold;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                HASHSEED_OFFSET = UNSAFE.objectFieldOffset(</span><br><span class="line">                        HashMap.class.getDeclaredField(<span class="string">&quot;hashSeed&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException | SecurityException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Failed to record hashSeed offset&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If &#123;<span class="doctag">@code</span> true&#125; then perform alternative hashing of String keys to reduce</span></span><br><span class="line"><span class="comment">     * the incidence of collisions due to weak hash code calculation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">boolean</span> useAltHashing;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A randomizing value associated with this instance that is applied to</span></span><br><span class="line"><span class="comment">     * hash code of keys to make hash collisions harder to find.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">final</span> <span class="keyword">int</span> hashSeed = sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and load factor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                    initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                    loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">            capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment">     * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment">     * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment">     * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment">     * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">        putAllForCreate(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// internal utilities</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialization hook for subclasses. This method is called</span></span><br><span class="line"><span class="comment">     * in all constructors and pseudo-constructors (clone, readObject)</span></span><br><span class="line"><span class="comment">     * after HashMap has been initialized but before any entries have</span></span><br><span class="line"><span class="comment">     * been inserted.  (In the absence of this method, readObject would</span></span><br><span class="line"><span class="comment">     * require explicit knowledge of subclasses.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieve object hash code and applies a supplemental hash function to the</span></span><br><span class="line"><span class="comment">     * result hash, which defends against poor quality hash functions.  This is</span></span><br><span class="line"><span class="comment">     * critical because HashMap uses power-of-two length hash tables, that</span></span><br><span class="line"><span class="comment">     * otherwise encounter collisions for hashCodes that do not differ</span></span><br><span class="line"><span class="comment">     * in lower bits. Note: Null keys always map to hash 0, thus index 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (useAltHashing) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">            &#125;</span><br><span class="line">            h = hashSeed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">        <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">        <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">        <span class="comment">//一种算法，进行4次位移，得到相对比较分散的链表，1.8有变化，有通过红黑树来实现</span></span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns index for hash code h.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of key-value mappings in this map.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of key-value mappings in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment">     * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment">     * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment">     * indicate that the map contains no mapping for the key; it&#x27;s also</span></span><br><span class="line"><span class="comment">     * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment">     * distinguish these two cases.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getForNullKey();</span><br><span class="line">        Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Offloaded version of get() to look up null keys.  Null keys map</span></span><br><span class="line"><span class="comment">     * to index 0.  This null case is split out into separate methods</span></span><br><span class="line"><span class="comment">     * for the sake of performance in the two most commonly used</span></span><br><span class="line"><span class="comment">     * operations (get and put), but incorporated with conditionals in</span></span><br><span class="line"><span class="comment">     * others.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the</span></span><br><span class="line"><span class="comment">     * specified key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   key   The key whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified</span></span><br><span class="line"><span class="comment">     * key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getEntry(key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the entry associated with the specified key in the</span></span><br><span class="line"><span class="comment">     * HashMap.  Returns null if the HashMap contains no mapping</span></span><br><span class="line"><span class="comment">     * for the key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key); <span class="comment">//key不为空，取得key的hash值</span></span><br><span class="line">        <span class="comment">//通过indexFor取得该hash值在数组table中的偏移量得到Entry类的单向链表</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="comment">//通过循环在单向链表中寻找相同hash值，相同key值确定链表中的具体实例。</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">     * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">     * value is replaced.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">     *         put时有返回值，如果重复返回老值，如果不重复返回null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Offloaded version of put for null keys</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is used instead of put by constructors and</span></span><br><span class="line"><span class="comment">     * pseudoconstructors (clone, readObject).  It does not resize the table,</span></span><br><span class="line"><span class="comment">     * check for comodification, etc.  It calls createEntry rather than</span></span><br><span class="line"><span class="comment">     * addEntry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putForCreate</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = <span class="keyword">null</span> == key ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Look for preexisting entry for key.  This will never happen for</span></span><br><span class="line"><span class="comment">         * clone or deserialize.  It will only happen for construction if the</span></span><br><span class="line"><span class="comment">         * input Map is a sorted map whose ordering is inconsistent w/ equals.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putAllForCreate</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">            putForCreate(e.getKey(), e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Rehashes the contents of this map into a new array with a</span></span><br><span class="line"><span class="comment">     * larger capacity.  This method is called automatically when the</span></span><br><span class="line"><span class="comment">     * number of keys in this map reaches its threshold.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If current capacity is MAXIMUM_CAPACITY, this method does not</span></span><br><span class="line"><span class="comment">     * resize the map, but sets threshold to Integer.MAX_VALUE.</span></span><br><span class="line"><span class="comment">     * This has the effect of preventing future calls.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newCapacity the new capacity, MUST be a power of two;</span></span><br><span class="line"><span class="comment">     *        must be greater than current capacity unless current</span></span><br><span class="line"><span class="comment">     *        capacity is MAXIMUM_CAPACITY (in which case value</span></span><br><span class="line"><span class="comment">     *        is irrelevant).</span></span><br><span class="line"><span class="comment">     * 扩容和rehash</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">        <span class="keyword">boolean</span> oldAltHashing = useAltHashing;</span><br><span class="line">        useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        <span class="keyword">boolean</span> rehash = oldAltHashing ^ useAltHashing;</span><br><span class="line">        transfer(newTable, rehash);</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copies all of the mappings from the specified map to this map.</span></span><br><span class="line"><span class="comment">     * These mappings will replace any mappings that this map had for</span></span><br><span class="line"><span class="comment">     * any of the keys currently in the specified map.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m mappings to be stored in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numKeysToBeAdded = m.size();</span><br><span class="line">        <span class="keyword">if</span> (numKeysToBeAdded == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Expand the map if the map if the number of mappings to be added</span></span><br><span class="line"><span class="comment">         * is greater than or equal to threshold.  This is conservative; the</span></span><br><span class="line"><span class="comment">         * obvious condition is (m.size() + size) &gt;= threshold, but this</span></span><br><span class="line"><span class="comment">         * condition could result in a map with twice the appropriate capacity,</span></span><br><span class="line"><span class="comment">         * if the keys to be added overlap with the keys already in this map.</span></span><br><span class="line"><span class="comment">         * By using the conservative calculation, we subject ourself</span></span><br><span class="line"><span class="comment">         * to at most one extra resize.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (numKeysToBeAdded &gt; threshold) &#123;</span><br><span class="line">            <span class="keyword">int</span> targetCapacity = (<span class="keyword">int</span>)(numKeysToBeAdded / loadFactor + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (targetCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">                targetCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">            <span class="keyword">int</span> newCapacity = table.length;</span><br><span class="line">            <span class="keyword">while</span> (newCapacity &lt; targetCapacity)</span><br><span class="line">                newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (newCapacity &gt; table.length)</span><br><span class="line">                resize(newCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">            put(e.getKey(), e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the mapping for the specified key from this map if present.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  key key whose mapping is to be removed from the map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = removeEntryForKey(key);</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes and returns the entry associated with the specified key</span></span><br><span class="line"><span class="comment">     * in the HashMap.  Returns null if the HashMap contains no mapping</span></span><br><span class="line"><span class="comment">     * for this key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span> (prev == e)</span><br><span class="line">                    table[i] = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    prev.next = next;</span><br><span class="line">                e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Special version of remove for EntrySet using &#123;<span class="doctag">@code</span> Map.Entry.equals()&#125;</span></span><br><span class="line"><span class="comment">     * for matching.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeMapping</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;</span><br><span class="line">        Object key = entry.getKey();</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.equals(entry)) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span> (prev == e)</span><br><span class="line">                    table[i] = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    prev.next = next;</span><br><span class="line">                e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes all of the mappings from this map.</span></span><br><span class="line"><span class="comment">     * The map will be empty after this call returns.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i++)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">     * specified value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">     *         specified value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> containsNullValue();</span><br><span class="line"></span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)</span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next)</span><br><span class="line">                <span class="keyword">if</span> (value.equals(e.value))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Special-case code for containsValue with null argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsNullValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)</span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next)</span><br><span class="line">                <span class="keyword">if</span> (e.value == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;/tt&gt; instance: the keys and</span></span><br><span class="line"><span class="comment">     * values themselves are not cloned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a shallow copy of this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;K,V&gt; result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = (HashMap&lt;K,V&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// assert false;</span></span><br><span class="line">        &#125;</span><br><span class="line">        result.table = <span class="keyword">new</span> Entry[table.length];</span><br><span class="line">        result.entrySet = <span class="keyword">null</span>;</span><br><span class="line">        result.modCount = <span class="number">0</span>;</span><br><span class="line">        result.size = <span class="number">0</span>;</span><br><span class="line">        result.init();</span><br><span class="line">        result.putAllForCreate(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 相比较于分离链接法，此处不是双向链表，而是一个有Map接口类，有Entry&lt;K,V&gt; next,应为一个单向链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment">     * 有自己的设置方法以及hashcode方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates new entry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry e = (Map.Entry)o;</span><br><span class="line">            Object k1 = getKey();</span><br><span class="line">            Object k2 = e.getKey();</span><br><span class="line">            <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">                Object v1 = getValue();</span><br><span class="line">                Object v2 = e.getValue();</span><br><span class="line">                <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (key==<span class="keyword">null</span>   ? <span class="number">0</span> : key.hashCode()) ^</span><br><span class="line">                    (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getKey() + <span class="string">&quot;=&quot;</span> + getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This method is invoked whenever the value in an entry is</span></span><br><span class="line"><span class="comment">         * overwritten by an invocation of put(k,v) for a key k that&#x27;s already</span></span><br><span class="line"><span class="comment">         * in the HashMap.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This method is invoked whenever the entry is</span></span><br><span class="line"><span class="comment">         * removed from the table.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds a new entry with the specified key, value and hash code to</span></span><br><span class="line"><span class="comment">     * the specified bucket.  It is the responsibility of this</span></span><br><span class="line"><span class="comment">     * method to resize the table if appropriate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Subclass overrides this to alter the behavior of put method.</span></span><br><span class="line"><span class="comment">     * put时调用次方法，超出长度进行扩容为2倍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Like addEntry except that this version is used when creating entries</span></span><br><span class="line"><span class="comment">     * as part of Map construction or &quot;pseudo-construction&quot; (cloning,</span></span><br><span class="line"><span class="comment">     * deserialization).  This version needn&#x27;t worry about resizing the table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Subclass overrides this to alter the behavior of HashMap(Map),</span></span><br><span class="line"><span class="comment">     * clone, and readObject.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount;   <span class="comment">// For fast-fail</span></span><br><span class="line">        <span class="keyword">int</span> index;              <span class="comment">// current slot</span></span><br><span class="line">        Entry&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">                Entry[] t = table;</span><br><span class="line">                <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">                    ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            Entry&lt;K,V&gt; e = next;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((next = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Entry[] t = table;</span><br><span class="line">                <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">                    ;</span><br><span class="line">            &#125;</span><br><span class="line">            current = e;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            Object k = current.key;</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">            HashMap.<span class="keyword">this</span>.removeEntryForKey(k);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextEntry().value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextEntry().getKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextEntry();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Subclass overrides these to alter behavior of views&#x27; iterator() method</span></span><br><span class="line">    <span class="function">Iterator&lt;K&gt; <span class="title">newKeyIterator</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Iterator&lt;V&gt; <span class="title">newValueIterator</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()   &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Views</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Set&#125; view of the keys contained in this map.</span></span><br><span class="line"><span class="comment">     * The set is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the set, and vice-versa.  If the map is modified</span></span><br><span class="line"><span class="comment">     * while an iteration over the set is in progress (except through</span></span><br><span class="line"><span class="comment">     * the iterator&#x27;s own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of</span></span><br><span class="line"><span class="comment">     * the iteration are undefined.  The set supports element removal,</span></span><br><span class="line"><span class="comment">     * which removes the corresponding mapping from the map, via the</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * operations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        <span class="keyword">return</span> (ks != <span class="keyword">null</span> ? ks : (keySet = <span class="keyword">new</span> KeySet()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> newKeyIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> containsKey(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> HashMap.<span class="keyword">this</span>.removeEntryForKey(o) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Collection&#125; view of the values contained in this map.</span></span><br><span class="line"><span class="comment">     * The collection is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the collection, and vice-versa.  If the map is</span></span><br><span class="line"><span class="comment">     * modified while an iteration over the collection is in progress</span></span><br><span class="line"><span class="comment">     * (except through the iterator&#x27;s own &lt;tt&gt;remove&lt;/tt&gt; operation),</span></span><br><span class="line"><span class="comment">     * the results of the iteration are undefined.  The collection</span></span><br><span class="line"><span class="comment">     * supports element removal, which removes the corresponding</span></span><br><span class="line"><span class="comment">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not</span></span><br><span class="line"><span class="comment">     * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;V&gt; vs = values;</span><br><span class="line">        <span class="keyword">return</span> (vs != <span class="keyword">null</span> ? vs : (values = <span class="keyword">new</span> Values()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> newValueIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> containsValue(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Set&#125; view of the mappings contained in this map.</span></span><br><span class="line"><span class="comment">     * The set is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the set, and vice-versa.  If the map is modified</span></span><br><span class="line"><span class="comment">     * while an iteration over the set is in progress (except through</span></span><br><span class="line"><span class="comment">     * the iterator&#x27;s own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the</span></span><br><span class="line"><span class="comment">     * iterator) the results of the iteration are undefined.  The set</span></span><br><span class="line"><span class="comment">     * supports element removal, which removes the corresponding</span></span><br><span class="line"><span class="comment">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a set view of the mappings contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        <span class="keyword">return</span> entrySet0();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;</span><br><span class="line">        <span class="keyword">return</span> es != <span class="keyword">null</span> ? es : (entrySet = <span class="keyword">new</span> EntrySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> newEntryIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o;</span><br><span class="line">            Entry&lt;K,V&gt; candidate = getEntry(e.getKey());</span><br><span class="line">            <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> removeMapping(o) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e.,</span></span><br><span class="line"><span class="comment">     * serialize it).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serialData</span> The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the</span></span><br><span class="line"><span class="comment">     *             bucket array) is emitted (int), followed by the</span></span><br><span class="line"><span class="comment">     *             &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value</span></span><br><span class="line"><span class="comment">     *             mappings), followed by the key (Object) and value (Object)</span></span><br><span class="line"><span class="comment">     *             for each key-value mapping.  The key-value mappings are</span></span><br><span class="line"><span class="comment">     *             emitted in no particular order.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i =</span><br><span class="line">                (size &gt; <span class="number">0</span>) ? entrySet0().iterator() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out number of buckets</span></span><br><span class="line">        s.writeInt(table.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size (number of Mappings)</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out keys and values (alternating)</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;K,V&gt; e : entrySet0()) &#123;</span><br><span class="line">                s.writeObject(e.getKey());</span><br><span class="line">                s.writeObject(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reconstitute the &#123;<span class="doctag">@code</span> HashMap&#125; instance from a stream (i.e.,</span></span><br><span class="line"><span class="comment">     * deserialize it).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                    loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set hashSeed (can only happen after VM boot)</span></span><br><span class="line">        Holder.UNSAFE.putIntVolatile(<span class="keyword">this</span>, Holder.HASHSEED_OFFSET,</span><br><span class="line">                sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in number of buckets and allocate the bucket array;</span></span><br><span class="line">        s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read number of mappings</span></span><br><span class="line">        <span class="keyword">int</span> mappings = s.readInt();</span><br><span class="line">        <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                    mappings);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> initialCapacity = (<span class="keyword">int</span>) Math.min(</span><br><span class="line">                <span class="comment">// capacity chosen by number of mappings</span></span><br><span class="line">                <span class="comment">// and desired load (if &gt;= 0.25)</span></span><br><span class="line">                mappings * Math.min(<span class="number">1</span> / loadFactor, <span class="number">4.0f</span>),</span><br><span class="line">                <span class="comment">// we have limits...</span></span><br><span class="line">                HashMap.MAXIMUM_CAPACITY);</span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// find smallest power of two which holds all mappings</span></span><br><span class="line">        <span class="keyword">while</span> (capacity &lt; initialCapacity) &#123;</span><br><span class="line">            capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line"></span><br><span class="line">        init();  <span class="comment">// Give subclass a chance to do its thing.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mappings; i++) &#123;</span><br><span class="line">            K key = (K) s.readObject();</span><br><span class="line">            V value = (V) s.readObject();</span><br><span class="line">            putForCreate(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These methods are used when serializing HashSets</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span>   <span class="title">capacity</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> table.length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">loadFactor</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> loadFactor;   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL MVCC机制</title>
    <url>/2023/09/07/MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="MVCC多版本并发控制机制"><a href="#MVCC多版本并发控制机制" class="headerlink" title="MVCC多版本并发控制机制"></a>MVCC多版本并发控制机制</h1><p>所谓的MVCC就是MySQL在<strong>RR、RC隔离级别</strong>下并发读取数据时的一种机制，主要是通过undo log和read view实现</p>
<h2 id="undo-log-版本链"><a href="#undo-log-版本链" class="headerlink" title="undo log 版本链"></a>undo log 版本链</h2><p>undo日志版本链是指一行数据被多个事务依次修改过后，在每个事务修改完后，Mysql会保留修改前的数据undo回滚日 志，并且用两个隐藏字段trx_id和roll_pointer把这些undo日志串联起来形成一个历史记录版本链</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230907200315276.png" alt="image-20230907200315276"></p>
<h1 id="一致性视图read-view"><a href="#一致性视图read-view" class="headerlink" title="一致性视图read view"></a>一致性视图read view</h1><p>在可重复读隔离级别，当事务开启，执行任何查询sqll时会生成当前事务的一致性视图read-view，**该视图在事务结束之前永 远都不会变化(如果是读已提交隔离级别在每次执行查询sql时都会重新生成read-view)**，这个视图由执行查询时所有未提交 事务id数组(数组里最小的id为min_id)和已创建的最大事务id(max_id)组成，事务里的任何sql查询结果需要从对应版 本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。</p>
<p>比如在上图中，如果在trx_id=180之后的事务进行查询，那么此时的一致性视图的是：[120,220]，180，min_id=120, max_id=220。对于小于120的事务都是已提交的事务，在120~220之间的事务有可能是已提交的，也有可能是未提交的事务，对于大于220的事务，都是未提交的事务</p>
<p><strong>版本链比对规则:</strong></p>
<ol>
<li>如果 row 的 trx_id 落在绿色部分( trx_id&lt;min_id )，表示这个版本是已提交的事务生成的，这个数据是可见的</li>
<li>如果 row 的 trx_id 落在红色部分( trx_id&gt;max_id )，表示这个版本是由将来启动的事务生成的，是不可见(若 row 的 trx_id 就是当前自己的事务是可见的);</li>
<li>如果 row 的 trx_id 落在黄色部分(min_id &lt;=trx_id&lt;= max_id)，那就包括两种情况<ul>
<li>若 row 的 trx_id 在视图数组中，表示这个版本是由还没提交的事务生成的，不可见(若 row 的 trx_id 就是当前自己的 事务是可见的);</li>
<li> 若 row 的 trx_id 不在视图数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ul>
</li>
</ol>
<p><strong>关于readview和可见性算法的原理解释</strong> </p>
<p>readview和可见性算法其实就是记录了sql查询那个时刻数据库里提交和未提交所有事务的状态。 要实现RR隔离级别，事务里每次执行查询操作readview都是使用第一次查询时生成的readview，也就是都是以第一次查询 时当时数据库里所有事务提交状态来比对数据是否可见，当然可以实现每次查询的可重复读的效果了。 要实现RC隔离级别，事务里每次执行查询操作readview都会按照数据库当前状态重新生成readview，也就是每次查询都是 跟数据库里当前所有事务提交状态来比对数据是否可见，当然实现的就是每次都能查到已提交的最新数据效果了。</p>
<p>注意:begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个修改操作或加排它锁操作(比如 select…for update)的语句，事务才真正启动，才会向mysql申请真正的事务id，mysql内部是严格按照事务的启动顺序来分配事务id的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MVCC机制的实现就是通过read-view机制与undo版本链比对机制，使得不同的事务会根据数据版本链对比规则读取同一条 数据在版本链上的不同版本数据。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 锁机制概述</title>
    <url>/2023/09/08/%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><h2 id="从性能的角度分：乐观锁、悲观锁"><a href="#从性能的角度分：乐观锁、悲观锁" class="headerlink" title="从性能的角度分：乐观锁、悲观锁"></a>从性能的角度分：乐观锁、悲观锁</h2><ol>
<li>乐观锁适合读操作较多的场景，用版本对比或CAS机制</li>
<li>悲观锁适合写操作较多的场景，如果在写操作较多的场景使用乐观锁会导致比对次数过多，影响性能</li>
</ol>
<h2 id="从锁的粒度分：表锁、行锁、页锁"><a href="#从锁的粒度分：表锁、行锁、页锁" class="headerlink" title="从锁的粒度分：表锁、行锁、页锁"></a>从锁的粒度分：表锁、行锁、页锁</h2><ol>
<li>表锁：每次操作锁住整张表。<strong>开销小，加锁快</strong>;不会出现死锁;锁定粒度大，发生锁冲突的概率最高，并发度最低;一般用在整表数据迁移的场景。</li>
<li>行锁：每次操作锁住一行数据。<strong>开销大，加锁慢</strong>;会出现死锁;锁定粒度最小，发生锁冲突的概率最低，并发度最高</li>
<li>页锁：只有BDB存储引擎支持页锁，页锁就是在页的粒度上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</li>
</ol>
<p>注：对于行锁，InnoDB的行锁，实际上是针对索引加的锁，是在所有对应的索引项上做标记，而不是对整行数据记录加锁，而且加锁的索引不能失效，否在可能会出现行锁升级成表锁的情况（锁升级是在RR级别中存在，RC级别不会）</p>
<h3 id="关于RR级别行锁升级为表锁的原因分析"><a href="#关于RR级别行锁升级为表锁的原因分析" class="headerlink" title="关于RR级别行锁升级为表锁的原因分析"></a>关于RR级别行锁升级为表锁的原因分析</h3><p>因为在RR隔离级别下，需要解决不可重复读和幻读问题，所以在遍历扫描聚集索引记录时，为了防止扫描过 的索引被其它事务修改(不可重复读问题) 或 间隙被其它事务插入记录(幻读问题)，从而导致数据不一致，所 以MySQL的解决方案就是把所有扫描过的索引记录和间隙都锁上，这里要注意，并不是直接将整张表加表锁，因为不一定能加上表锁，可能会有其它事务锁住了表里的其它行记录。</p>
<h2 id="从操作类型分：读锁、写锁、意向锁"><a href="#从操作类型分：读锁、写锁、意向锁" class="headerlink" title="从操作类型分：读锁、写锁、意向锁"></a>从操作类型分：读锁、写锁、意向锁</h2><ol>
<li>读锁（共享锁）也叫S锁，针对同一份数据，多个读操作可以同时进行而不会互相影响</li>
<li>写锁（互斥锁）也叫X锁，当前写操作没有完成前，它会阻断其他写锁和读锁，数据修改操作都会加写锁，查询也可以通过for update加写锁</li>
<li>意向锁也叫I锁，针对表锁主要是为了提高加表锁的效率，是mysql数据库自己加的。当有事务给表的数据行加了共享锁或排他锁，同时会给表设置一个标识，代表已经有行锁了，其他事务要想对表加表锁时，就不必逐行判断有没有行锁可能跟表锁冲突了，直接读这个标识就可以确定自己该不该加表锁<ul>
<li>意向共享锁，IS锁：对整个表加共享锁之前，需要先获取到意向共享锁。</li>
<li>意向排他锁，IX锁：对整个表加排他锁之前，需要先获取到意向排他锁。</li>
</ul>
</li>
</ol>
<h2 id="其他类型的锁"><a href="#其他类型的锁" class="headerlink" title="其他类型的锁"></a>其他类型的锁</h2><ol>
<li>间隙锁（gap lock）:锁的就是两个值之间的空隙，间隙锁是在可重复读隔离级别下才会生效。在RR隔离级别下，间隙锁是可以解决幻读问题的，只要在间隙范围内锁了一条不存在的记录会锁住整个间隙范围，不锁边界记录，这样就能防止其 它Session在这个间隙范围内插入数据，就解决了可重复读隔离级别的幻读问题。</li>
<li>临键锁（next-key lock）:Next-Key Locks是行锁与间隙锁的组合。</li>
</ol>
<h2 id="锁优化思路"><a href="#锁优化思路" class="headerlink" title="锁优化思路"></a>锁优化思路</h2><ol>
<li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li>
<li>合理设计索引，尽量缩小锁的范围</li>
<li>尽可能减少检索条件范围，避免间隙锁</li>
<li>尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql</li>
<li>尽量放在事务最后执行 尽可能用低的事务隔离级别</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IoC的工作流程</title>
    <url>/2023/09/10/Spring%20IoC%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Ioc的定义"><a href="#Ioc的定义" class="headerlink" title="Ioc的定义"></a>Ioc的定义</h2><p>IOC 的全称是 Inversion Of Control, 也就是控制反转，它的核心思想是把对象的管理权限交给容器，应用程序如果需要使用到某个对象实例，直接从 IOC 容器中去获取就 行，这样设计的好处是降低了程序里面对象与对象之间的耦合性。 使得程序的整个体系结构变得更加灵活。</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>Spring Ioc的工作流程大致可以分为两个阶段</p>
<h3 id="Ioc容器的初始化"><a href="#Ioc容器的初始化" class="headerlink" title="Ioc容器的初始化"></a>Ioc容器的初始化</h3><p>这个阶段主要是根据程序中定义的 XML 或者注解等 Bean 的声明方式 (如图)通过解析和加载后生成 BeanDefinition，然后把 BeanDefinition 注册到 IOC 容器。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230910173603005.png" alt="image-20230910173603005"></p>
<p>最后把这个 BeanDefinition 保存到一个 Map 集合里面，从而完成了 IOC 的初始化。 IoC 容器的作用就是对这些注册的 Bean 的定义信息进行处理和维护，它 IoC 容器控制 反转的核心。</p>
<h3 id="Bean的初始化以及依赖注入"><a href="#Bean的初始化以及依赖注入" class="headerlink" title="Bean的初始化以及依赖注入"></a>Bean的初始化以及依赖注入</h3><p>在这个阶段会处理两个事情：</p>
<ol>
<li>通过反射针对没有设置lazy-init属性的单例bean进行初始化</li>
<li>完成bean的依赖注入</li>
</ol>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230910174115149.png" alt="bean的初始化"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 启动过程</title>
    <url>/2023/09/10/Spring%20%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Spring-启动过程"><a href="#Spring-启动过程" class="headerlink" title="Spring 启动过程"></a>Spring 启动过程</h2><p>这里说的Spring启动，就是构造ApplicationContext对象以及调用refresh()方法的过程。</p>
<p>总体来说，Spring启动过程主要做了这些事情：</p>
<ol>
<li>构造BeanFactory对象</li>
<li>解析配置类，得到BeanDefinition,并注册到BeanFactory中</li>
<li>初始化MessageSource对象，支持ApplicationContext的国际化</li>
<li>初始化ApplicationEventMulticaster对象，支持ApplicationContext事件机制</li>
<li>将用户定义的ApplicationListener对象添加到ApplicationContext中，等Spring启动后发布事件</li>
<li>创建非懒加载的单例Bean，并存入BeanFactory的单例池中。</li>
<li>调用Lifecycle Bean的start()方法</li>
<li>发布ContextRefreshedEvent事件</li>
</ol>
<p>由于Spring启动过程要创建非懒加载的单例Bean对象，那么就需要BeanPostProcessor，所以Spring在启动过程中就需要做两件事：</p>
<ol>
<li>生成默认的BeanPostProcessor对象，并添加到BeanFactory中<ul>
<li>AutowiredAnnotationBeanPostProcessor：处理@Autowired、@Value</li>
<li>CommonAnnotationBeanPostProcessor：处理@Resource、@PostConstruct、 @PreDestroy</li>
<li>ApplicationContextAwareProcessor：处理ApplicationContextAware等回调</li>
</ul>
</li>
<li>找到外部用户所定义的BeanPostProcessor对象，并添加到BeanFactory中。</li>
</ol>
<h2 id="如何理解refresh"><a href="#如何理解refresh" class="headerlink" title="如何理解refresh()"></a>如何理解refresh()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load or refresh the persistent representation of the configuration,</span></span><br><span class="line"><span class="comment"> * which might an XML file, properties file, or relational database schema.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;As this is a startup method, it should destroy already created singletons</span></span><br><span class="line"><span class="comment"> * if it fails, to avoid dangling resources. In other words, after invocation</span></span><br><span class="line"><span class="comment"> * of that method, either all or no singletons at all should be instantiated.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if the bean factory could not be initialized</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if already initialized and multiple refresh</span></span><br><span class="line"><span class="comment"> * attempts are not supported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br></pre></td></tr></table></figure>

<p>这是ConfigurableApplicationContext接口上refresh()方法的注释，意思是:加载或刷新持久化的配置，可能是XML文件、属性文件或关系数据库中存储的。由于这是一个启动方法，如果失败，它应该销毁已经创建的单例，以避免占用资源。换句话说，在调用该方法之后，应该实例化所有的单例， 或者根本不实例化单例。</p>
<p>需要注意的是：<code>ApplicationContext关闭之后不代表JVM也关闭了，ApplicationContext是 属于JVM的，说白了ApplicationContext也是JVM中的一个对象。</code></p>
<p>在Spring的设计中，也提供可以刷新的ApplicationContext和不可以刷新的ApplicationContext。 比如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractRefreshableApplicationContext extends AbstractApplicationContext</span><br></pre></td></tr></table></figure>

<p>这个是可以刷新的，而下面的则是不可以刷新的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GenericApplicationContext extends AbstractApplicationContext</span><br></pre></td></tr></table></figure>

<p>AnnotationConfigApplicationContext继承的是GenericApplicationContext，所以它是不能刷新的。 AnnotationConfigWebApplicationContext继承的是 AbstractRefreshableWebApplicationContext，所以它是可以刷的。</p>
<p><strong>上面说的不能刷新是指不能重复刷新，只能调用一次refresh方法，第二次时会报错。</strong></p>
<h2 id="refresh-底层原理"><a href="#refresh-底层原理" class="headerlink" title="refresh()底层原理"></a>refresh()底层原理</h2><p>以AnnotationConfigApplicationContext为例，refresh()底层原理大致如下：</p>
<ol>
<li>在调用AnnotationConfigApplicationContext的构造方法之前，会调用父类GenericApplicationContext的无参构造方法，会构造一个BeanFactory,为DefaultListableBeanFactory。</li>
<li>构造AnnotatedBeanDefinitionReader，主要作用是添加一些基础的PostProcessor，同时可以通过reader进行BeanDefinition的注册，同时对BeanFactory进行设置和添加PostProcessor</li>
<li>构造ClassPathBeanDefinitionScanner(主要作用可以用来扫描得到并注册 BeanDefinition)</li>
<li>利用reader注册AppConfig为BeanDefinition，类型为AnnotatedGenericBeanDefinition</li>
<li>调用refresh方法</li>
<li>prepareRefresh()</li>
<li>obtainFreshBeanFactory():进行BeanFactory的refresh，在这里会去调用子类的 refreshBeanFactory方法，具体子类是怎么刷新的得看子类，然后再调用子类的 getBeanFactory方法，重新得到一个BeanFactory</li>
<li>prepareBeanFactory</li>
<li>postProcessBeanFactory(beanFactory) : 提供给AbstractApplicationContext的子类进行扩 展，具体的子类，可以继续向BeanFactory中再添加一些东西</li>
<li>invokeBeanFactoryPostProcessors(beanFactory):执行BeanFactoryPostProcessor</li>
<li>到此，所有的BeanFactoryPostProcessor的逻辑都执行完了，主要做的事情就是得到 BeanDefinition并注册到BeanFactory中</li>
<li>registerBeanPostProcessors(beanFactory):因为上面的步骤完成了扫描，这个过程中程序员 可能自己定义了一些BeanPostProcessor，在这一步就会把BeanFactory中所有的 BeanPostProcessor找出来并实例化得到一个对象，并添加到BeanFactory中去(属性 beanPostProcessors)，最后再重新添加一个ApplicationListenerDetector对象(之前其实 就添加了过，这里是为了把ApplicationListenerDetector移动到最后)</li>
<li>initMessageSource():如果BeanFactory中存在一个叫做”messageSource”的 BeanDefinition，那么就会把这个Bean对象创建出来并赋值给ApplicationContext的 messageSource属性，让ApplicationContext拥有国际化的功能</li>
<li>initApplicationEventMulticaster():如果BeanFactory中存在一个叫 做”applicationEventMulticaster”的BeanDefinition，那么就会把这个Bean对象创建出来并 赋值给ApplicationContext的applicationEventMulticaster属性，让ApplicationContext拥有 事件发布的功能</li>
<li>onRefresh():提供给AbstractApplicationContext的子类进行扩展</li>
<li>registerListeners():从BeanFactory中获取ApplicationListener类型的beanName，然后添加 到ApplicationContext中的事件广播器applicationEventMulticaster中去，到这一步因为 FactoryBean还没有调用getObject()方法生成Bean对象，所以这里要在根据类型找一下 ApplicationListener，记录一下对应的beanName</li>
<li>finishBeanFactoryInitialization(beanFactory):完成BeanFactory的初始化，主要就是实例化 非懒加载的单例Bean</li>
<li>finishRefresh():BeanFactory的初始化完后，就到了Spring启动的最后一步了</li>
<li>设置ApplicationContext的lifecycleProcessor，默认情况下设置的是 DefaultLifecycleProcessor</li>
<li>调用lifecycleProcessor的onRefresh()方法，如果是DefaultLifecycleProcessor，那么会获取所 有类型为Lifecycle的Bean对象，然后调用它的start()方法，这就是ApplicationContext的生命 周期扩展机制</li>
<li>发布ContextRefreshedEvent事件</li>
</ol>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP(一)基础知识点</title>
    <url>/2023/09/11/Spring%20AOP/</url>
    <content><![CDATA[<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>在java的动态代理机制中，有两个重要的类或接口，一个是 <code>InvocationHandler</code>(Interface)、另一个则是 <code>Proxy</code>(Class)，这一个类和接口是实现我们动态代理所必须用到的。</p>
<h3 id="InvocationHandler接口"><a href="#InvocationHandler接口" class="headerlink" title="InvocationHandler接口"></a>InvocationHandler接口</h3><p>每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。</p>
<p>InvocationHandler这个接口的唯一一个方法 invoke 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span></span><br></pre></td></tr></table></figure>

<p>这个方法一共接受三个参数，那么这三个参数分别代表如下：</p>
<ul>
<li><strong>proxy</strong>:指代JDK动态生成的最终代理对象</li>
<li><strong>method</strong>:指代的是我们所要调用真实对象的某个方法的Method对象</li>
<li><strong>args</strong>:指代的是调用真实对象某个方法时接受的参数</li>
</ul>
<h3 id="Proxy类"><a href="#Proxy类" class="headerlink" title="Proxy类"></a>Proxy类</h3><p>Proxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是newProxyInstance 这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,  InvocationHandler handler)</span>  <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure>

<p>这个方法的作用就是得到一个动态的代理对象，其接收三个参数，我们来看看这三个参数所代表的含义：</p>
<ul>
<li><strong>loader</strong>：ClassLoader对象，定义了由哪个ClassLoader来对生成的代理对象进行加载，即代理类的类加载器。</li>
<li><strong>interfaces</strong>：Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了。</li>
<li><strong>Handler</strong>：InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上。</li>
</ul>
<p>所以我们所说的DynamicProxy（动态代理类）是这样一种class：它是在运行时生成的class，在生成它时你必须提供一组interface给它，然后该class就宣称它实现了这些 interface。这个DynamicProxy其实就是一个Proxy，它不会做实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。</p>
<p>总结一下JDK动态代理的步骤：</p>
<ol>
<li><p>拿到被代理对象的引用，并且通过反射获取到它的所有的接口。</p>
</li>
<li><p>通过JDK Proxy类重新生成一个新的类，同时新的类要实现被代理类所实现的所有的接口。</p>
</li>
<li><p>动态生成 Java 代码，把新加的业务逻辑方法由一定的逻辑代码去调用。</p>
</li>
<li><p>编译新生成的 Java 代码.class。</p>
</li>
<li><p>将新生成的Class文件重新加载到 JVM 中运行。</p>
</li>
</ol>
<p>综上所述，JDK动态代理的核心是重写被代理对象所实现的接口，如果被代理对象中没有实现接口，则需要使用cglib动态代理了</p>
<h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>与JDK动态代理不同，CGLIB是通过继承被代理对象来实现，和JDK动态代理需要实现指定接口一样，CGLIB也要求代理对象必须要实现<code>MethodInterceptor</code>接口，并重写其唯一的方法<code>intercept</code>。</p>
<h3 id="CGLib核心类"><a href="#CGLib核心类" class="headerlink" title="CGLib核心类"></a>CGLib核心类</h3><p><strong>1、 net.sf.cglib.proxy.Enhancer</strong>：主要增强类，通过字节码技术动态创建委托类的子类实例；</p>
<p><code>Enhancer</code>可能是CGLIB中最常用的一个类，和Java1.3动态代理中引入的Proxy类差不多。和Proxy不同的是，Enhancer既能够代理普通的class，也能够代理接口。Enhancer创建一个被代理对象的子类并且拦截所有的方法调用（包括从Object中继承的toString和hashCode方法）。Enhancer不能够拦截final方法，例如Object.getClass()方法，这是由于Java final方法语义决定的。基于同样的道理，Enhancer也不能对fianl类进行代理操作。这也是Hibernate为什么不能持久化final class的原因。</p>
<p><strong>2、net.sf.cglib.proxy.MethodInterceptor</strong>：常用的方法拦截器接口，需要实现intercept方法，实现具体拦截处理:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">intercept</span><span class="params">(java.lang.Object obj,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   java.lang.reflect.Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   java.lang.Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   MethodProxy proxy)</span> <span class="keyword">throws</span> java.lang.Throwable</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>obj</strong>：动态生成的代理对象</li>
<li><strong>method</strong>:实际调用的方法</li>
<li><strong>args</strong>：调用方法入参</li>
<li><strong>net.sf.cglib.proxy.MethodProxy</strong>：java Method类的代理类，可以实现委托类对象的方法的调用；常用方法：methodProxy.invokeSuper(proxy, args)；在拦截方法内可以调用多次。</li>
</ul>
<h3 id="CGLIB动态代理实现分析"><a href="#CGLIB动态代理实现分析" class="headerlink" title="CGLIB动态代理实现分析"></a>CGLIB动态代理实现分析</h3><p>CGLib动态代理采用了FastClass机制，其分别为代理类和被代理类各生成一个FastClass，这个FastClass类会为代理类或被代理类的方法分配一个 index(int类型)。这个index当做一个入参，FastClass 就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比 JDK 动态代理通过反射调用更高。</p>
<p>但是我们看上面的源码也可以明显看到，JDK动态代理只生成一个文件，而CGLIB生成了三个文件，所以生成代理对象的过程会更复杂。</p>
<h2 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h2><p>在Spring中，使用的动态代理是通过ProxyFactory实现的，具体是用JDK动态代理还是CGLIB，是由Spring判断，如果被代理对象实现了接口，那么ProxyFactory底层就会用jdk动态代理，如果没有实现接 口，就会用cglib技术。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> UserService target = <span class="keyword">new</span> UserService();</span><br><span class="line">  ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">  proxyFactory.setTarget(target);</span><br><span class="line">  proxyFactory.addAdvice(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">          Object result = invocation.proceed();</span><br><span class="line">          System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br><span class="line">  UserInterface userService = (UserInterface) proxyFactory.getProxy();</span><br><span class="line">  userService.test();</span><br></pre></td></tr></table></figure>

<h3 id="Advice的分类"><a href="#Advice的分类" class="headerlink" title="Advice的分类"></a>Advice的分类</h3><ol>
<li>Before Advice:方法之前执行</li>
<li>After returning advice:方法return后执行</li>
<li>After throwing advice:方法抛异常后执行</li>
<li>After (finally) advice:方法执行完finally之后执行，这是最后的，比return更后 </li>
<li>Around advice:这是功能最强大的Advice，可以自定义执行顺序</li>
</ol>
<h3 id="Advisor的理解"><a href="#Advisor的理解" class="headerlink" title="Advisor的理解"></a>Advisor的理解</h3><p>跟Advice类似的还有一个Advisor的概念，一个Advisor是有一个Pointcut和一个Advice组成的，通过Pointcut可以指定要需要被代理的逻辑，比如一个UserService类中有两个方法，按上面的例子， 这两个方法都会被代理，被增强，那么我们现在可以通过Advisor，来控制到具体代理哪一个方法， 比如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserService target = <span class="keyword">new</span> UserService();</span><br><span class="line">          ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">          proxyFactory.setTarget(target);</span><br><span class="line">          proxyFactory.addAdvisor(<span class="keyword">new</span> PointcutAdvisor() &#123;</span><br><span class="line">							<span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> Pointcut <span class="title">getPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">new</span> StaticMethodMatcherPointcut() &#123;</span><br><span class="line">											<span class="meta">@Override</span></span><br><span class="line">                      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">                          <span class="keyword">return</span> method.getName().equals(<span class="string">&quot;testAbc&quot;</span>);</span><br><span class="line">									&#125; &#125;;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">											<span class="meta">@Override</span></span><br><span class="line">                      <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                          System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">                          Object result = invocation.proceed();</span><br><span class="line">                          System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">                          <span class="keyword">return</span> result;</span><br><span class="line">                      &#125;</span><br><span class="line">							&#125;; &#125;</span><br><span class="line">							<span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">							&#125; &#125;);</span><br><span class="line">          UserInterface userService = (UserInterface) proxyFactory.getProxy();</span><br><span class="line">          userService.test();</span><br></pre></td></tr></table></figure>

<p>通常我们在使用Spring的时候，并不会直接去使用ProxyFactory</p>
<h3 id="ProxyFactoryBean"><a href="#ProxyFactoryBean" class="headerlink" title="ProxyFactoryBean"></a>ProxyFactoryBean</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ProxyFactoryBean <span class="title">userServiceProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">      UserService userService = <span class="keyword">new</span> UserService();</span><br><span class="line">      ProxyFactoryBean proxyFactoryBean = <span class="keyword">new</span> ProxyFactoryBean();</span><br><span class="line">      proxyFactoryBean.setTarget(userService);</span><br><span class="line">      proxyFactoryBean.addAdvice(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">              Object result = invocation.proceed();</span><br><span class="line">              System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span> result;</span><br><span class="line">          &#125;</span><br><span class="line">			&#125;);</span><br><span class="line">      <span class="keyword">return</span> proxyFactoryBean;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方法来定义一个UserService的Bean，并且是经过了AOP的。但是这种方式只能针对某一个 Bean。它是一个FactoryBean，所以利用的就是FactoryBean技术，间接的将UserService的代理对象作为了Bean。</p>
<p>ProxyFactoryBean还有额外的功能，比如可以把某个Advise或Advisor定义成为Bean，然后在 ProxyFactoryBean中进行设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">testAroundAdvise</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">              Object result = invocation.proceed();</span><br><span class="line">              System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span> result;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;; &#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ProxyFactoryBean <span class="title">userService</span><span class="params">()</span></span>&#123;</span><br><span class="line">      UserService userService = <span class="keyword">new</span> UserService();</span><br><span class="line">      ProxyFactoryBean proxyFactoryBean = <span class="keyword">new</span> ProxyFactoryBean();</span><br><span class="line">      proxyFactoryBean.setTarget(userService);</span><br><span class="line">      proxyFactoryBean.setInterceptorNames(<span class="string">&quot;testAroundAdvise&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> proxyFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>从map中数据丢失谈@RefreshScope</title>
    <url>/2023/09/13/%E4%BB%8Emap%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E8%B0%88@Refresh/</url>
    <content><![CDATA[<h1 id="从map中数据丢失谈-RefreshScope"><a href="#从map中数据丢失谈-RefreshScope" class="headerlink" title="从map中数据丢失谈@RefreshScope"></a>从map中数据丢失谈@RefreshScope</h1><h2 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h2><p>先展示一段出现问题代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;rule.enable&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowDynamicConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;rocketmq.name-server&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String rocketMqServer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.根据 nameServer 的地址以及 topic 和 tag 进行唯一性判断</span></span><br><span class="line"><span class="comment">     * 2.用 map 维护已经注册的监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, DefaultMQPushConsumer&gt; listeners = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RuleService ruleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RuleTriggerService ruleTriggerService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initConsumer</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        List&lt;TriggerVO.TriggerMQVO&gt; triggerMQVOS = ruleService.ruleMQTrigger();</span><br><span class="line">        triggerMQVOS.parallelStream().forEach( c -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                initConsumer(c.getTopic());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;MQ注册失败:&quot;</span> + c.getTopic(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        listeners.values().forEach(DefaultMQPushConsumer::shutdown);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化消费者，并放入 map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultMQPushConsumer <span class="title">initConsumer</span><span class="params">(String topic)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listeners.get(topic) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;csm-flow-consumer-group&quot;</span> + topic);</span><br><span class="line">            consumer.setNamesrvAddr(<span class="keyword">this</span>.rocketMqServer);</span><br><span class="line">            <span class="comment">// Subscribe one more more topics to consume.</span></span><br><span class="line">            consumer.subscribe(topic, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">            registerMsgListener(consumer);</span><br><span class="line">            listeners.put(topic, consumer);</span><br><span class="line">            log.info(<span class="string">&quot;注册了MQ消费者：&#123;&#125;&quot;</span>, topic);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listeners.get(topic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先执行 start 方法，再根据 topic 和 tag 进行消息监听器的注册</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumer 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerMsgListener</span> <span class="params">(DefaultMQPushConsumer consumer)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        <span class="comment">// Register callback to execute on arrival of messages fetched from brokers.</span></span><br><span class="line">        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&#123;&#125; ReceiveNewMessages: &#123;&#125;,, &#123;&#125;&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">            <span class="comment">// 获取的消息体</span></span><br><span class="line">            String body = <span class="keyword">new</span> String(msgs.get(<span class="number">0</span>).getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            log.info(<span class="string">&quot;topic,messageId:&#123;&#125;,&#123;&#125;&quot;</span>,msgs.get(<span class="number">0</span>).getTopic(),msgs.get(<span class="number">0</span>).getMsgId());</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            ruleTriggerService.mqTrigger(msgs.get(<span class="number">0</span>).getTopic(), msgs.get(<span class="number">0</span>).getTags(), body);</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的问题是：在服务运行后，listeners数据会丢失，导致MQ重新创建消费组，但是由于之前已经创建过，导致服务报错</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ol>
<li>一开始以为数据丢失，是不是多线程环境下的线程安全性问题，读取的线程没有读到数据，但是定义的listerners是ConcurrentHashMap，是个并发安全的容器</li>
<li>是不是类上面的@RefreshScope注解将数据刷掉了</li>
</ol>
<h2 id="RefreshScope原理"><a href="#RefreshScope原理" class="headerlink" title="@RefreshScope原理"></a>@RefreshScope原理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.cloud.context.config.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ScopedProxyMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convenience annotation to put a &lt;code&gt;<span class="doctag">@Bean</span>&lt;/code&gt; definition in</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.cloud.context.scope.refresh.RefreshScope refresh scope&#125;.</span></span><br><span class="line"><span class="comment"> * Beans annotated this way can be refreshed at runtime and any components that are using</span></span><br><span class="line"><span class="comment"> * them will get a new instance on the next method call, fully initialized and injected</span></span><br><span class="line"><span class="comment"> * with all dependencies.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Scope(&quot;refresh&quot;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RefreshScope &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> Scope#proxyMode()</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> proxy mode</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">ScopedProxyMode <span class="title">proxyMode</span><span class="params">()</span> <span class="keyword">default</span> ScopedProxyMode.TARGET_CLASS</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码上的注释的意思是：如果bean使用了这个注解，bean可以在运行时进行刷新，并且使用这些bean的任何组件都将在下一个方法调用前获得一个新实例，该实例讲完全初始化并注入所有依赖项。</p>
<p>RefreshScope(org.springframework.cloud.context.scope.refresh),是spring cloud提供的一种特殊的scope实现,用来实现配置、实例热加载。当有配置更新时，会触发ContextRefresher.refresh()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Set&lt;String&gt; <span class="title">refresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Set&lt;String&gt; keys = refreshEnvironment();</span><br><span class="line">   <span class="keyword">this</span>.scope.refreshAll();</span><br><span class="line">   <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Set&lt;String&gt; <span class="title">refreshEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; before = extract(</span><br><span class="line">				<span class="keyword">this</span>.context.getEnvironment().getPropertySources());</span><br><span class="line">		addConfigFilesToEnvironment();</span><br><span class="line">		Set&lt;String&gt; keys = changes(before,</span><br><span class="line">				extract(<span class="keyword">this</span>.context.getEnvironment().getPropertySources())).keySet();</span><br><span class="line">		<span class="keyword">this</span>.context.publishEvent(<span class="keyword">new</span> EnvironmentChangeEvent(<span class="keyword">this</span>.context, keys));</span><br><span class="line">		<span class="keyword">return</span> keys;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@ManagedOperation(description = &quot;Dispose of the current instance of all beans &quot;</span></span><br><span class="line"><span class="meta">			+ &quot;in this scope and force a refresh on next method execution.&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.destroy();</span><br><span class="line">		<span class="keyword">this</span>.context.publishEvent(<span class="keyword">new</span> RefreshScopeRefreshedEvent());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>源码的大体逻辑是：</p>
<ol>
<li>提取配置</li>
<li>将新的配置放入到新的Spring context容器中</li>
<li>比对获取发生更新的配置</li>
<li>发布环境配置更新的事件</li>
<li>清除refreshscope缓存销毁当前Bean，并在下一个方法调用时重新从BeanFactory生成新的Bean</li>
<li>发布refreshscope刷新事件</li>
</ol>
<p>综上：当nacos配置发生变动时，Spring会为添加了@RefreshScope注解的Bean，重建一个新的Bean代替原来的Bean，所以便出现了文中一开始的问题</p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring、nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>跨集群/服务商MQ通信方案</title>
    <url>/2023/09/14/%E8%B7%A8%E9%9B%86%E7%BE%A4MQ%E9%80%9A%E4%BF%A1%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="跨服务商MQ通信方案思路"><a href="#跨服务商MQ通信方案思路" class="headerlink" title="跨服务商MQ通信方案思路"></a>跨服务商MQ通信方案思路</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>现在下游有若干服务需要监听Pass服务开通业务的结果消息，但是由于上下游服务在不同的集群环境中，在不同的云服务商的服务器中。传统的服务直接的交互如下图</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230914151502948.png" alt="image-20230914151502948"></p>
<p>A服务和B服务直接通过http请求进行连接数据传输等交互，但是在此场景中。由于下游服务不会同步阻塞等待上游服务的消息，而是通过监听MQ消息实现异步处理。但AB两个服务在不同的云服务商的服务器中，各自有各自MQ实例，由于服务商之间的网络不通，无法直接监听对方的MQ消息。</p>
<h2 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h2><p>方案的思路是，在不同的集群环境中搭建同样一套代理服务，组成一个代理层服务，用于不同集群的消息交换。如下图</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230914155954014.png" alt="image-20230914155954014"></p>
<p>这样，整个业务链路分为了三个部分：A服务，消息代理层，B服务。其中：</p>
<ol>
<li>消息代理层由腾讯云中的消息代理服务A和阿里云消息代理服务B共同组成</li>
<li>各自代理服务负责对本集群中的服务消息进行收发</li>
<li>代理服务之间通过http请求进行消息的传递</li>
</ol>
<p>通过引入消息代理层，使得AB两个业务服务不需要进行定制化改造，A服务只需要将业务消息投递到消息代理层，B服务只需要监听消息代理层的消息。AB服务之间无感。后续的改动，只需要对消息代理层进行改动完善，而且一个集群环境只需要部署一个消息代理服务即可。</p>
<h2 id="关键实现"><a href="#关键实现" class="headerlink" title="关键实现"></a>关键实现</h2><p>上述设计的关键点在于，如何实现消息代理服务对消息的动态收发。通常我们在开发中，都是明确消息的topic和tag，然后将topic和tag写在类的注解上，那如何去动态监听topic和tag呢</p>
<p>核心代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 1.根据 nameServer 的地址以及 topic 和 tag 进行唯一性判断</span></span><br><span class="line"><span class="comment">   * 2.用 map 维护已经注册的监听器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> ConcurrentHashMap&lt;String, DefaultMQPushConsumer&gt; listeners = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="meta">@EventListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">envListener</span><span class="params">(EnvironmentChangeEvent event)</span> </span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;conf change: &quot;</span> + event);</span><br><span class="line">      <span class="keyword">for</span> (DefaultMQPushConsumer c : listeners.values()) &#123;</span><br><span class="line">          c.shutdown();</span><br><span class="line">      &#125;</span><br><span class="line">      listeners.clear();</span><br><span class="line">      registerConsumer();</span><br><span class="line">      log.info(<span class="string">&quot;listeners:count: &#123;&#125;&quot;</span>,listeners.values().size());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerConsumer</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">     List&lt;ConsumerInfo&gt; consumerInfoList =</span><br><span class="line">             JSON.parseArray(mqTransConfigRepository.getClusterMqAddress(), ConsumerInfo.class);</span><br><span class="line">      consumerInfoList.parallelStream().forEach( c -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              registerMsgListener(initConsumer(c),c);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化消费者，并放入 map</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> DefaultMQPushConsumer <span class="title">initConsumer</span><span class="params">(ConsumerInfo consumerInfo)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (listeners.get(consumerInfo.getTopic()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(consumerInfo.getGroup());</span><br><span class="line">          consumer.setNamesrvAddr(mqTransConfigRepository.getRocketmqNameServer());</span><br><span class="line">          <span class="comment">// Subscribe one more more topics to consume.</span></span><br><span class="line">          consumer.subscribe(consumerInfo.getTopic(), TAG_EXPRESSION);</span><br><span class="line">          listeners.put(consumerInfo.getTopic(), consumer);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> listeners.get(consumerInfo.getTopic());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 先执行 start 方法，再根据 topic 和 tag 进行消息监听器的注册</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> consumer 消费者</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerMsgListener</span> <span class="params">(DefaultMQPushConsumer consumer,ConsumerInfo consumerInfo)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">      <span class="comment">// Register callback to execute on arrival of messages fetched from brokers.</span></span><br><span class="line">      consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -&gt; &#123;</span><br><span class="line">          log.info(<span class="string">&quot;&#123;&#125; ReceiveNewMessages: &#123;&#125;,, &#123;&#125;&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">          <span class="comment">// 获取的消息体</span></span><br><span class="line">          String body =  <span class="keyword">new</span> String(msgs.get(<span class="number">0</span>).getBody(), StandardCharsets.UTF_8);</span><br><span class="line">          log.info(<span class="string">&quot;topic,messageId:&#123;&#125;,&#123;&#125;&quot;</span>,msgs.get(<span class="number">0</span>).getTopic(),msgs.get(<span class="number">0</span>).getMsgId());</span><br><span class="line">          <span class="comment">// 发送消息</span></span><br><span class="line">          sendMessage(body,consumerInfo.getAddressInfo(),msgs.get(<span class="number">0</span>).getTopic());</span><br><span class="line">          <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">      &#125;);</span><br><span class="line">      consumer.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上述实现主要做了：</p>
<ol>
<li>监听环境配置变动事件，当配置变动时，重新注册MQ监听器</li>
<li>初始化消费者，并放入map中，消费者订阅的消息topic和tag都是有ConsumerInfo封装的，可以根据实际业务场景设置对应的topic和tag</li>
<li>注册消费者</li>
<li>发送消息</li>
</ol>
]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL bigint和varchar进行比较的坑</title>
    <url>/2023/09/17/MySQL%20bigint%E5%92%8Cvarchar%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h1 id="MySQL-bigint和varchar进行比较的坑"><a href="#MySQL-bigint和varchar进行比较的坑" class="headerlink" title="MySQL bigint和varchar进行比较的坑"></a>MySQL bigint和varchar进行比较的坑</h1><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>这个问题是出在产线列表接口中，返回的数据量与预期的数据量不相符。由于列表是有数据权限的，当时以为是数据权限有问题。</p>
<h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><p>由于这个列表功能已经上线1年多了，而且最近一段时间一直没有对这块功能进行迭代。所以起初我排除了代码逻辑变动导致的问题。由于产品管理列表有权限控制，所以我开始怀疑是不是账号权限模型有问题。</p>
<h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230920113031509.png" alt="image-20230920113031509"></p>
<p>从打印的日志来看，数据权限并不多，然后结合项目中查询语句，在数据库中执行了一下</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230920113245866.png" alt="image-20230920113245866"></p>
<p>从sql的执行结果来看，确实有1300+的记录。但是仔细看一下结果集中的platform_client_id这一列值，是有很多不一样的值的。根据客户关系模型来看，platform_client_id应该不超过2个不一样的值的。这个时候问题的范围就缩小了，所以我就猜测是不是因为平台表中的platform_client_id的字段类型是varchar，而在客户表中的主键是bigint类型。不同的类型的字段进行数值比较的时候出现了差异，类似java中float类型精度丢失的问题。</p>
<h3 id="问题验证"><a href="#问题验证" class="headerlink" title="问题验证"></a>问题验证</h3><p>修改mybatis中的查询语句，将where条件中的客户id手动改为字符类型，然后执行SQL</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230920114050432.png" alt="image-20230920114050432"></p>
<p>此时，可以认定现象的本质原因就是子查询中不同数据类型进行比较时出现了问题。</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>后来我在网上发现了类似的问题：<a href="https://segmentfault.com/a/1190000041292478">实际上是varchar和bigint的转换问题</a> ，官方文档虽然没有明确指出bigint和varchar是如何进行比较的，但是有这么一段话</p>
<blockquote>
<p>The following rules describe how conversion occurs for comparison operations:</p>
<p>●   If one or both arguments are NULL, the result of the comparison is NULL, except for the NULL-safe <a href="https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to">&lt;=&gt;</a> equality comparison operator. For NULL &lt;=&gt; NULL, the result is true. No conversion is needed.</p>
<p>●   If both arguments in a comparison operation are strings, they are compared as strings.</p>
<p>●   If both arguments are integers, they are compared as integers.</p>
<p>●   Hexadecimal values are treated as binary strings if not compared to a number.</p>
<p>●   If one of the arguments is a <a href="https://dev.mysql.com/doc/refman/8.0/en/datetime.html">TIMESTAMP</a> or <a href="https://dev.mysql.com/doc/refman/8.0/en/datetime.html">DATETIME</a> column and the other argument is a constant, the constant is converted to a timestamp before the comparison is performed. This is done to be more ODBC-friendly. This is not done for the arguments to <a href="https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in">IN()</a>. To be safe, always use complete datetime, date, or time strings when doing comparisons. For example, to achieve best results when using <a href="https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_between">BETWEEN</a> with date or time values, use <a href="https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast">CAST()</a> to explicitly convert the values to the desired data type.A single-row subquery from a table or tables is not considered a constant. For example, if a subquery returns an integer to be compared to a <a href="https://dev.mysql.com/doc/refman/8.0/en/datetime.html">DATETIME</a> value, the comparison is done as two integers. The integer is not converted to a temporal value. To compare the operands as <a href="https://dev.mysql.com/doc/refman/8.0/en/datetime.html">DATETIME</a> values, use <a href="https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast">CAST()</a> to explicitly convert the subquery value to <a href="https://dev.mysql.com/doc/refman/8.0/en/datetime.html">DATETIME</a>.</p>
<p>●   If one of the arguments is a decimal value, comparison depends on the other argument. The arguments are compared as decimal values if the other argument is a decimal or integer value, or as floating-point values if the other argument is a floating-point value.</p>
<p>●   In all other cases, the arguments are compared as floating-point (double-precision) numbers. For example, a comparison of string and numeric operands takes place as a comparison of floating-point numbers.</p>
<p>其中“In all other cases, the arguments are compared as floating-point (double-precision) numbers. For example, a comparison of string and numeric operands takes place as a comparison of floating-point numbers.”</p>
</blockquote>
<p>就是说除了上述数据类型比较有明确的规则外，其余的不同数据类型的字段进行比较时，会转成浮点数进行比较，而浮点数由 IEEE 754标准定下的。IEEE 754规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）。查询官方文档中bigint的取值范围如下：</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230920114229712.png" alt="image-20230920114229712"></p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230920114241610.png" alt="image-20230920114241610"></p>
<p>回到这个问题，<strong>就是在整数转成二进制后，如果大于53位，只要前53位值一样，它们之间用=号就能返回true。</strong></p>
<h2 id="结论验证"><a href="#结论验证" class="headerlink" title="结论验证"></a>结论验证</h2><p>我们选择两个数据进行验证：3501875912769420370、3501875912769420530。</p>
<p>3501875912769420370 转为二进制数  <code>11000010011001001010011001011011000100000111100011110</code>001010010</p>
<p>3501875912769420530 转为二进制数</p>
<p><code>11000010011001001010011001011011000100000111100011110</code>011110010</p>
<p>看来确实是这么回事</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>踩坑记录</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里飞猪面试复盘（2023-09-22）</title>
    <url>/2023/09/22/%E9%98%BF%E9%87%8C%E9%A3%9E%E7%8C%AA%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</url>
    <content><![CDATA[<p>电话面试，面试时长大约40分钟。自我介绍环节不赘述</p>
<h2 id="mq消息丢失问题"><a href="#mq消息丢失问题" class="headerlink" title="mq消息丢失问题"></a>mq消息丢失问题</h2><p>首先要明确，消息从生产到消费完成这个过程，可以分成三个阶段，分别为：<strong>消息生产阶段、消息存储阶段和消息消费阶段</strong></p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230922213703437.png" alt="image-20230922213703437"></p>
<ul>
<li><strong>消息生产阶段：</strong> 从消息被生产出来，然后提交给 MQ 的过程中，只要能正常收到 MQ Broker 的 ack 确认响应，就表示发送成功，所以只要处理好返回值和异常，这个阶段是不会出现消息丢失的。</li>
<li><strong>消息存储阶段：</strong> 这个阶段一般会直接交给 MQ 消息中间件来保证，但是你要了解它的原理，比如 Broker 会做副本，保证一条消息至少同步两个节点再返回 ack</li>
<li><strong>消息消费阶段：</strong> 消费端从 Broker 上拉取消息，只要消费端在收到消息后，不立即发送消费确认给 Broker，而是等到执行完业务逻辑后，再发送消费确认，也能保证消息的不丢失。</li>
</ul>
<h3 id="如何保证消息可靠投递"><a href="#如何保证消息可靠投递" class="headerlink" title="如何保证消息可靠投递"></a>如何保证消息可靠投递</h3><ol>
<li>消息持久化：MQ可以将消息存储到磁盘中，即使MQ服务器崩溃或重启，也能够保证消息不会丢失。同时，MQ还可以通过主从复制等方式保证高可用性。</li>
<li>消息确认机制：当消费者消费完一条消息后，向MQ服务器发送确认消息，告诉MQ服务器该消息已经被消费，MQ服务器才会将该消息从队列中删除。如果消费者没有发送确认消息，MQ服务器会将该消息重新发送给其他消费者。</li>
<li>事务机制：MQ可以支持事务机制，在发送消息时开启事务，只有在事务提交成功后才会将消息发送到队列中，否则会进行回滚操作。</li>
<li>重试机制：当消息发送失败时，MQ会自动进行重试，直到消息被成功投递或达到最大重试次数。如果达到最大重试次数仍然无法成功投递，则会将该消息发送到死信队列中。</li>
</ol>
<h3 id="如何排查"><a href="#如何排查" class="headerlink" title="如何排查"></a>如何排查</h3><p>如果出现消息丢失的情况，可以通过以下几个步骤进行排查：</p>
<ol>
<li>确认消息是否已经发送到MQ，可以通过MQ的管理界面查看消息发送状态。</li>
<li>检查消费者的代码，确保消费者已经正确地连接到MQ并正确地处理消息。</li>
<li>检查消息是否被消费者拒绝或者消费者处理消息时出现异常。</li>
<li>检查MQ的配置，确保MQ的持久化配置正确，以保证消息能够在MQ中持久化存储。</li>
<li>检查网络连接，确保消息发送和接收的网络连接正常。</li>
<li>检查MQ的日志，查看是否有异常或错误日志。</li>
</ol>
<h2 id="oom如何排查"><a href="#oom如何排查" class="headerlink" title="oom如何排查"></a>oom如何排查</h2><ol>
<li><p>先通过内存映像工具对Dump出来的堆转储快照进行分析，<strong>重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出。</strong></p>
<ul>
<li><p>内存溢出：建议加大内存</p>
</li>
<li><p>观察内存，每一次gc后都有某一些不要的对象是gc不了的，一直占着空间，导致越来越多的对象堆积在内存中得不到释放，最终内存泄漏导致内存溢出。</p>
<p>解决思路：应该从代码层面进行解决，不需要的对象不要建立强引用。</p>
</li>
</ul>
</li>
<li><p>查看OOM错误日志：查找并分析系统的日志文件，通常会有关于OOM的错误信息。可以通过dmesg命令或者系统日志文件（如/var/log/messages）来查看。</p>
</li>
<li><p>检查系统资源使用情况：使用系统监控工具（如top、htop等）查看系统的内存、CPU和磁盘使用情况。检查是否存在异常的资源占用情况。</p>
</li>
<li><p>检查应用程序日志：查看应用程序的日志文件，寻找与OOM相关的错误或异常信息。这些信息可能会提供有关导致OOM的具体原因的线索。</p>
</li>
<li><p>分析堆栈信息：如果有可用的堆栈信息，可以分析其中的线程和方法调用，以确定是否存在内存泄漏或者异常的内存使用情况。</p>
</li>
<li><p>检查代码和配置：检查应用程序的代码和配置文件，特别是与内存管理相关的部分。确保没有存在不合理的内存使用或配置问题。</p>
</li>
<li><p>调整JVM参数：如果应用程序是基于Java开发的，可以尝试调整JVM参数，如堆大小、垃圾回收策略等，以优化内存使用和垃圾回收性能。</p>
</li>
<li><p>使用内存分析工具：如果以上方法无法解决问题，可以考虑使用专业的内存分析工具，如VisualVM、MAT（Memory Analyzer Tool）等，对应用程序进行详细的内存分析和排查。</p>
</li>
</ol>
<h2 id="HashTable和HashMap区别"><a href="#HashTable和HashMap区别" class="headerlink" title="HashTable和HashMap区别"></a>HashTable和HashMap区别</h2><p>Hashtable和HashMap都是实现了Map接口的数据结构，不同之处在于：</p>
<ul>
<li>线程安全性：Hashtable是线程安全的，而HashMap不是。如果需要在多线程环境下使用，可以选择Hashtable或者通过synchronized关键字来保证线程安全。</li>
<li>空值（null）：Hashtable不允许键或值为空，否则会抛出NullPointerException，而HashMap允许键或值为空。</li>
<li>性能：由于线程安全的原因，Hashtable的性能通常比HashMap差。如果不需要考虑线程安全，建议使用HashMap。</li>
</ul>
<h2 id="ConcurrentHashmap底层实现原理"><a href="#ConcurrentHashmap底层实现原理" class="headerlink" title="ConcurrentHashmap底层实现原理"></a>ConcurrentHashmap底层实现原理</h2><p>这里是ConcurrentHashMap是JDK1.8的</p>
<h3 id="ConcurrentHashMap-整体架构"><a href="#ConcurrentHashMap-整体架构" class="headerlink" title="ConcurrentHashMap 整体架构"></a>ConcurrentHashMap 整体架构</h3><p>它是由数组、 单向链表、红黑树组成。当我们初始化一个 ConcurrentHashMap 实例时，默认会初始化一个长度为 16 的数组。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230923104835046.png" alt="image-20230923104835046"></p>
<p> 由于 ConcurrentHashMap 它的核心仍然是 hash 表，所以必然会存在 hash 冲突问题。 ConcurrentHashMap 采用链式寻址法来解决 hash 冲突。<br> 当 hash 冲突比较多的时候，会造成链表长度较长，这种情况会使得 ConcurrentHashMap 中数据元素的查询复杂度变成 O(n)。因此在 JDK1.8 中，引入了 红黑树的机制。<br> 当数组长度大于 64 并且链表长度大于等于 8 的时候，单项链表就会转换为红黑树。 另外，随着 ConcurrentHashMap 的动态扩容，一旦链表长度小于 6，红黑树会退化 成单向链表。在JDK8中这个阈值是固定的</p>
<p>注：在JDK9中ConcurrentHashMap 引入了一种动态计算阈值的机制，以更好地适应不同场景下的数据结构变化。当元素数量减少时，ConcurrentHashMap 也会根据当前数组的长度和元素数量，计算出一个负载因子，并根据负载因子动态调整阈值。如果负载因子小于一个阈值，就会触发缩容操作。</p>
<h3 id="ConcurrentHashMap的基础功能"><a href="#ConcurrentHashMap的基础功能" class="headerlink" title="ConcurrentHashMap的基础功能"></a>ConcurrentHashMap的基础功能</h3><p>ConcurrentHashMap 本质上是一个 HashMap，因此功能和 HashMap 一样，但是 ConcurrentHashMap 在 HashMap 的基础上，提供了并发安全的实现。 并发安全的主要实现是通过对指定的 Node 节点加锁，来保证数据更新的安全性</p>
<h3 id="ConcurrentHashMap的性能优化"><a href="#ConcurrentHashMap的性能优化" class="headerlink" title="ConcurrentHashMap的性能优化"></a>ConcurrentHashMap的性能优化</h3><ul>
<li><p>在 JDK1.8 中，ConcurrentHashMap 锁的粒度是数组中的某一个节点，而在 JDK1.7，锁定的是 Segment，锁的范围要更大，因此性能上会更低。</p>
</li>
<li><p>引入红黑树，降低了数据查询的时间复杂度，红黑树的时间复杂度是 O(logn)。</p>
</li>
<li><p>当数组长度不够时，ConcurrentHashMap 需要对数组进行扩容，在扩容的实现上，ConcurrentHashMap 引入了多线程并发扩容的机制， 简单来说就是多个线程对原始数组进行分片后，每个线程负责一个分片的数据 迁移，从而提升了扩容过程中数据迁移的效率。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230923122202127.png" alt="image-20230923122202127"></p>
</li>
<li><p>ConcurrentHashMap 中有一个 size()方法来获取总的元素个数，而在多线程 并发场景中，在保证原子性的前提下来实现元素个数的累加，性能是非常低的。 ConcurrentHashMap 在这个方面的优化主要体现在两个点:</p>
<ul>
<li>当线程竞争不激烈时，直接采用 CAS 来实现元素个数的原子递增。</li>
<li>如果线程竞争激烈，使用一个数组来维护元素个数，如果要增加总的元素 个数，则直接从数组中随机选择一个，再通过 CAS 实现原子递增。它的核心思想是引入了数组来实现对并发更新的负载。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230923122429620.png" alt="image-20230923122429620"></p>
</li>
</ul>
<h2 id="sql如何优化"><a href="#sql如何优化" class="headerlink" title="sql如何优化"></a>sql如何优化</h2><ul>
<li><p>优化查询语句：避免使用子查询、不必要的 JOIN、OR 等操作，尽量使用 UNION、IN、EXISTS 等操作；使用 LIMIT 分页，避免一次性查询大量数据；使用索引优化查询等。</p>
</li>
<li><p>优化数据库结构：合理设计数据库表结构，避免冗余字段、冗余表等，尽量使用整型作为主键，避免使用字符串类型等；避免使用过多的触发器、存储过程等。</p>
</li>
<li><p>优化索引：使用合适的索引可以极大地提高查询性能，但是过多的索引也会影响性能；需要根据具体情况进行选择，可以使用 EXPLAIN 等命令来查看查询语句的执行计划，从而确定是否需要创建或删除索引。</p>
</li>
<li><p>优化数据库连接：尽量减少数据库连接的次数，使用连接池等工具来管理连接；避免在循环中进行数据库连接等操作。</p>
</li>
<li><p>优化数据访问：尽量减少数据访问次数，使用缓存等机制来提高数据访问效率；避免一次性查询大量数据，可以进行分批查询等操作。</p>
</li>
</ul>
<h2 id="项目中为什么要用ES"><a href="#项目中为什么要用ES" class="headerlink" title="项目中为什么要用ES"></a>项目中为什么要用ES</h2><p>项目使用 Elasticsearch （简称 ES）的原因有以下几点：</p>
<ul>
<li>快速搜索：Elasticsearch 是一个基于 Lucene 的搜索引擎，具有非常快的搜索速度和高效的分布式架构，可以快速地处理大量数据。</li>
<li>高可靠性：Elasticsearch 具有高可靠性和容错性，支持数据备份和自动恢复，可以保证数据的安全和可靠性。</li>
<li>强大的扩展性：Elasticsearch 具有强大的扩展性，支持插件机制和 API 接口，可以方便地进行二次开发和定制。</li>
<li>多种数据类型支持：Elasticsearch 支持多种数据类型的索引和搜索，包括文本、数字、日期等等，可以满足不同场景下的需求。</li>
<li>大量数据存储：Elasticsearch 可以存储大量数据，支持 PB 级别的数据存储和搜索，可以满足大型项目的需求。</li>
<li>实时搜索：Elasticsearch 支持实时搜索，可以在数据更新后立即进行搜索，满足实时搜索的需求</li>
</ul>
<p>其他问题：</p>
<ol>
<li>项目架构描述</li>
<li>项目中的亮点，难点以及如何解决的</li>
<li><strong>spring初始方法</strong>：@PostConstruct 是一个注解，用于指定一个方法在 Bean 初始化完成后执行。具体来说，当 Bean 实例化、属性注入、Aware 回调、前置处理等操作完成后，Spring 会调用 @PostConstruct 标注的方法，执行一些初始化操作。</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>复盘</tag>
      </tags>
  </entry>
  <entry>
    <title>一行日志导致的OOM事件</title>
    <url>/2023/09/26/%E4%B8%80%E8%A1%8C%E6%97%A5%E5%BF%97%E5%AF%BC%E8%87%B4%E7%9A%84OOM%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="一行日志导致的OOM事件"><a href="#一行日志导致的OOM事件" class="headerlink" title="一行日志导致的OOM事件"></a>一行日志导致的OOM事件</h1><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>简单交代一下问题背景和现象：产线SSO登录服务运行一段时间就会出现LDAP连接无响应，最终导致客户端超时的现象，并且通过日志观察，存在大量OOM异常</p>
<h2 id="问题排查过程"><a href="#问题排查过程" class="headerlink" title="问题排查过程"></a>问题排查过程</h2><ol>
<li><p>联系运维，拉取nginx的access log 查看请求源ip，判断是否存在测试脚本频繁请求</p>
</li>
<li><p>经过排查发现并不是外部请求导致的OOM</p>
</li>
<li><p>然后拉取了dump日志文件</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230926234702045.png" alt="image-20230926234702045"></p>
<p>怀疑存在内存泄露，发现有个对象占用了3.7G内存</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230926234754955.png" alt="image-20230926234754955"></p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230926234819849.png" alt="image-20230926234819849"></p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230926234833581.png" alt="image-20230926234833581"></p>
</li>
<li><p>查看该对象具体信息，发现属性workQueue占用了3.7G，明显是一个队列，翻一翻源码去</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230926234936940.png" alt="image-20230926234936940"></p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230926234948523.png" alt="image-20230926234948523"></p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230926234957220.png" alt="image-20230926234957220"></p>
</li>
<li><p>看看队列是哪里消费的，先理一下代码逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> AtomicLong completedTaskCount = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    Runnable task = fetchTask();</span><br><span class="line"></span><br><span class="line">                    idleWorkers.decrementAndGet();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (workers.size() &gt; corePoolSize) &#123;</span><br><span class="line">                                <span class="comment">// Remove now to prevent duplicate exit.</span></span><br><span class="line">                                workers.remove(<span class="keyword">this</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (task == EXIT_SIGNAL) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            queueHandler.polled(UnorderedThreadPoolExecutor.<span class="keyword">this</span>, (IoEvent) task);</span><br><span class="line">                            runTask(task);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        idleWorkers.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">                    workers.remove(<span class="keyword">this</span>);</span><br><span class="line">                    UnorderedThreadPoolExecutor.<span class="keyword">this</span>.completedTaskCount += completedTaskCount.get();</span><br><span class="line">                    workers.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Runnable <span class="title">fetchTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Runnable task = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> deadline = currentTime + getKeepAliveTime(TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">long</span> waitTime = deadline - currentTime;</span><br><span class="line">                    <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task = getQueue().poll(waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            currentTime = System.currentTimeMillis();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// Ignore.</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            beforeExecute(thread, task);</span><br><span class="line">            <span class="keyword">boolean</span> ran = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                task.run();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">                afterExecute(task, <span class="keyword">null</span>);</span><br><span class="line">                completedTaskCount.incrementAndGet();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ran) &#123;</span><br><span class="line">                    afterExecute(task, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230926235105569.png" alt="image-20230926235105569"></p>
</li>
<li><p> 其实看到第4步中的截图，idleWorkers = 0才会创建工作线程，就猜想会不会是idleWorkds不为0？果然，分析dump文件的确不是0。然后继续猜想idleWorkers不为0，但是workers的size却为0，会不会有线程安全问题，看了workers的操作都加了synchronized， idleWorkers这个又是AtomicInteger类型的，推敲了好一会，想不出有什么线程安全的问题</p>
</li>
<li><p>否定了这个猜想后，继续排查，猜想除非是下图的第4步出现异常，可能导致问题</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230926235454316.png" alt="image-20230926235454316"></p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230926235502275.png" alt="image-20230926235502275"></p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230926235508051.png" alt="image-20230926235508051"></p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230926235514520.png" alt="image-20230926235514520"></p>
</li>
<li><p>那么何时才会导致这边抛出异常呢？想到了现象中的第3点的空指针异常，本地进行debug模拟，发现无论怎么模拟都是Exception异常，最终都会被捕获掉，抛不上去</p>
</li>
<li><p>又猜想会不会是高并发问题，于是本地模拟高并发，发现还是没有问题</p>
</li>
<li><p>联想到了现象1，因为产线运行一段时间后会出现ldap连接不上的情况，于是进行验证，发现产线果然又连不上了</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230926235602286-20230926235614460-20230926235626670.png"></p>
</li>
<li><p>拉取产线dump文件，果然idleWorkers不为0，且工作线程队列的size也为0</p>
</li>
<li><p>至此排除了高并发导致的问题，因为此刻的产线的现象3的问题已经解决了</p>
</li>
<li><p>  看看上线以来产线进行了哪些特殊操作，产线两台实例，都进行了yapi连接之后就再也没有ldap连接了，会不会是yapi的问题？</p>
</li>
<li><p>本地进行用yapi进行模拟请求，果然必现了，下图打印日志的地方导致了栈溢出了，该对象依赖了自身，导致了循环</p>
</li>
<li><p>本质原因就是因为此处的异常，导致了idleWorkers不为0，然后工作线程不再创建了，而后产线大量的现象3导致了oom，且也导致了现象1</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230926235854545.png" alt="image-20230926235854545"></p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230926235925621.png" alt="image-20230926235925621"></p>
<h2 id="问题结论"><a href="#问题结论" class="headerlink" title="问题结论"></a>问题结论</h2><p>通过上面的分析，可以得出结论，在使用<code>JSONUtil.toJsonStr(obj);</code>时出现了异常，那具体的异常又是如何的呢?</p>
<p>首先看一下hutool包中的序列化方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Object source)</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != source) &#123;</span><br><span class="line">            JSONSerializer serializer = GlobalSerializeMapping.getSerializer(source.getClass());</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != serializer &amp;&amp; JSONArray.class.equals(TypeUtil.getTypeArgument(serializer.getClass()))) &#123;</span><br><span class="line">                serializer.serialize(<span class="keyword">this</span>, source);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source <span class="keyword">instanceof</span> CharSequence) &#123;</span><br><span class="line">                <span class="keyword">this</span>.init((CharSequence)source);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source <span class="keyword">instanceof</span> JSONTokener) &#123;</span><br><span class="line">                <span class="keyword">this</span>.init((JSONTokener)source);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Object iter;</span><br><span class="line">                <span class="keyword">if</span> (ArrayUtil.isArray(source)) &#123;</span><br><span class="line">                    iter = <span class="keyword">new</span> ArrayIter(source);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source <span class="keyword">instanceof</span> Iterator) &#123;</span><br><span class="line">                    iter = (Iterator)source;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!(source <span class="keyword">instanceof</span> Iterable)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">&quot;JSONArray initial value should be a string or collection or array.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    iter = ((Iterable)source).iterator();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(((Iterator)iter).hasNext()) &#123;</span><br><span class="line">                    Object next = ((Iterator)iter).next();</span><br><span class="line">                    <span class="keyword">if</span> (next != source) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.add(next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上作者检查了循环引用，但是只检查了简单的直接引用，多层嵌套的未作处理,即，如果A引用了B对象，B对象又引用了A对象，形成嵌套，就会导致上述问题。</p>
<p>注：经过测试fastjson对以上情况能够兼容处理，并输出循环引用对象（前提是没有设置SerializerFeature.DisableCircularReferenceDetect）</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title>面试复盘（2023-09-27）</title>
    <url>/2023/09/27/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98%EF%BC%882023-09-27%EF%BC%89/</url>
    <content><![CDATA[<p>电话面试，面试时长大约20分钟。自我介绍环节不赘述</p>
<h2 id="Spring-bean的生命周期"><a href="#Spring-bean的生命周期" class="headerlink" title="Spring bean的生命周期"></a>Spring bean的生命周期</h2><p>Bean的生命周期大体可以分为4个阶段</p>
<h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><ol>
<li>实例化前：在实例化之前，Spring会扫描上下文，拿到BeanDefinition，并且会判断是否有其他BeanDefinition，如果有的话会进行合并</li>
<li>然后调用BeanFactory所设置的类加载器进行加载，如果没有设置则使用ClassUtils.getDefaultClassLoader()方法返回的类加载器进行加载</li>
<li>实例化，通过反射得到一个实例对象</li>
</ol>
<h3 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h3><p>在属性赋值阶段主要是为 Bean 设置相关属性和依赖，Spring会根据配置文件或注解中的属性值，将对应的值注入到Bean中。</p>
<p>在进行属性赋值时，Spring会递归地处理Bean之间的依赖关系。如果一个Bean依赖于另一个Bean，Spring会先创建被依赖的Bean，并将其注入到需要依赖它的Bean中。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Spring初始化是在属性赋值完成后，容器对Bean进行了一下额外的处理，使Bean达到可用的状态的过程。具体来说会有以下工作：</p>
<ol>
<li>如果Bean实现了InitializingBean接口，Spring会调用其afterPropertiesSet()方法，用于执行一些初始化操作。</li>
<li>如果在配置文件或注解中指定了init-method属性，则Spring会调用指定的方法，用于执行一些初始化操作。</li>
<li>如果Bean实现了BeanPostProcessor接口，Spring会调用其postProcessBeforeInitialization()方法，用于在Bean初始化之前进行一些自定义处理。</li>
<li>Spring会调用Bean的构造方法或工厂方法，创建Bean实例。</li>
<li>如果Bean实现了BeanNameAware接口，Spring会调用其setBeanName()方法，用于设置Bean的名称。</li>
<li>如果Bean实现了BeanFactoryAware或ApplicationContextAware接口，Spring会调用其setBeanFactory()或setApplicationContext()方法，用于设置Bean所属的工厂或应用上下文。</li>
<li>如果在配置文件或注解中指定了scope属性，则根据指定的作用域创建Bean实例。</li>
<li>如果Bean实现了BeanPostProcessor接口，Spring会调用其postProcessAfterInitialization()方法，用于在Bean初始化之后进行一些自定义处理。</li>
</ol>
<h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><ol>
<li>容器关闭，发布ContextClosedEvent事件</li>
<li>调用LifecycleProcessor的onClose方法</li>
<li>销毁单例bean<ul>
<li>找出所有DisposableBean</li>
<li>遍历DisposableBean</li>
<li>找出依赖了当前DisposableBean的其他Bean,并从单例池中移除掉</li>
<li>调用DisposableBean的destory方法</li>
<li>找到当前DisposableBean所包含的inner beans，将这些Bean从单例池中移除掉</li>
</ul>
</li>
</ol>
<h2 id="Spring-bean的扩展点有哪些，你用过哪些"><a href="#Spring-bean的扩展点有哪些，你用过哪些" class="headerlink" title="Spring bean的扩展点有哪些，你用过哪些"></a>Spring bean的扩展点有哪些，你用过哪些</h2><p>Spring框架提供了很多扩展点，可以方便地扩展和定制Spring框架的行为。以下是Spring常用的扩展点：</p>
<ol>
<li><p>BeanFactoryPostProcessor：BeanFactoryPostProcessor是Spring容器启动后第一个执行的扩展点。它可以修改BeanFactory中的Bean定义，例如添加新的属性值、修改属性值等。</p>
</li>
<li><p>BeanPostProcessor：BeanPostProcessor是在Spring容器实例化Bean之后、初始化Bean之前执行的扩展点。它可以对Bean进行增强，例如添加新的属性、修改属性值等。</p>
</li>
<li><p>InstantiationAwareBeanPostProcessor：InstantiationAwareBeanPostProcessor是在Spring容器实例化Bean之后、初始化Bean之前执行的扩展点。它可以在Bean实例化之前或之后进行一些操作，例如修改Bean的实例化方式、修改属性值等。</p>
</li>
<li><p>ApplicationContextAware：ApplicationContextAware是在Spring容器实例化Bean之后、初始化Bean之前执行的扩展点。它可以让Bean获取到ApplicationContext对象，从而访问Spring容器中的其他Bean</p>
</li>
<li><p>BeanFactoryAware：BeanFactoryAware是在Spring容器实例化Bean之后、初始化Bean之前执行的扩展点。它可以让Bean获取到BeanFactory对象，从而访问Spring容器中的其他Bean。</p>
</li>
<li><p>InitializingBean：InitializingBean是在Spring容器实例化Bean之后、初始化Bean之前执行的扩展点。它可以让Bean在初始化之前执行一些操作。</p>
</li>
<li><p>DisposableBean：DisposableBean是在Spring容器关闭之前执行的扩展点。它可以让Bean在销毁之前执行一些操作。</p>
</li>
<li><p>ApplicationListener：准确的说，这个应该不算spring&amp;springboot当中的一个扩展点，<code>ApplicationListener</code>可以监听某个事件的<code>event</code>，触发时机可以穿插在业务方法执行过程中，用户可以自定义某个业务事件。接下来罗列下spring主要的内置事件：</p>
<ul>
<li><p>ContextRefreshedEvent</p>
<p>ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在<code> ConfigurableApplicationContext</code>接口中使用 <code>refresh() </code>方法来发生。此处的初始化是指：所有的Bean被成功装载，后处理Bean被检测并激活，所有Singleton Bean 被预实例化，<code>ApplicationContext</code>容器已就绪可用。</p>
</li>
<li><p>ContextStartedEvent</p>
<p>当使用 <code>ConfigurableApplicationContext</code> （ApplicationContext子接口）接口中的 start() 方法启动 <code>ApplicationContext </code>时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</p>
</li>
<li><p>ContextStoppedEvent</p>
<p>当使用 <code>ConfigurableApplicationContext </code>接口中的 <code>stop() </code>停止<code> ApplicationContext</code> 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作</p>
</li>
<li><p>ContextClosedEvent</p>
<p>当使用 <code>ConfigurableApplicationContext</code>接口中的 <code>close()</code>方法关闭 <code>ApplicationContext</code> 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启</p>
</li>
<li><p>RequestHandledEvent</p>
<p>这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。只能应用于使用DispatcherServlet的Web应用。在使用Spring作为前端的MVC控制器时，当Spring处理用户请求结束后，系统会自动触发该事件</p>
</li>
</ul>
</li>
</ol>
<h2 id="Springboot-stater的实现原理"><a href="#Springboot-stater的实现原理" class="headerlink" title="Springboot-stater的实现原理"></a>Springboot-stater的实现原理</h2><p>springBoot starter基于约定大于配置思想，使用spi机制及自动装配原理，可以将一些通用的功能能够封装成一个独立组件并很方便的集成到不同的项目里面，简化开发，提升代码复用能力。</p>
<p>其中：</p>
<ol>
<li><p>SPI机制：SPI(Service Provider Interface)是一种服务提供发现机制，可以用来启用框架扩展和替换组件,主要用于框架中开发，例如Dubbo、Spring、Common-Logging，JDBC等采用采用SPI机制，针对同一接口采用不同的实现提供给不同的用户，从而提高了框架的扩展性。ava内置的SPI通过java.util.ServiceLoader类使用load方法解析classPath和jar包的META-INF/services/目录 下的以接口全限定名命名的文件，并加载该文件中指定的接口实现类，以此完成调用。 Spring SPI沿用了Java SPI的设计思想，Spring采用的是spring.factories方式实现SPI机制，可以在不修改Spring源码的前提下，提供Spring框架的扩展性。如自动装配里面获取自动配置的各种实现类,starter里面的spring.factories文件里的内容都是某某注解类型（接口）=对应的实现类。</p>
</li>
<li><p>自动装配：</p>
<ul>
<li><p>引入 Starter 启动依赖组件的时候，这个组件里面必须要包含@Configuration 配置类，在这个配置类里面通过@Bean 注解声明需要装配到 IOC 容器的 Bean 对象。</p>
</li>
<li><p>这个配置类是放在第三方的 jar 包里面，然后通过 SpringBoot 中的约定优于配置</p>
<p>思想，把这个配置类的全路径放在 classpath:/META-INF/spring.factories 文件 中。这样 SpringBoot 就可以知道第三方 jar 包里面的配置类的位置，这个步骤主 要是用到了 Spring 里面的 SpringFactoriesLoader 来完成的。</p>
</li>
<li><p>SpringBoot 拿到所第三方 jar 包里面声明的配置类以后，再通过 Spring 提供的 ImportSelector 接口，实现对这些配置类的动态加载。</p>
</li>
</ul>
</li>
</ol>
<h2 id="Mybatis-plus方便CRUD的原理"><a href="#Mybatis-plus方便CRUD的原理" class="headerlink" title="Mybatis-plus方便CRUD的原理"></a>Mybatis-plus方便CRUD的原理</h2><p>Mybatis-Plus是一个基于Mybatis的增强工具，它提供了一系列方便CRUD的API，大大简化了数据访问层的开发。</p>
<p>Mybatis-Plus的方便CRUD主要基于以下两个原理：</p>
<ol>
<li>代码生成器：Mybatis-Plus提供了一个代码生成器，可以根据数据库表自动生成对应的Java实体类、Mapper接口和XML映射文件。生成的代码已经包含了基本的CRUD操作，我们只需要在此基础上进行扩展即可。这样可以大大减少手写代码的工作量。</li>
<li>封装通用CRUD操作：Mybatis-Plus在Mapper接口中封装了一些通用的CRUD操作，如插入、更新、删除和查询等。这些操作都有对应的方法，我们可以直接调用这些方法完成相应的操作，而不需要手写SQL语句。</li>
</ol>
<h2 id="讲讲AQS的理解"><a href="#讲讲AQS的理解" class="headerlink" title="讲讲AQS的理解"></a>讲讲AQS的理解</h2><p>一言蔽之：AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。</p>
<h3 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h3><p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。</p>
<p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p>
<p>AQS定义了两种资源共享方式：独占和共享。独占模式下，同一时刻只有一个线程可以获得锁；而共享模式下，多个线程可以同时获得锁。</p>
<p>AQS的实现主要依赖于子类实现的两个方法：tryAcquire和tryRelease。在独占模式下，tryAcquire方法用于尝试获取锁，而tryRelease方法用于释放锁；在共享模式下，tryAcquireShared方法用于尝试获取共享资源，而tryReleaseShared方法用于释放共享资源。</p>
<h2 id="讲讲线程池中的参数"><a href="#讲讲线程池中的参数" class="headerlink" title="讲讲线程池中的参数"></a>讲讲线程池中的参数</h2><blockquote>
<p><a href="https://he-you.github.io/2021/01/06/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0/">线程池相关参数</a></p>
</blockquote>
<h2 id="线程池的拒绝策略有哪些，工作中使用的是哪个"><a href="#线程池的拒绝策略有哪些，工作中使用的是哪个" class="headerlink" title="线程池的拒绝策略有哪些，工作中使用的是哪个"></a>线程池的拒绝策略有哪些，工作中使用的是哪个</h2><p><a href="https://he-you.github.io/2021/01/06/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0/">线程池相关参数</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>复盘</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL InnoDB缓冲池</title>
    <url>/2023/09/28/MySQL%20InnoDB%E7%BC%93%E5%86%B2%E6%B1%A0/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230928155716575.png" alt="image-20230928155716575"></p>
<p>上图是MySQL使用InnoDB存储引擎时，写操作的执行过程。而Buffer Pool缓冲池是InnoDB存储引擎中至关重要的部分，它负责加载磁盘中的数据，并将数据存入内存中，以此可以大大提高MySQL的读写操作的效率。下面会仔细介绍Buffer Pool中的数据结构</p>
<h2 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h2><p>我们操作的数据都是以表 + 行的方式，而表 + 行仅仅是逻辑上的概念，MySQL并不会像我们一样去操作行数据，而是抽象出来一个一个的数据页概念，默认大小16KB。一个数据页存放着多条数据，MySQL在执行读写操作时，会先定位到这条数据所在的数据页，然后将数据所在的数据页加载到Buffer Pool中。</p>
<p>数据页包括七个部分，结构如下图：</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20231006204201309.png" alt="image-20231006204201309"></p>
<p>这 7 个部分的作用如下图：</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/fabd6dadd61a0aa342d7107213955a72.png" alt="图片"></p>
<p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表</p>
<h2 id="缓存页"><a href="#缓存页" class="headerlink" title="缓存页"></a>缓存页</h2><p>当数据页被加载到缓冲池中后，Buffer Pool 中也有叫缓存页的概念与其一一对应，大小同样是 16KB，但是 MySQL还为每个缓存也开辟额外的一些空间，用来描述对应的缓存页的一些信息，例如：数据页所属的表空间，数据页号，这些描述数据块的大小大概是缓存页的15%左右（约800KB）。</p>
<h2 id="Free链"><a href="#Free链" class="headerlink" title="Free链"></a>Free链</h2><p>MySQL 为 Buffer Pool 设计了一个双向链表— free链表，这个 free 链表的作用就是用来保存空闲缓存页的描述块，另外 free 链表还会有一个基础节点，他会引用该链表的头结点和尾结点，还会记录节点的个数，也就是可用的空闲的缓存页的个数</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20230928162845410.png" alt="image-20230928162845410"></p>
<p>当加载数据页到缓存池中的时候， MySQL会从 free 链表中获取一个描述数据的信息，根据描述节点的信息拿到其对应的缓存页，然后将数据页信息放到该缓存页中，同时将链表中的该描述数据的节点移除。这就是数据页被读取 Buffer Pool 中的缓存页的过程。</p>
<h2 id="脏页"><a href="#脏页" class="headerlink" title="脏页"></a>脏页</h2><p>脏页是指内存中已经被修改但还没有被写回磁盘的数据页。当MySQL需要从内存中淘汰一个脏页时，需要将其写回到磁盘，这个过程称为脏页刷新。</p>
<h2 id="Flush链"><a href="#Flush链" class="headerlink" title="Flush链"></a>Flush链</h2><p>MySql 在执行增删改的时候会一直将数据以数据页的形式加载到 Buffer Pool 的缓存页中，增删改的操作都是在内存中执行的，然后会有一个后台的线程数将脏数据刷新到磁盘中，而如何区分哪些需要刷入磁盘的数据呢？为此MySQL设计了这个Flush链，与Free链一样是个双向链表，同样的这些已经被修改了的数据所在的缓存页的描述数据会被维护到 Flush 中，所以 Flush 中维护的是一些脏数据数据描述（准确地说是脏数据的所在的缓存页的数据描述）</p>
<h2 id="LRU链"><a href="#LRU链" class="headerlink" title="LRU链"></a>LRU链</h2><p>LRU（Least Recently Used）是一种常用的缓存淘汰算法，它根据数据的历史访问记录来淘汰缓存中最近最少使用的数据。在MySQL中，InnoDB存储引擎默认使用LRU算法来淘汰缓存中的数据页。当缓存空间不足时，InnoDB会将最近最少使用的脏页刷新回磁盘，并将其从缓存中淘汰。</p>
<p>工作原理：每次查询数据时，如果数据已经在缓存页中，那么就会将缓存页对应的描述信息放到LRU链表的头部，如果不存在就去磁盘中查找，找到了加载到缓存中，并将该数据对应的缓存页描述信息插入到LRU链表的头部。</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20231006213811153.png" alt="image-20231006213811153"></p>
<p>为了提高缓存效率，可以通过调整innodb_buffer_pool_size参数来增加缓存空间。同时，可以通过调整innodb_old_blocks_time和innodb_lru_scan_depth参数来优化LRU算法的性能。</p>
<h3 id="引入LRU链带来的问题"><a href="#引入LRU链带来的问题" class="headerlink" title="引入LRU链带来的问题"></a>引入LRU链带来的问题</h3><p>这里说的的问题，并不是LRU链的问题，而是MySQL本身的预读机制带来的问题。所谓的预读机制就是： MySQL 在从磁盘加载数据的的时候，会将数据页的相邻的其他的数据页也加载到缓存中。因为根据经验和习惯，一般查询数据的时候往往还会查询该数据相邻前后的一些数据，MySQL 为了提高效率，会将某个数据页的相邻的数据页也加载到缓存池中。这样的话，LRU链中的顺序可能不能满足LRU特性。</p>
<h3 id="基于冷热数据分离的LRU链表"><a href="#基于冷热数据分离的LRU链表" class="headerlink" title="基于冷热数据分离的LRU链表"></a>基于冷热数据分离的LRU链表</h3><p>MySQL预读机制导致LRU失效的解决方案：即对LRU的数据进行冷热分离，所谓的冷热分离，就是将 LRU 链表分成两部分，一部分是经常被使用到的热数据，另一部分是被加载进来但是很少使用的冷数据。通过参数innodb_old_blocks_pct 参数控制的，默认为37，也就是 37% 。用图表示大致如下：</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20231006215536686.png" alt="image-20231006215536686"></p>
<p>数据在从磁盘被加载到缓存池的时候，首先是会被放在冷数据区的头部，然后在<code>一定时间</code>之后，如果再次访问了这个数据，那么这个数据所在的缓存页对应描述数据就会被放转移到热数据区链表的头部。</p>
<p>之所以不在访问后立马放入热数据区，是因为如果某条数据刚被加载到缓存池中，然后紧接着又被访问了一次，这个时候假设就将其转移到热数据区链表的头部，但是以后就再也不会被使用了，这种场景也是不能解决LRU链失效的问题。</p>
<p>所以 MySQL通过<code>innodb_old_blocks_time</code>来设置数据被加载到缓存池后的多少时间之后再次被访问，才会将该数据转移到热数据区链表的头部，该参数默认是1000单位为：毫秒，也就是1秒之后，如果该数据又被访问了，那么这个时候才会将该数据从 LRU 链表的冷数据区转移到热数据区。</p>
<p>但是这样子还不是足够完美，为什么这么说，刚刚我们一直在讨论的是冷数据区的数据被访问，然后在一定规则之下会被加载到热数据链表的头部，但是现在某个请求需要访问的数据就在热数据区，那是不是直接把该数据所在的缓存页对应的描述数据转移到热数据区链表头部呢？</p>
<p>所以 MySQL针对热数据区的数据的转移也有相关的规则</p>
<h3 id="冷热数据转移规则"><a href="#冷热数据转移规则" class="headerlink" title="冷热数据转移规则"></a>冷热数据转移规则</h3><p><strong>如果被访问的数据所在的缓存页在热数据区的前25%，那么该缓存页对应的描述数据是不会被转移到热数据链表的头部的，只有当被访问的缓存页对应的描述数据在热数据区链表的后75%，该缓存页的描述数据才会被转移到热数据链表的头部</strong>。</p>
<h2 id="Buffer-Pool在并发环境中的表现"><a href="#Buffer-Pool在并发环境中的表现" class="headerlink" title="Buffer Pool在并发环境中的表现"></a>Buffer Pool在并发环境中的表现</h2><p>在正常的环境中不可能每次只有一个请求来访问的，说白了就是如果多个请求同时来执行增删改，那他们会并行的去操作 Buffer Pool 中的各种链表吗？如果是并行的会不会有什么问题。</p>
<p>实际上 MySQL在处理这个问题的时候考虑得非常简单，就是： <strong>Buffer Pool 一次只能允许一个线程来操作，一次只有一个线程来执行这一系列的操作，因为MySQL 为了保证数据的一致性，操作的时候必须缓存池加锁，一次只能有一个线程获取到锁</strong>。</p>
<p>当然MySQL针对这种情况也有相应的优化方案：</p>
<h3 id="多个Buffer-Pool"><a href="#多个Buffer-Pool" class="headerlink" title="多个Buffer Pool"></a>多个Buffer Pool</h3><p> Buffer Pool 是可以有多个的，可以通过 MySQL的配置文件来配置，参数分别是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  Buffer Pool  的总大小</span></span><br><span class="line">innodb_buffer_pool_size=8589934592</span><br><span class="line"><span class="comment">#  Buffer Pool  的实例数（个数）</span></span><br><span class="line">innodb_buffer_pool_instance=4</span><br></pre></td></tr></table></figure>

<p>多个BufferPool虽然可以提升并发环境中的性能，但是同样也会面临并发环境的问题：在多个线程访问不同的 Buffer Pool 那不同的线程加载的数据必然是在不同的 Buffer Pool 中，假设 A 线程加载数据页A到 Buffer Pool A 中，B 线程加载数据页B到 Buffer Pool  B 中，然后两个都执行完了，这个时候 C 线程来了，他到达的是 Buffer Pool B中，但是 C 要访问的数据是在 Buffer Pool A中的数据页上了，这个时候 C 还会去加载数据页A吗？，这种情况会发生吗？在不同的 Buffer Pool 缓存中会去缓存相同的数据页吗？</p>
<p>这种情况很显然不会发生，既然不会发生，那 MySql 是如何解决这种问题的？其实前面已经提到过了，那就是数据页缓存哈希表，里面存放的是表空间号+数据页号 = 缓存页地址，所以  <strong>MySQL 在加载数据所在的数据页的时候根据这一系列的映射关系判断数据页是否被加载，被加载到了那个缓存页中</strong>，所以 MySQL 能够精确的确定某个数据页是否被加载，被加载的到了哪个缓存页，绝不可能出现重复加载的情况。</p>
<h3 id="动态调整Buffer-Pool——chunk机制"><a href="#动态调整Buffer-Pool——chunk机制" class="headerlink" title="动态调整Buffer Pool——chunk机制"></a>动态调整Buffer Pool——chunk机制</h3><p>**什么是chunk机制:**chunk是 MySQL 设计的一种机制，这种机制的原理是将 Buffer Pool 拆分一个一个大小相等的 chunk 块，每个 chunk 默认大小为 128M（可以通过参数innodb_buffer_pool_chunk_size 来调整大小），也就是说 Buffer Pool 是由一个个的chunk组成的     假设 Buffer Pool 大小是2GB，而一个chunk大小默认是128M，也就是说一个2GB大小的 Buffer Pool 里面由16个 chunk 组成，每个chunk中有自己的缓存页和描述数据，而 free 链表、flush 链表和 lru 链表是共享的，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/he-You/image/master/image-20231006222218988.png" alt="image-20231006222218988"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
